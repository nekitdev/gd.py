{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"<code>gd.py</code>","text":"<p>An API wrapper for Geometry Dash written in Python.</p>"},{"location":"#installing","title":"Installing","text":"<p>Python 3.7 or above is required.</p>"},{"location":"#pip","title":"pip","text":"<p>Installing the library with <code>pip</code> is quite simple:</p> <pre><code>$ pip install gd.py\n</code></pre> <p>Alternatively, the library can be installed from source:</p> <pre><code>$ git clone https://github.com/nekitdev/gd.py.git\n$ cd gd.py\n$ python -m pip install .\n</code></pre>"},{"location":"#poetry","title":"poetry","text":"<p>You can add <code>gd.py</code> as a dependency with the following command:</p> <pre><code>$ poetry add gd.py\n</code></pre> <p>Or by directly specifying it in the configuration like so:</p> <pre><code>[tool.poetry.dependencies]\n\"gd.py\" = \"^1.0.0\"\n</code></pre> <p>Alternatively, you can add it directly from the source:</p> <pre><code>[tool.poetry.dependencies.\"gd.py\"]\ngit = \"https://github.com/nekitdev/gd.py.git\"\n</code></pre>"},{"location":"#examples","title":"Examples","text":""},{"location":"#fetching","title":"Fetching","text":"<pre><code># file.py\n\nimport asyncio\n\nimport gd\n\nSONG_ID = 1081309\nSONG = \"{} by {} (ID: {}, size: {} MB)\"\n\n\nasync def main() -&gt; None:\n    client = gd.Client()\n\n    song = await client.get_song(SONG_ID)\n\n    print(SONG.format(song.name, song.artist.name, song.id, song.size))\n\n\nasyncio.run(main())\n</code></pre> <pre><code>$ python file.py\nPANDA EYES - BROKEN by PandaEyesOfficial (ID: 1081309, size: 9.71 MB)\n</code></pre>"},{"location":"#listening","title":"Listening","text":"<pre><code>import gd\n\nclient = gd.Client()\n\nDAILY = \"new daily! {daily.name} by {daily.creator.name} (ID: {daily.id})\"\n\n\n@client.event\nasync def on_daily(daily: gd.Level) -&gt; None:\n    print(DAILY.format(daily=daily))\n\n\nclient.listen_for_daily()\n\nclient.create_controller().run()\n</code></pre>"},{"location":"#documentation","title":"Documentation","text":"<p>You can find the documentation here.</p>"},{"location":"#support","title":"Support","text":"<p>If you need support with the library, you can send an email or refer to the official Discord server.</p>"},{"location":"#changelog","title":"Changelog","text":"<p>You can find the changelog here.</p>"},{"location":"#security-policy","title":"Security Policy","text":"<p>You can find the Security Policy of <code>gd.py</code> here.</p>"},{"location":"#contributing","title":"Contributing","text":"<p>If you are interested in contributing to <code>gd.py</code>, make sure to take a look at the Contributing Guide, as well as the Code of Conduct.</p>"},{"location":"#license","title":"License","text":"<p><code>gd.py</code> is licensed under the MIT License terms. See License for details.</p>"},{"location":"changelog/","title":"Changelog","text":""},{"location":"code_of_conduct/","title":"Code of Conduct","text":""},{"location":"code_of_conduct/#our-pledge","title":"Our Pledge","text":"<p>We as members, contributors, and leaders pledge to make participation in our community a harassment-free experience for everyone, regardless of age, body size, visible or invisible disability, ethnicity, sex characteristics, gender identity and expression, level of experience, education, socio-economic status, nationality, personal appearance, race, caste, color, religion, or sexual identity and orientation.</p> <p>We pledge to act and interact in ways that contribute to an open, welcoming, diverse, inclusive, and healthy community.</p>"},{"location":"code_of_conduct/#our-standards","title":"Our Standards","text":"<p>Examples of behavior that contributes to a positive environment for our community include:</p> <ul> <li>Demonstrating empathy and kindness toward other people</li> <li>Being respectful of differing opinions, viewpoints, and experiences</li> <li>Giving and gracefully accepting constructive feedback</li> <li>Accepting responsibility and apologizing to those affected by our mistakes,   and learning from the experience</li> <li>Focusing on what is best not just for us as individuals, but for the overall   community</li> </ul> <p>Examples of unacceptable behavior include:</p> <ul> <li>The use of sexualized language or imagery, and sexual attention or advances of   any kind</li> <li>Trolling, insulting or derogatory comments, and personal or political attacks</li> <li>Public or private harassment</li> <li>Publishing others' private information, such as a physical or email address,   without their explicit permission</li> <li>Other conduct which could reasonably be considered inappropriate in a   professional setting</li> </ul>"},{"location":"code_of_conduct/#enforcement-responsibilities","title":"Enforcement Responsibilities","text":"<p>Community leaders are responsible for clarifying and enforcing our standards of acceptable behavior and will take appropriate and fair corrective action in response to any behavior that they deem inappropriate, threatening, offensive, or harmful.</p> <p>Community leaders have the right and responsibility to remove, edit, or reject comments, commits, code, wiki edits, issues, and other contributions that are not aligned to this Code of Conduct, and will communicate reasons for moderation decisions when appropriate.</p>"},{"location":"code_of_conduct/#scope","title":"Scope","text":"<p>This Code of Conduct applies within all community spaces, and also applies when an individual is officially representing the community in public spaces. Examples of representing our community include using an official email address, posting via an official social media account, or acting as an appointed representative at an online or offline event.</p>"},{"location":"code_of_conduct/#enforcement","title":"Enforcement","text":"<p>Instances of abusive, harassing, or otherwise unacceptable behavior may be reported to the community leaders responsible for enforcement to conduct@nekit.dev.</p> <p>All complaints will be reviewed and investigated promptly and fairly.</p> <p>All community leaders are obligated to respect the privacy and security of the reporter of any incident.</p>"},{"location":"code_of_conduct/#enforcement-guidelines","title":"Enforcement Guidelines","text":"<p>Community leaders will follow these Community Impact Guidelines in determining the consequences for any action they deem in violation of this Code of Conduct:</p>"},{"location":"code_of_conduct/#1-correction","title":"1. Correction","text":"<p>Community Impact: Use of inappropriate language or other behavior deemed unprofessional or unwelcome in the community.</p> <p>Consequence: A private, written warning from community leaders, providing clarity around the nature of the violation and an explanation of why the behavior was inappropriate. A public apology may be requested.</p>"},{"location":"code_of_conduct/#2-warning","title":"2. Warning","text":"<p>Community Impact: A violation through a single incident or series of actions.</p> <p>Consequence: A warning with consequences for continued behavior. No interaction with the people involved, including unsolicited interaction with those enforcing the Code of Conduct, for a specified period of time. This includes avoiding interactions in community spaces as well as external channels like social media. Violating these terms may lead to a temporary or permanent ban.</p>"},{"location":"code_of_conduct/#3-temporary-ban","title":"3. Temporary Ban","text":"<p>Community Impact: A serious violation of community standards, including sustained inappropriate behavior.</p> <p>Consequence: A temporary ban from any sort of interaction or public communication with the community for a specified period of time. No public or private interaction with the people involved, including unsolicited interaction with those enforcing the Code of Conduct, is allowed during this period. Violating these terms may lead to a permanent ban.</p>"},{"location":"code_of_conduct/#4-permanent-ban","title":"4. Permanent Ban","text":"<p>Community Impact: Demonstrating a pattern of violation of community standards, including sustained inappropriate behavior, harassment of an individual, or aggression toward or disparagement of classes of individuals.</p> <p>Consequence: A permanent ban from any sort of public interaction within the community.</p>"},{"location":"code_of_conduct/#attribution","title":"Attribution","text":"<p>This Code of Conduct is adapted from the Contributor Covenant, version 2.1, available at https://contributor-covenant.org/version/2/1/code_of_conduct.</p> <p>Community Impact Guidelines were inspired by Mozilla's Code of Conduct enforcement ladder.</p> <p>For answers to common questions about this code of conduct, see the FAQ at https://contributor-covenant.org/faq. Translations are available at https://contributor-covenant.org/translations.</p>"},{"location":"security/","title":"Security Policy","text":""},{"location":"security/#reporting","title":"Reporting","text":"<p>Thank you for taking the time to responsibly disclose any problems you find.</p> <p>Do not file public issues as they are open for everyone to see!</p> <p>All security vulnerabilities in <code>gd.py</code> should be reported by email to security@nekit.dev. Your report will be acknowledged within 24 hours, and you will receive a more detailed response within 48 hours indicating the next steps in handling your report.</p> <p>You can encrypt your report using our public key: <code>BB2D8194464001E0B9B60EB8741A1EAD20FFDE8A</code>. This key is also available on MIT's Key Server and reproduced below.</p> <p>After the initial reply to your report, the core team will try to keep you informed of the progress being made towards a fix and official announcement. These updates will be sent at least every five days. In reality, this is more likely to be every 24-48 hours.</p>"},{"location":"security/#disclosure-policy","title":"Disclosure Policy","text":"<p><code>gd.py</code> has a 5-step disclosure process:</p> <ol> <li> <p>The security report is received and is assigned a primary handler.    This person will coordinate the fix and release process.</p> </li> <li> <p>The problem is confirmed and a list of all affected versions is determined.</p> </li> <li> <p>Code is audited to find any potential similar problems.</p> </li> <li> <p>Fixes are prepared for all releases which are still under maintenance.    These fixes are not committed to the public repository but rather    held locally pending the announcement.</p> </li> <li> <p>On the embargo date, the changes are pushed to the public repository    and new builds are deployed.</p> </li> </ol> <p>This process can take some time, especially when coordination is required with maintainers of other projects. Every effort will be made to handle the issue in as timely a manner as possible, however it is important that we follow the release process above to ensure that the disclosure is handled in a consistent manner.</p>"},{"location":"security/#security-key","title":"Security Key","text":"<pre><code>-----BEGIN PGP PUBLIC KEY BLOCK-----\n\nmQINBGKJEuEBEAC37iPX5u8sN+DZQ8c4Of+85u/hboSqNLp7VtTGgr/d8RCFhGZk\n25ZwqGWeJbhnlPuzT6u96CZFRe3TMHYJR+A2NZBVjAQQjDRGbIGgaS6/9lvMLcRx\nD+hFQNPgwUTfPhSHIan+9EuYK/Bz+jyyIplwTrIBq1Mo0NG+cUNvAB+he22xhBQ7\ny/Xal+sapHfYedqywhYEQUgP94IGURIMiBlAB7nKW+qs7YiQBShBbfxxffMgK6W6\nsNNSybUQDqjj1AWkOBj5uizkA6FLF80xULypbhe1gbqsIt4d1Lj/mxI5zvj84wy5\noQ6QOpYlBUQwl8kqfszYaqKCviflA+riAFMAE8NVL+5BuVN0QSvQb6cRzIV1SL0p\nMCA6s2+plK/9K+JyR5yyjY7FxvatYNLW5LsubmS+YeBdO4l4A7YEElOGMexUb61H\n3ejlb/9UUrZ7hd09Hsi1J6nthrI26o0XBdB8UJ9QAdfoHWka3fgSgopBBcI+S3tU\niWGngFrUhiXcBS+0xHjrk4USKwFyFr8fmL4Y8Yu31ViHRFj6gVjC/PHP0apCnakB\nUEEMHnAQfztodH9o2ew2kew77+q9VblDGpb3BYaiptl4c6h6WBcEULpRfWERfB8H\nSt4L49Ob6CCNpVw9qgsDfNw2fFjUIsT6OGwJxhv9StIFW2JEhgxEvfHr1wARAQAB\ntC9OaWtpdGEgVGlraG9ub3YgKHNlY3VyaXR5KSA8c2VjdXJpdHlAbmVraXQuZGV2\nPokCUgQTAQgAPAIbAwIXgAIeBxYhBLstgZRGQAHgubYOuHQaHq0g/96KBQJiiR6G\nBQsJCAcCAyICAQYVCgkICwIEFgIDAQAKCRB0Gh6tIP/einfmD/9y69eqwjRfdmnW\ns0ph8Rh99JHtgA+zm1akRl+eymiqLuJwmZge7PPFb68Wj4lI6s1M1dIkyRuYMtIM\n3rEcMmGUlcVnPldx/wdcPyhYZDUXnYCK64dsloftrWFWoSr5a/AILyVh/L6Fkf+L\nRU9h3KPMXhLTyK127ZF5WuzpjSJms0hDMDV/idfiDeWn/VGaZz1Wiks4l8R9kisR\nLI3RKNR537f0KFS8jkqlI41Lj9XQTUdqMRp+eqi/zUMM7OZzKQg1ohDsLi4MR6wa\nbXIu7LeAp1M0XlB+MO09KOxR8i19ST89EapAp4gHprbG5hJyV3XHK4txcWHG0YjB\ng5/fOvytljf/ue5YGe5nQUcxucq6i4d6jsB66Gk/4nnKutlMG2ZtVyIZZZActPZ5\nqKI64HQJOpag+ERXwrv0optEhTC7RHOFRuZ4pCKuVjdJE9W7ZpAIAi8yHeVvpgJY\nglo+DqZH1/kLD1u2Jb/8yUuMeCYc3aBlfZswO6IeMFeXbPaMtIHzY5q7blIdKIAb\nYxS5KCYn8VHG6Nz8lFMu2z4jpH4QY9vTaxZnG3Xp23uxbP0pznih4DMiHIACyCBP\nWgRReZTCVU6Z9FvBq8t/hcrwli33lTa5hkuuzqcojn80+1g9st7DOzxVFtR2MoSS\nWkv8ss8apRyeLNZAM5M8v+AiiyVCrLkCDQRiiRLhARAApEJFgvQVDMYpuo754cRK\nWC/17DH1BQ9y78h/0MXmOOf/0MpzJBkPjn4++BdXQGoOCBleHrWmbtmfYLcQFmZ/\neiUzxFDS/pkC7aZUb+YA7JzcwZQP2yOhlMfFK0qCoQKw/45q+AkOUR+Z+VGExkM1\n5+PAcQ+7cQRiyina6/MG7FHAOcvuEwjiyt/0zBm3izeWmXL0Gngisl1jvd8bGn4T\nbK68q2d09NNHdXJ9UDFdGJ+FVIqJCyLyBl0ZfWazSkD/4ZNchdjFcSOzTTMvqWWn\n6i5awbVyMPZkKS88vRVwTtcjk4+hrzaIyNbTw7y55qQxFe0NEoj4SK+iMwCkax19\nnjGQeB8GqmieC+0WYUSt10xXZ6tDf6a9F2cg6zv1ZklOuYU9x8GYwU7zvhrGhvXU\nUn1ZtP/OaHoQsS/+AS7KJtm/NWHGsfjd8vwDirIoZ31D7X52QrN07NQ0H7+uqtDL\nc7BAhsLI1G/r9Kz0+P0nC/6bMWvQWiomB1BSwUTfXLkT0RoKZ3Yub8XMk46N9XKE\nRtTk5x0/rZ40uOg8wzT1GvwYFA4tpavAqLejOftE05lKXAb5tQhYRupZywzXM6HN\nDR7CbP1e26g0p8GAuz1aFny6cN8T3wTHHyYn7aQk7i1BboV8zFpVlF6EmoHNCZtG\nhkl28kYa0Yvu+9mw0SPNiIsAEQEAAYkCNgQYAQgAIBYhBLstgZRGQAHgubYOuHQa\nHq0g/96KBQJiiRLhAhsMAAoJEHQaHq0g/96KeCoP/3i3A629wvjPn7m3y7pTcV8p\nriTlH5OeXhg4jCORgJrgL4PSoeFCITA0u0djtcvctmCrHMsZe0hyH5+X+/B9Bsf6\neFQKWXLidqkxD/M6lnE6t34d17DvaWCP27MsS/f0u0FsLom11TTFgp4wGKZfRBNH\nvX5xuhjoYXYwZwWqCYyEXFTbsUTDce2oaqc7Yw/GmM3fCodLX0/0eYh5u2fiKA57\n7VuUWD74/TkgcEOMa/IZ/jPmJHuHOteaIJR0pYUvLQ1EJh3jI4LhmH8DqxoUrmKy\n8z2VM0iLIiev86EXM+yzqTpRIFnm6Ts+47L18rb9D5IUo68gr5B2bMKPOfvMVzdN\n/vw2RKdCVJ70nh3qqRis5RsJrn/3T8H1CQtuPvsAd/oB86YGWPpWBtpTyI+VBp+x\n+XR434K8D9QXFst73wTCnQwSX6j0sIotQC5GsPJEKky2Wijg3BlxqTxtYjLhwKWg\nx3e63TEw7IgU+lE/ybzWLJ7EndbKsC7stZh+Lyh5b3YHgI3cfJUxjZNFpniKr/Fy\n4EjjLZzFf3QRmNNJ/7VlYLYztGZsOWxRsLk7QfUPSZY4iHUr8aiwfL7IFwnAlzIo\n36HDjJi80UakMlf45UcxRaJwWiaj7G4x3h1D1BZLtMiypiaw/mesrithmfHg+KYu\n1oYi7ft0FnZ67Wnk5+E+\n=VRe2\n-----END PGP PUBLIC KEY BLOCK-----\n</code></pre>"},{"location":"security/#attribution","title":"Attribution","text":"<p>This Security Policy is adapted from Rust's Security Policy.</p>"},{"location":"reference/artist/","title":"Artist","text":""},{"location":"reference/artist/#gd.artist.Artist","title":"<code>Artist</code>","text":"<p>         Bases: <code>Entity</code></p> <p>Represents artists on Newgrounds.</p> Binary <pre><code>struct Artist {\nname_length: u8,\nname: [u8; name_length],  // utf-8 string\n}\n</code></pre> Source code in <code>gd/artist.py</code> <pre><code>@register_unstructure_hook_omit_id_and_client\n@define()\nclass Artist(Entity):\n\"\"\"Represents artists on *Newgrounds*.\n\n    Binary:\n        ```rust\n        struct Artist {\n            name_length: u8,\n            name: [u8; name_length],  // utf-8 string\n        }\n        ```\n    \"\"\"\n\n    name: str = field(eq=False)\n\n    id: int = field(repr=False, init=False)\n\n    @id.default\n    def default_id(self) -&gt; int:\n        return hash(self.id_name)\n\n    @property\n    def url(self) -&gt; URL:\n        return URL(ARTIST.format(self.id_name))\n\n    @property\n    def id_name(self) -&gt; str:\n        return clear_whitespace(case_fold(self.name))\n\n    @classmethod\n    def default(cls: Type[A]) -&gt; A:\n        return cls(name=UNKNOWN)\n\n    def __hash__(self) -&gt; int:\n        return hash(type(self)) ^ self.id\n\n    def __str__(self) -&gt; str:\n        return self.name\n\n    @classmethod\n    def from_model(cls: Type[A], model: ArtistModel) -&gt; A:\n        return cls(name=model.name)\n\n    @classmethod\n    def from_data(cls: Type[A], data: ArtistData) -&gt; A:  # type: ignore\n        return CONVERTER.structure(data, cls)\n\n    def into_data(self) -&gt; ArtistData:  # type: ignore\n        return CONVERTER.unstructure(self)  # type: ignore\n\n    @classmethod\n    def from_binary(\n        cls: Type[A],\n        binary: BinaryReader,\n        order: ByteOrder = ByteOrder.DEFAULT,\n        version: int = VERSION,\n        encoding: str = DEFAULT_ENCODING,\n        errors: str = DEFAULT_ERRORS,\n    ) -&gt; A:\n        reader = Reader(binary, order)\n\n        length = reader.read_u8()\n\n        data = reader.read(length)\n\n        name = data.decode(encoding, errors)\n\n        return cls(name=name)\n\n    def to_binary(\n        self,\n        binary: BinaryWriter,\n        order: ByteOrder = ByteOrder.DEFAULT,\n        version: int = VERSION,\n        encoding: str = DEFAULT_ENCODING,\n        errors: str = DEFAULT_ERRORS,\n    ) -&gt; None:\n        writer = Writer(binary, order)\n\n        data = self.name.encode(encoding, errors)\n\n        writer.write_u8(len(data))\n\n        writer.write(data)\n\n    @wrap_async_iter\n    def get_songs_on_page(self, page: int = DEFAULT_PAGE) -&gt; AsyncIterator[Song]:\n        return self.client.get_newgrounds_artist_songs_on_page(self, page=page).unwrap()\n\n    @wrap_async_iter\n    def get_songs(self, pages: Iterable[int] = DEFAULT_PAGES) -&gt; AsyncIterator[Song]:\n        return self.client.get_newgrounds_artist_songs(self, pages=pages).unwrap()\n</code></pre>"},{"location":"reference/client/","title":"Client","text":""},{"location":"reference/client/#gd.client.Client","title":"<code>Client</code>","text":"Source code in <code>gd/client.py</code> <pre><code>@define(slots=False)\nclass Client:\n    session: Session = field(factory=Session)\n\"\"\"The session of the client.\"\"\"\n\n    credentials: Credentials = field(factory=Credentials)\n\"\"\"The credentials of the client.\"\"\"\n\n    database_unchecked: Optional[Database] = field(default=None, repr=False)\n\"\"\"The database of the client.\"\"\"\n\n    load_after_post: bool = field(default=DEFAULT_LOAD_AFTER_POST)\n\"\"\"Whether to load items after posting them.\"\"\"\n\n    _listeners: DynamicTuple[Listener] = field(default=(), repr=False, init=False)\n    _controller: Optional[Controller] = field(default=None, repr=False, init=False)\n\n    def apply_items(\n        self: C,\n        credentials: Optional[Credentials] = None,\n        database: Optional[Database] = None,\n        credentials_type: Type[Credentials] = Credentials,\n    ) -&gt; C:\n        if credentials is None:\n            self.credentials = credentials_type()\n\n        else:\n            self.credentials = credentials\n\n        self.database_unchecked = database\n\n        return self\n\n    @property\n    def database(self) -&gt; Database:\n        database = self.database_unchecked\n\n        if database is None:\n            raise ValueError(NO_DATABASE)\n\n        return database\n\n    @database.setter\n    def database(self, database: Database) -&gt; None:\n        self.database_unchecked = database\n\n    @database.deleter\n    def database(self) -&gt; None:\n        self.database_unchecked = None\n\n    def reset_items(self: C) -&gt; C:\n        return self.apply_items()\n\n    def is_logged_in(self) -&gt; bool:\n\"\"\"Checks if the client is logged in.\n\n        Returns:\n            Whether the client is logged in.\n        \"\"\"\n        return self.credentials.is_loaded()\n\n    def run(self, awaitable: Awaitable[T]) -&gt; T:\n        return run(awaiting(awaitable))\n\n    @property\n    def account_id(self) -&gt; int:\n\"\"\"The account ID of the client.\"\"\"\n        return self.credentials.account_id\n\n    @property\n    def id(self) -&gt; int:\n\"\"\"The user ID of the client.\"\"\"\n        return self.credentials.id\n\n    @property\n    def name(self) -&gt; str:\n\"\"\"The name of the client.\"\"\"\n        return self.credentials.name\n\n    @property\n    def password(self) -&gt; str:\n\"\"\"The password of the client.\"\"\"\n        return self.credentials.password\n\n    @property\n    def http(self) -&gt; HTTPClient:\n\"\"\"The [`HTTPClient`][gd.http.HTTPClient] used by the client session.\"\"\"\n        return self.session.http\n\n    @property\n    def encoded_password(self) -&gt; str:\n\"\"\"The encoded password of the client.\"\"\"\n        return encode_robtop_string(self.password, Key.USER_PASSWORD)\n\n    @property\n    @check_login\n    def user(self) -&gt; User:\n\"\"\"The user representing the client.\"\"\"\n        return User(id=self.id, name=self.name, account_id=self.account_id).attach_client(self)\n\n    async def ping(self) -&gt; Duration:\n\"\"\"Pings the Geometry Dash server.\n\n        Returns:\n            The [`Duration`][gd.date_time.Duration] representing the latency.\n        \"\"\"\n        return await self.ping_url(self.http.url)\n\n    async def ping_url(self, url: URLString) -&gt; Duration:\n\"\"\"Pings the given `url`.\n\n        Returns:\n            The [`Duration`][gd.date_time.Duration] representing the latency.\n        \"\"\"\n        return await self.session.ping(url)\n\n    async def logout(self) -&gt; None:\n\"\"\"Performs the logout.\"\"\"\n        self.reset_items()\n\n    def login(self: C, name: str, password: str) -&gt; LoginContextManager[C]:\n\"\"\"Performs the login.\n\n        This function returns a context manager that can be used for temporarily logging in:\n\n        ```python\n        async with client.login(name, password):\n            assert client.is_logged_in()\n\n        assert not client.is_logged_in()\n        ```\n\n        Returns:\n            The [`LoginContextManager`][gd.client.LoginContextManager] for handling login process.\n        \"\"\"\n        return LoginContextManager(self, name, password)\n\n    async def try_login(self, name: str, password: str) -&gt; None:\n        model = await self.session.login(name, password)\n\n        self.apply_items(Credentials(model.account_id, model.id, name, password))\n\n    def unsafe_login(self: C, name: str, password: str) -&gt; UnsafeLoginContextManager[C]:\n\"\"\"Performs the *unsafe* login.\n\n        *Unsafe* means that the credentials are not confirmed.\n\n        This function returns a context manager that can be used for temporarily logging in:\n\n        ```python\n        async with client.unsafe_login(name, password):\n            assert client.is_logged_in()\n\n        assert not client.is_logged_in()\n        ```\n\n        Returns:\n            The [`UnsafeLoginContextManager`][gd.client.UnsafeLoginContextManager]\n                for handling login process.\n        \"\"\"\n        return UnsafeLoginContextManager(self, name, password)\n\n    async def try_unsafe_login(self, name: str, password: str) -&gt; None:\n        user = await self.search_user(name, simple=True)\n\n        self.apply_items(Credentials(user.account_id, user.id, name, password))\n\n    @check_login\n    async def load(self) -&gt; Database:\n\"\"\"Loads the save from the cloud, saving it in the\n        [`database`][gd.client.Client.database] attribute.\n\n        Note:\n            This function requires the client to be logged in.\n\n        Returns:\n            The [`Database`][gd.api.database.Database] loaded.\n        \"\"\"\n        database = await self.session.load(\n            account_id=self.account_id, name=self.name, password=self.password\n        )\n\n        self.database = database\n\n        return database\n\n    @check_login\n    async def save(self, database: Optional[Database] = None) -&gt; None:\n\"\"\"Saves the the `database` to the cloud, optionally fetching it from the\n        [`database`][gd.client.Client.database] attribute.\n\n        Note:\n            This function requires the client to be logged in.\n        \"\"\"\n        if database is None:\n            database = self.database\n\n        await self.session.save(\n            database, account_id=self.account_id, name=self.name, password=self.password\n        )\n\n    async def get_account_url(self, account_id: int, type: AccountURLType) -&gt; URL:\n        return await self.session.get_account_url(account_id=account_id, type=type)\n\n    @check_login\n    async def update_profile(\n        self,\n        stars: Optional[int] = None,\n        diamonds: Optional[int] = None,\n        secret_coins: Optional[int] = None,\n        user_coins: Optional[int] = None,\n        demons: Optional[int] = None,\n        icon_type: Optional[IconType] = None,\n        icon_id: Optional[int] = None,\n        color_1_id: Optional[int] = None,\n        color_2_id: Optional[int] = None,\n        glow: Optional[bool] = None,\n        cube_id: Optional[int] = None,\n        ship_id: Optional[int] = None,\n        ball_id: Optional[int] = None,\n        ufo_id: Optional[int] = None,\n        wave_id: Optional[int] = None,\n        robot_id: Optional[int] = None,\n        spider_id: Optional[int] = None,\n        # swing_copter_id: Optional[int] = None,\n        explosion_id: Optional[int] = None,\n        special: int = DEFAULT_SPECIAL,\n        *,\n        set_as_user: Optional[User] = None,\n    ) -&gt; None:\n        if set_as_user is None:\n            user = await self.get_self()\n\n        else:\n            user = set_as_user\n\n        await self.session.update_profile(\n            stars=switch_none(stars, user.stars),\n            diamonds=switch_none(diamonds, user.diamonds),\n            secret_coins=switch_none(secret_coins, user.secret_coins),\n            user_coins=switch_none(user_coins, user.user_coins),\n            demons=switch_none(demons, user.demons),\n            icon_type=switch_none(icon_type, user.icon_type),\n            icon_id=switch_none(icon_id, user.icon_id),\n            color_1_id=switch_none(color_1_id, user.color_1_id),\n            color_2_id=switch_none(color_2_id, user.color_2_id),\n            glow=switch_none(glow, user.glow),\n            cube_id=switch_none(cube_id, user.cube_id),\n            ship_id=switch_none(ship_id, user.ship_id),\n            ball_id=switch_none(ball_id, user.ball_id),\n            ufo_id=switch_none(ufo_id, user.ufo_id),\n            wave_id=switch_none(wave_id, user.wave_id),\n            robot_id=switch_none(robot_id, user.robot_id),\n            spider_id=switch_none(spider_id, user.spider_id),\n            # swing_copter_id=switch_none(swing_copter_id, user.swing_copter_id),\n            explosion_id=switch_none(explosion_id, user.explosion_id),\n            special=special,\n            account_id=self.account_id,\n            name=self.name,\n            encoded_password=self.encoded_password,\n        )\n\n    @check_login\n    async def update_settings(\n        self,\n        message_state: Optional[MessageState] = None,\n        friend_request_state: Optional[FriendRequestState] = None,\n        comment_state: Optional[CommentState] = None,\n        youtube: Optional[str] = None,\n        twitter: Optional[str] = None,\n        twitch: Optional[str] = None,\n        # discord: Optional[str] = None,\n        *,\n        set_as_user: Optional[User] = None,\n    ) -&gt; None:\n        if set_as_user is None:\n            user = await self.get_self(simple=True)\n\n        else:\n            user = set_as_user\n\n        await self.session.update_settings(\n            message_state=switch_none(message_state, user.message_state),\n            friend_request_state=switch_none(friend_request_state, user.friend_request_state),\n            comment_state=switch_none(comment_state, user.comment_state),\n            youtube=switch_none(youtube, user.youtube),\n            twitter=switch_none(twitter, user.twitter),\n            twitch=switch_none(twitch, user.twitch),\n            # discord=switch_none(discord, user.discord),\n            account_id=self.account_id,\n            encoded_password=self.encoded_password,\n        )\n\n    @check_login\n    async def get_self(self, simple: bool = DEFAULT_SIMPLE) -&gt; User:\n\"\"\"Gets the user representing this client.\n\n        This is a shorthand for:\n\n        ```python\n        await client.user.get(simple=simple)\n        ```\n\n        See [`User.get`][gd.user.User.get] for more information.\n\n        Note:\n            This function requires the client to be logged in.\n\n        Arguments:\n            simple: Whether to fetch simple information.\n\n        Returns:\n            The [`User`][gd.user.User] representing the client.\n        \"\"\"\n        return await self.user.get(simple=simple)\n\n    async def get_user(\n        self,\n        account_id: int,\n        simple: bool = DEFAULT_SIMPLE,\n        friend_state: bool = DEFAULT_FRIEND_STATE,\n    ) -&gt; User:\n\"\"\"Fetches the user by `account_id`.\n\n        Arguments:\n            account_id: The account ID of the user to fetch.\n            simple: Whether to fetch simple information only.\n            friend_state: Whether to fetch friend state.\n\n        Note:\n            `friend_state` requires the client to be logged in.\n\n        Returns:\n            The [`User`][gd.user.User] fetched.\n        \"\"\"\n        if friend_state:  # if we need to fetch friend state\n            check_client_login(self)\n\n            profile_model = await self.session.get_user_profile(  # request profile\n                account_id=account_id,\n                client_account_id=self.account_id,\n                encoded_password=self.encoded_password,\n            )\n\n        else:  # otherwise, simply request normally\n            profile_model = await self.session.get_user_profile(account_id=account_id)\n\n        if simple:  # if only the profile is needed, return right away\n            return User.from_profile_model(profile_model).attach_client(self)\n\n        search_model = await self.session.search_user(profile_model.id)  # search by ID\n\n        return User.from_search_user_and_profile_models(search_model, profile_model).attach_client(\n            self\n        )\n\n    async def search_user(\n        self,\n        query: IntString,\n        simple: bool = DEFAULT_SIMPLE,\n        friend_state: bool = DEFAULT_FRIEND_STATE,\n    ) -&gt; User:\n        search_user_model = await self.session.search_user(query=query)  # search using query\n\n        if simple:  # if only simple is required, return right away\n            return User.from_search_user_model(search_user_model)\n\n        if friend_state:  # if friend state is requested\n            check_client_login(self)  # assert client is logged in\n\n            profile_model = await self.session.get_user_profile(  # request profile\n                search_user_model.account_id,\n                client_account_id=self.account_id,\n                encoded_password=self.encoded_password,\n            )\n\n        else:  # otherwise, request normally\n            profile_model = await self.session.get_user_profile(\n                account_id=search_user_model.account_id\n            )\n\n        return User.from_search_user_and_profile_models(\n            search_user_model, profile_model\n        ).attach_client(self)\n\n    @wrap_async_iter\n    async def search_users_on_page(\n        self, query: IntString, page: int = DEFAULT_PAGE\n    ) -&gt; AsyncIterator[User]:\n        search_users_response_model = await self.session.search_users_on_page(\n            query=query, page=page\n        )\n\n        for search_user_model in search_users_response_model.users:\n            yield User.from_search_user_model(search_user_model).attach_client(self)\n\n    @wrap_async_iter\n    def search_users(\n        self,\n        query: IntString,\n        pages: Iterable[int] = DEFAULT_PAGES,\n    ) -&gt; AsyncIterator[User]:\n        return run_iterables(\n            (self.search_users_on_page(query=query, page=page).unwrap() for page in pages),\n            ClientError,\n        )\n\n    @wrap_async_iter\n    @check_login\n    async def get_simple_relationships(self, type: SimpleRelationshipType) -&gt; AsyncIterator[User]:\n        try:\n            response_model = await self.session.get_simple_relationships(\n                type=type,\n                account_id=self.account_id,\n                encoded_password=self.encoded_password,\n            )\n\n        except NothingFound:\n            return\n\n        for model in response_model.users:\n            yield User.from_relationship_user_model(model).attach_client(self)\n\n    @wrap_async_iter\n    @check_login\n    def get_friends(self) -&gt; AsyncIterator[User]:\n        return self.get_simple_relationships(SimpleRelationshipType.FRIEND).unwrap()\n\n    @wrap_async_iter\n    @check_login\n    def get_blocked(self) -&gt; AsyncIterator[User]:\n        return self.get_simple_relationships(SimpleRelationshipType.BLOCKED).unwrap()\n\n    @wrap_async_iter\n    @check_login\n    async def get_relationships(self) -&gt; AsyncIterator[Relationship]:\n        async for friend in self.get_friends():\n            yield friend.into_relationship(RelationshipType.FRIEND)\n\n        async for blocked in self.get_blocked():\n            yield blocked.into_relationship(RelationshipType.BLOCKED)\n\n        async for friend_request in self.get_friend_requests(type=FriendRequestType.INCOMING):\n            yield friend_request.into_relationship()\n\n        async for friend_request in self.get_friend_requests(type=FriendRequestType.OUTGOING):\n            yield friend_request.into_relationship()\n\n    @wrap_async_iter\n    async def get_leaderboard(\n        self,\n        strategy: LeaderboardStrategy = LeaderboardStrategy.DEFAULT,\n        count: int = DEFAULT_COUNT,\n    ) -&gt; AsyncIterator[LeaderboardUser]:\n        response_model = await self.session.get_leaderboard(\n            strategy=strategy,\n            count=count,\n            account_id=self.account_id,\n            encoded_password=self.encoded_password,\n        )\n\n        for model in response_model.users:\n            yield LeaderboardUser.from_leaderboard_user_model(model).attach_client(self)\n\n    def level_models_from_model(\n        self, response_model: SearchLevelsResponseModel\n    ) -&gt; Iterator[Tuple[LevelModel, User, Song]]:\n        songs = (Song.from_model(model).attach_client(self) for model in response_model.songs)\n        creators = (\n            User.from_creator_model(model).attach_client(self) for model in response_model.creators\n        )\n\n        id_to_song = {song.id: song for song in songs}\n        id_to_creator = {creator.id: creator for creator in creators}\n\n        for model in response_model.levels:\n            song = id_to_song.get(model.custom_song_id)\n\n            if song is None:\n                song = Song.official(model.official_song_id, server_style=True).attach_client(self)\n\n            creator = id_to_creator.get(model.creator_id)\n\n            if creator is None:\n                creator = User.default().attach_client(self)\n\n            yield (model, creator, song)\n\n    async def get_daily(self, use_client: bool = DEFAULT_USE_CLIENT) -&gt; Level:\n        return await self.get_timely(TimelyType.DAILY, use_client=use_client)\n\n    async def get_weekly(self, use_client: bool = DEFAULT_USE_CLIENT) -&gt; Level:\n        return await self.get_timely(TimelyType.WEEKLY, use_client=use_client)\n\n    # async def get_event(self, use_client: bool = DEFAULT_USE_CLIENT) -&gt; Level:\n    #     return await self.get_timely(TimelyType.EVENT, use_client=use_client)\n\n    async def get_timely(self, type: TimelyType, use_client: bool = DEFAULT_USE_CLIENT) -&gt; Level:\n        timely_model = await self.session.get_timely_info(type=type)\n\n        level = await self.get_level(type.into_timely_id().value)\n\n        return level.update_with_timely_model(timely_model)\n\n    async def get_level(\n        self,\n        level_id: int,\n        get_data: bool = DEFAULT_GET_DATA,\n        use_client: bool = DEFAULT_USE_CLIENT,\n    ) -&gt; Level:\n        get_data = get_data or level_id &lt; 0\n\n        if get_data:\n            if use_client:\n                check_client_login(self)\n\n                response_model = await self.session.get_level(\n                    level_id=level_id,\n                    account_id=self.account_id,\n                    encoded_password=self.encoded_password,\n                )\n\n            else:\n                response_model = await self.session.get_level(level_id)\n\n            model = response_model.level\n\n            level_id = model.id\n\n        level = await self.search_levels_on_page(level_id).next().extract()\n\n        if level is None:\n            raise InternalError  # TODO: message?\n\n        if get_data:\n            return Level.from_model(model, level.creator, level.song).attach_client(self)\n\n        return level\n\n    @wrap_async_iter\n    async def search_levels_on_page(\n        self,\n        query: Optional[MaybeIterable[IntString]] = None,\n        page: int = DEFAULT_PAGE,\n        filters: Optional[Filters] = None,\n        user: Optional[User] = None,\n        gauntlet: Optional[int] = None,\n    ) -&gt; AsyncIterator[Level]:\n        if user is None:\n            user_id = None\n\n        else:\n            user_id = user.id\n\n        try:\n            response_model = await self.session.search_levels_on_page(\n                query=query,\n                page=page,\n                filters=filters,\n                user_id=user_id,\n                gauntlet=gauntlet,\n                client_account_id=self.account_id,\n                client_user_id=self.id,\n                encoded_password=self.encoded_password,\n            )\n\n        except NothingFound:\n            return\n\n        for model, creator, song in self.level_models_from_model(response_model):\n            yield Level.from_model(model, creator, song).attach_client(self)\n\n    @wrap_async_iter\n    def search_levels(\n        self,\n        query: Optional[Union[int, str]] = None,\n        pages: Iterable[int] = DEFAULT_PAGES,\n        filters: Optional[Filters] = None,\n        user: Optional[User] = None,\n        gauntlet: Optional[int] = None,\n    ) -&gt; AsyncIterator[Level]:\n        return run_iterables(\n            (\n                self.search_levels_on_page(\n                    query=query,\n                    page=page,\n                    filters=filters,\n                    user=user,\n                    gauntlet=gauntlet,\n                ).unwrap()\n                for page in pages\n            ),\n            ClientError,\n        )\n\n    @check_login\n    async def update_level_description(self, level: Level, description: Optional[str]) -&gt; None:\n        await self.session.update_level_description(\n            level_id=level.id,\n            description=description,\n            account_id=self.account_id,\n            encoded_password=self.encoded_password,\n        )\n\n    async def upload_level(\n        self,\n        name: str = UNNAMED,\n        id: int = DEFAULT_ID,\n        version: int = DEFAULT_VERSION,\n        length: LevelLength = LevelLength.DEFAULT,\n        official_song_id: int = DEFAULT_ID,\n        description: str = EMPTY,\n        song_id: int = DEFAULT_ID,\n        original_id: int = DEFAULT_ID,\n        two_player: bool = DEFAULT_TWO_PLAYER,\n        privacy: LevelPrivacy = LevelPrivacy.DEFAULT,\n        object_count: int = DEFAULT_OBJECT_COUNT,\n        coins: int = DEFAULT_COINS,\n        stars: int = DEFAULT_STARS,\n        low_detail: bool = DEFAULT_LOW_DETAIL,\n        password: Optional[Password] = None,\n        recording: Optional[Recording] = None,\n        editor_time: Optional[Duration] = None,\n        copies_time: Optional[Duration] = None,\n        data: str = EMPTY,\n    ) -&gt; Level:\n        level_id = await self.session.upload_level(\n            name=name,\n            id=id,\n            version=version,\n            length=length,\n            official_song_id=official_song_id,\n            song_id=song_id,\n            description=description,\n            original_id=original_id,\n            two_player=two_player,\n            object_count=object_count,\n            coins=coins,\n            stars=stars,\n            privacy=privacy,\n            low_detail=low_detail,\n            password=password,\n            recording=recording,\n            editor_time=editor_time,\n            copies_time=copies_time,\n            data=data,\n            account_id=self.account_id,\n            account_name=self.name,\n            encoded_password=self.encoded_password,\n        )\n\n        if self.load_after_post:\n            return await self.get_level(level_id)\n\n        level = Level.default()\n\n        level.id = level_id\n\n        return level\n\n    async def report_level(self, level: Level) -&gt; None:\n        await self.session.report_level(level.id)\n\n    @check_login\n    async def delete_level(self, level: Level) -&gt; None:\n        await self.session.delete_level(\n            level_id=level.id, account_id=self.account_id, encoded_password=self.encoded_password\n        )\n\n    @check_login\n    async def rate_level(self, level: Level, stars: int) -&gt; None:\n        await self.session.rate_level(\n            level_id=level.id,\n            stars=stars,\n            account_id=self.account_id,\n            encoded_password=self.encoded_password,\n        )\n\n    @check_login\n    async def rate_demon(self, level: Level, rating: DemonDifficulty) -&gt; None:\n        await self.session.rate_demon(\n            level_id=level.id,\n            rating=rating,\n            account_id=self.account_id,\n            encoded_password=self.encoded_password,\n        )\n\n    @check_login\n    async def suggest_demon(self, level: Level, rating: DemonDifficulty) -&gt; None:\n        await self.session.suggest_demon(\n            level_id=level.id,\n            rating=rating,\n            account_id=self.account_id,\n            encoded_password=self.encoded_password,\n        )\n\n    @check_login\n    async def suggest_level(self, level: Level, stars: int, feature: bool) -&gt; None:\n        return await self.session.suggest_level(\n            level_id=level.id,\n            stars=stars,\n            feature=feature,\n            account_id=self.account_id,\n            encoded_password=self.encoded_password,\n        )\n\n    @wrap_async_iter\n    @check_login\n    async def get_level_leaderboard(\n        self,\n        level: Level,\n        strategy: LevelLeaderboardStrategy = LevelLeaderboardStrategy.ALL,\n    ) -&gt; AsyncIterator[LevelLeaderboardUser]:\n        response_model = await self.session.get_level_leaderboard(\n            level_id=level.id,\n            strategy=strategy,\n            account_id=self.account_id,\n            encoded_password=self.encoded_password,\n        )\n\n        for model in response_model.users:\n            yield LevelLeaderboardUser.from_level_leaderboard_user_model(model).attach_client(self)\n\n    @check_login\n    async def block_user(self, user: User) -&gt; None:\n        await self.session.block_user(\n            account_id=user.account_id,\n            client_account_id=self.account_id,\n            encoded_password=self.encoded_password,\n        )\n\n    @check_login\n    async def unblock_user(self, user: User) -&gt; None:\n        await self.session.unblock_user(\n            account_id=user.account_id,\n            client_account_id=self.account_id,\n            encoded_password=self.encoded_password,\n        )\n\n    @check_login\n    async def unfriend_user(self, user: User) -&gt; None:\n        await self.session.unfriend_user(\n            account_id=user.account_id,\n            client_account_id=self.account_id,\n            encoded_password=self.encoded_password,\n        )\n\n    @check_login\n    async def send_message(\n        self, user: User, subject: Optional[str] = None, content: Optional[str] = None\n    ) -&gt; Optional[Message]:\n        await self.session.send_message(\n            account_id=user.account_id,\n            subject=subject,\n            content=content,\n            client_account_id=self.account_id,\n            encoded_password=self.encoded_password,\n        )\n\n        if self.load_after_post:\n            if subject is None:\n                subject = EMPTY\n\n            messages = self.get_messages_on_page(MessageType.OUTGOING)\n            message = await messages.find(by_subject_and_user(subject, user)).extract()\n\n            if message is None:\n                return message\n\n            message.content = content\n\n            return message\n\n        return None\n\n    @check_login\n    async def get_message(self, message_id: int, type: MessageType) -&gt; Message:\n        model = await self.session.get_message(\n            message_id=message_id,\n            type=type,\n            account_id=self.account_id,\n            encoded_password=self.encoded_password,\n        )\n\n        return Message.from_model(model).attach_client(self)\n\n    @check_login\n    async def delete_message(self, message: Message) -&gt; None:\n        await self.session.delete_message(\n            message_id=message.id,\n            type=message.type,\n            account_id=self.account_id,\n            encoded_password=self.encoded_password,\n        )\n\n    @wrap_async_iter\n    @check_login\n    async def get_messages_on_page(\n        self, type: MessageType = MessageType.DEFAULT, page: int = DEFAULT_PAGE\n    ) -&gt; AsyncIterator[Message]:\n        try:\n            response_model = await self.session.get_messages_on_page(\n                type=type,\n                page=page,\n                account_id=self.account_id,\n                encoded_password=self.encoded_password,\n            )\n\n        except NothingFound:\n            return\n\n        for model in response_model.messages:\n            yield Message.from_model(model).attach_client(self)\n\n    @wrap_async_iter\n    @check_login\n    def get_messages(\n        self,\n        type: MessageType = MessageType.DEFAULT,\n        pages: Iterable[int] = DEFAULT_PAGES,\n    ) -&gt; AsyncIterator[Message]:\n        return run_iterables(\n            (self.get_messages_on_page(type=type, page=page).unwrap() for page in pages),\n            ClientError,\n        )\n\n    @check_login\n    async def send_friend_request(\n        self, user: User, message: Optional[str] = None\n    ) -&gt; Optional[FriendRequest]:\n        await self.session.send_friend_request(\n            account_id=user.account_id,\n            message=message,\n            client_account_id=self.account_id,\n            encoded_password=self.encoded_password,\n        )\n\n        if self.load_after_post:\n            friend_requests = self.get_friend_requests_on_page(FriendRequestType.OUTGOING)\n\n            return await friend_requests.find(by_user(user)).extract()\n\n        return None\n\n    @check_login\n    async def delete_friend_request(self, friend_request: FriendRequest) -&gt; None:\n        await self.session.delete_friend_request(\n            account_id=friend_request.user.account_id,\n            type=friend_request.type,\n            client_account_id=self.account_id,\n            encoded_password=self.encoded_password,\n        )\n\n    @check_login\n    async def accept_friend_request(self, friend_request: FriendRequest) -&gt; None:\n        await self.session.accept_friend_request(\n            account_id=friend_request.user.account_id,\n            request_id=friend_request.id,\n            type=friend_request.type,\n            client_account_id=self.account_id,\n            encoded_password=self.encoded_password,\n        )\n\n    @check_login\n    async def read_friend_request(self, friend_request: FriendRequest) -&gt; None:\n        await self.session.read_friend_request(\n            request_id=friend_request.id,\n            account_id=self.account_id,\n            encoded_password=self.encoded_password,\n        )\n\n    @wrap_async_iter\n    @check_login\n    async def get_friend_requests_on_page(\n        self,\n        type: FriendRequestType = FriendRequestType.DEFAULT,\n        page: int = DEFAULT_PAGE,\n    ) -&gt; AsyncIterator[FriendRequest]:\n        try:\n            response_model = await self.session.get_friend_requests_on_page(\n                type=type,\n                page=page,\n                account_id=self.account_id,\n                encoded_password=self.encoded_password,\n            )\n\n        except NothingFound:\n            return\n\n        for model in response_model.friend_requests:\n            yield FriendRequest.from_model(model, type).attach_client(self)\n\n    @wrap_async_iter\n    @check_login\n    def get_friend_requests(\n        self,\n        type: FriendRequestType = FriendRequestType.DEFAULT,\n        pages: Iterable[int] = DEFAULT_PAGES,\n    ) -&gt; AsyncIterator[FriendRequest]:\n        return run_iterables(\n            (self.get_friend_requests_on_page(type=type, page=page).unwrap() for page in pages),\n            ClientError,\n        )\n\n    @check_login\n    async def like_level(self, level: Level) -&gt; None:\n        await self.session.like_level(\n            level.id,\n            dislike=False,\n            account_id=self.account_id,\n            encoded_password=self.encoded_password,\n        )\n\n    @check_login\n    async def dislike_level(self, level: Level) -&gt; None:\n        await self.session.like_level(\n            level.id,\n            dislike=True,\n            account_id=self.account_id,\n            encoded_password=self.encoded_password,\n        )\n\n    @check_login\n    async def like_user_comment(self, comment: UserComment) -&gt; None:\n        await self.session.like_user_comment(\n            comment.id,\n            dislike=False,\n            account_id=self.account_id,\n            encoded_password=self.encoded_password,\n        )\n\n    @check_login\n    async def dislike_user_comment(self, comment: UserComment) -&gt; None:\n        await self.session.like_user_comment(\n            comment.id,\n            dislike=True,\n            account_id=self.account_id,\n            encoded_password=self.encoded_password,\n        )\n\n    @check_login\n    async def like_level_comment(self, comment: LevelComment) -&gt; None:\n        await self.session.like_level_comment(\n            comment.id,\n            comment.level.id,\n            dislike=False,\n            account_id=self.account_id,\n            encoded_password=self.encoded_password,\n        )\n\n    @check_login\n    async def dislike_level_comment(self, comment: LevelComment) -&gt; None:\n        await self.session.like_level_comment(\n            comment.id,\n            comment.level.id,\n            dislike=True,\n            account_id=self.account_id,\n            encoded_password=self.encoded_password,\n        )\n\n    @check_login\n    async def post_comment(self, content: Optional[str] = None) -&gt; Optional[UserComment]:\n        comment_id = await self.session.post_user_comment(\n            content=content,\n            account_id=self.account_id,\n            account_name=self.name,\n            encoded_password=self.encoded_password,\n        )\n\n        if self.load_after_post:\n            comments = self.user.get_comments_on_page()\n\n            return await comments.find(by_id(comment_id)).extract()\n\n        return None\n\n    @check_login\n    async def post_level_comment(\n        self, level: Level, content: Optional[str] = None, record: int = DEFAULT_RECORD\n    ) -&gt; Optional[LevelComment]:\n        comment_id = await self.session.post_level_comment(\n            level_id=level.id,\n            content=content,\n            record=record,\n            account_id=self.account_id,\n            account_name=self.name,\n            encoded_password=self.encoded_password,\n        )\n\n        if self.load_after_post:\n            comments = level.get_comments_on_page(count=DEFAULT_COUNT)\n\n            return await comments.find(by_id(comment_id)).extract()\n\n        return None\n\n    @check_login\n    async def delete_user_comment(self, comment: UserComment) -&gt; None:\n        await self.session.delete_user_comment(\n            comment_id=comment.id,\n            account_id=self.account_id,\n            encoded_password=self.encoded_password,\n        )\n\n    @check_login\n    async def delete_level_comment(self, comment: LevelComment) -&gt; None:\n        await self.session.delete_level_comment(\n            comment_id=comment.id,\n            level_id=comment.level.id,\n            account_id=self.account_id,\n            encoded_password=self.encoded_password,\n        )\n\n    @wrap_async_iter\n    async def get_user_comments_on_page(\n        self,\n        user: User,\n        page: int = DEFAULT_PAGE,\n    ) -&gt; AsyncIterator[UserComment]:\n        response_model = await self.session.get_user_comments_on_page(\n            account_id=user.account_id,\n            page=page,\n        )\n\n        for model in response_model.comments:\n            yield UserComment.from_model(model, user).attach_client(self)\n\n    @wrap_async_iter\n    def get_user_comments(\n        self,\n        user: User,\n        pages: Iterable[int] = DEFAULT_PAGES,\n    ) -&gt; AsyncIterator[UserComment]:\n        return run_iterables(\n            (self.get_user_comments_on_page(user=user, page=page).unwrap() for page in pages),\n            ClientError,\n        )\n\n    @wrap_async_iter\n    async def get_user_level_comments_on_page(\n        self,\n        user: User,\n        count: int = COMMENT_PAGE_SIZE,\n        page: int = DEFAULT_PAGE,\n        strategy: CommentStrategy = CommentStrategy.DEFAULT,\n    ) -&gt; AsyncIterator[LevelComment]:\n        try:\n            response_model = await self.session.get_user_level_comments_on_page(\n                user_id=user.id,\n                count=count,\n                page=page,\n                strategy=strategy,\n            )\n\n        except NothingFound:\n            return\n\n        for model in response_model.comments:\n            yield LevelComment.from_model(model).attach_client(self)\n\n    @wrap_async_iter\n    def get_user_level_comments(\n        self,\n        user: User,\n        count: int = COMMENT_PAGE_SIZE,\n        pages: Iterable[int] = DEFAULT_PAGES,\n        strategy: CommentStrategy = CommentStrategy.DEFAULT,\n    ) -&gt; AsyncIterator[LevelComment]:\n        return run_iterables(\n            (\n                self.get_user_level_comments_on_page(user=user, count=count, page=page).unwrap()\n                for page in pages\n            ),\n            ClientError,\n        )\n\n    @wrap_async_iter\n    async def get_level_comments_on_page(\n        self,\n        level: Level,\n        count: int = COMMENT_PAGE_SIZE,\n        page: int = DEFAULT_PAGE,\n        strategy: CommentStrategy = CommentStrategy.DEFAULT,\n    ) -&gt; AsyncIterator[LevelComment]:\n        try:\n            response_model = await self.session.get_level_comments_on_page(\n                level_id=level.id,\n                count=count,\n                page=page,\n                strategy=strategy,\n            )\n\n        except NothingFound:\n            return\n\n        for model in response_model.comments:\n            comment = LevelComment.from_model(model).attach_client(self)\n\n            comment.level = level\n\n            yield comment\n\n    @wrap_async_iter\n    def get_level_comments(\n        self,\n        level: Level,\n        count: int = COMMENT_PAGE_SIZE,\n        pages: Iterable[int] = DEFAULT_PAGES,\n        strategy: CommentStrategy = CommentStrategy.DEFAULT,\n    ) -&gt; AsyncIterator[LevelComment]:\n        return run_iterables(\n            (\n                self.get_level_comments_on_page(\n                    level=level, count=count, page=page, strategy=strategy\n                ).unwrap()\n                for page in pages\n            ),\n            ClientError,\n        )\n\n    @wrap_async_iter\n    async def get_gauntlets(self) -&gt; AsyncIterator[Gauntlet]:\n        response_model = await self.session.get_gauntlets()\n\n        for model in response_model.gauntlets:\n            yield Gauntlet.from_model(model).attach_client(self)\n\n    @wrap_async_iter\n    async def get_map_packs_on_page(self, page: int = DEFAULT_PAGE) -&gt; AsyncIterator[MapPack]:\n        response_model = await self.session.get_map_packs_on_page(page=page)\n\n        for model in response_model.map_packs:\n            yield MapPack.from_model(model).attach_client(self)\n\n    @wrap_async_iter\n    def get_map_packs(self, pages: Iterable[int] = DEFAULT_PAGES) -&gt; AsyncIterator[MapPack]:\n        return run_iterables(\n            (self.get_map_packs_on_page(page=page).unwrap() for page in pages),\n            ClientError,\n        )\n\n    @wrap_async_iter\n    @check_login\n    async def get_quests(self) -&gt; AsyncIterator[Quest]:\n        response_model = await self.session.get_quests(\n            account_id=self.account_id, encoded_password=self.encoded_password\n        )\n\n        model = response_model.inner\n\n        for quest_model in (model.quest_1, model.quest_2, model.quest_3):\n            yield Quest.from_model(quest_model, model.duration).attach_client(self)\n\n    @wrap_async_iter\n    @check_login\n    async def get_chests(\n        self,\n        reward_type: RewardType = RewardType.DEFAULT,\n        chest_1_count: int = DEFAULT_CHEST_COUNT,\n        chest_2_count: int = DEFAULT_CHEST_COUNT,\n    ) -&gt; AsyncIterator[Chest]:\n        response_model = await self.session.get_chests(\n            reward_type=reward_type,\n            chest_1_count=chest_1_count,\n            chest_2_count=chest_2_count,\n            account_id=self.account_id,\n            encoded_password=self.encoded_password,\n        )\n        model = response_model.inner\n\n        for (id, chest_model, count, duration) in (\n            (1, model.chest_1, model.chest_1_count, model.chest_1_duration),\n            (2, model.chest_2, model.chest_2_count, model.chest_2_duration),\n        ):\n            yield Chest.from_model(chest_model, id, count, duration).attach_client(self)\n\n    @wrap_async_iter\n    async def get_artists_on_page(self, page: int = DEFAULT_PAGE) -&gt; AsyncIterator[Artist]:\n        response_model = await self.session.get_artists_on_page(page=page)\n\n        for model in response_model.artists:\n            yield Artist.from_model(model).attach_client(self)\n\n    @wrap_async_iter\n    def get_artists(self, pages: Iterable[int] = DEFAULT_PAGES) -&gt; AsyncIterator[Artist]:\n        return run_iterables(\n            (self.get_artists_on_page(page=page).unwrap() for page in pages),\n            ClientError,\n        )\n\n    async def get_song(self, song_id: int) -&gt; Song:\n        model = await self.session.get_song(song_id=song_id)\n\n        return Song.from_model(model).attach_client(self)\n\n    async def get_newgrounds_song(self, song_id: int) -&gt; Song:\n        model = await self.session.get_newgrounds_song(song_id=song_id)\n\n        return Song.from_model(model).attach_client(self)\n\n    @wrap_async_iter\n    async def search_newgrounds_songs_on_page(\n        self, query: str, page: int = DEFAULT_PAGE\n    ) -&gt; AsyncIterator[Song]:\n        models = await self.session.search_newgrounds_songs_on_page(query=query, page=page)\n\n        for model in models:\n            yield Song.from_model(model).attach_client(self)\n\n    @wrap_async_iter\n    def search_newgrounds_songs(\n        self, query: str, pages: Iterable[int] = DEFAULT_PAGES\n    ) -&gt; AsyncIterator[Song]:\n        return run_iterables(\n            (self.search_newgrounds_songs_on_page(query=query, page=page) for page in pages),\n            ClientError,\n        )\n\n    @wrap_async_iter\n    async def search_newgrounds_artists_on_page(\n        self, query: str, page: int = DEFAULT_PAGE\n    ) -&gt; AsyncIterator[Artist]:\n        models = await self.session.search_newgrounds_artists_on_page(query=query, page=page)\n\n        for model in models:\n            yield Artist.from_model(model).attach_client(self)\n\n    @wrap_async_iter\n    def search_newgrounds_artists(\n        self, query: str, pages: Iterable[int] = DEFAULT_PAGES\n    ) -&gt; AsyncIterator[Artist]:\n        return run_iterables(\n            (self.search_newgrounds_artists_on_page(query=query, page=page) for page in pages),\n            ClientError,\n        )\n\n    @wrap_async_iter\n    async def get_newgrounds_artist_songs_on_page(\n        self, artist: Artist, page: int = DEFAULT_PAGE\n    ) -&gt; AsyncIterator[Song]:\n        models = await self.session.get_newgrounds_artist_songs_on_page(\n            artist_name=artist.name, page=page\n        )\n\n        for model in models:\n            yield Song.from_model(model).attach_client(self)\n\n    @wrap_async_iter\n    def get_newgrounds_artist_songs(\n        self, artist: Artist, pages: Iterable[int] = DEFAULT_PAGES\n    ) -&gt; AsyncIterator[Song]:\n        return run_iterables(\n            (\n                self.get_newgrounds_artist_songs_on_page(artist=artist, page=page).unwrap()\n                for page in pages\n            ),\n            ClientError,\n        )\n\n    # handlers\n\n    async def on_daily(self, daily: Level) -&gt; None:\n\"\"\"Handles `daily` events.\n\n        Arguments:\n            daily: The daily level to handle.\n        \"\"\"\n\n    async def on_weekly(self, weekly: Level) -&gt; None:\n\"\"\"Handles `weekly` events.\n\n        Arguments:\n            weekly: The weekly level to handle.\n        \"\"\"\n\n    async def on_rate(self, level: Level) -&gt; None:\n\"\"\"Handles `rate` events.\n\n        Arguments:\n            level: The rated level to handle.\n        \"\"\"\n\n    async def on_level(self, level: Level) -&gt; None:\n\"\"\"Handles `level` events.\n\n        Arguments:\n            level: The level to handle.\n        \"\"\"\n\n    async def on_user_level(self, user: User, level: Level) -&gt; None:\n\"\"\"Handles `user_level` events.\n\n        Arguments:\n            user: The user to handle.\n            level: The level to handle.\n        \"\"\"\n\n    async def on_message(self, message: Message) -&gt; None:\n\"\"\"Handles `message` events.\n\n        Arguments:\n            message: The message to handle.\n        \"\"\"\n\n    async def on_friend_request(self, friend_request: FriendRequest) -&gt; None:\n\"\"\"Handles `friend_request` events.\n\n        Arguments:\n            friend_request: The friend request to handle.\n        \"\"\"\n\n    async def on_level_comment(self, level: Level, comment: LevelComment) -&gt; None:\n\"\"\"Handles `level_comment` events.\n\n        Arguments:\n            level: The level to handle.\n            comment: The level comment to handle.\n        \"\"\"\n\n    async def on_daily_comment(self, daily: Level, comment: LevelComment) -&gt; None:\n\"\"\"Handles `daily_comment` events.\n\n        Arguments:\n            daily: The daily level to handle.\n            comment: The daily comment to handle.\n        \"\"\"\n\n    async def on_weekly_comment(self, weekly: Level, comment: LevelComment) -&gt; None:\n\"\"\"Handles `weekly_comment` events.\n\n        Arguments:\n            weekly: The weekly level to handle.\n            comment: The weekly comment to handle.\n        \"\"\"\n\n    async def on_user_comment(self, user: User, comment: UserComment) -&gt; None:\n\"\"\"Handles `user_comment` events.\n\n        Arguments:\n            user: The user to handle.\n            comment: The comment to handle.\n        \"\"\"\n\n    async def on_user_level_comment(self, user: User, comment: LevelComment) -&gt; None:\n\"\"\"Handles `user_level_comment` events.\n\n        Arguments:\n            user: The user to handle.\n            comment: The level comment to handle.\n        \"\"\"\n\n    # dispatchers\n\n    async def dispatch_daily(self, daily: Level) -&gt; None:\n\"\"\"Dispatches `daily` events via calling [`on_daily`][gd.client.Client.on_daily].\n\n        Arguments:\n            daily: The daily level to dispatch.\n        \"\"\"\n        await self.on_daily(daily)\n\n    async def dispatch_weekly(self, weekly: Level) -&gt; None:\n\"\"\"Dispatches `weekly` events via calling [`on_weekly`][gd.client.Client.on_weekly].\n\n        Arguments:\n            weekly: The weekly level to dispatch.\n        \"\"\"\n        await self.on_weekly(weekly)\n\n    async def dispatch_rate(self, level: Level) -&gt; None:\n\"\"\"Dispatches `rate` events via calling [`on_rate`][gd.client.Client.on_rate].\n\n        Arguments:\n            level: The rated level to dispatch.\n        \"\"\"\n        await self.on_rate(level)\n\n    async def dispatch_level(self, level: Level) -&gt; None:\n\"\"\"Dispatches `level` events via calling [`on_level`][gd.client.Client.on_level].\n\n        Arguments:\n            level: The level to dispatch.\n        \"\"\"\n        await self.on_level(level)\n\n    async def dispatch_user_level(self, user: User, level: Level) -&gt; None:\n\"\"\"Dispatches `user_level` events via calling\n        [`on_user_level`][gd.client.Client.on_user_level].\n\n        Arguments:\n            user: The user to dispatch.\n            level: The level to dispatch.\n        \"\"\"\n        await self.on_user_level(user, level)\n\n    async def dispatch_message(self, message: Message) -&gt; None:\n\"\"\"Dispatches `message` events via calling [`on_message`][gd.client.Client.on_message].\n\n        Arguments:\n            message: The message to dispatch.\n        \"\"\"\n        await self.on_message(message)\n\n    async def dispatch_friend_request(self, friend_request: FriendRequest) -&gt; None:\n\"\"\"Dispatches `friend_request` events via calling\n        [`on_friend_request`][gd.client.Client.on_friend_request].\n\n        Arguments:\n            friend_request: The friend request to dispatch.\n        \"\"\"\n        await self.on_friend_request(friend_request)\n\n    async def dispatch_level_comment(self, level: Level, comment: LevelComment) -&gt; None:\n\"\"\"Dispatches `level_comment` events via calling\n        [`on_level_comment`][gd.client.Client.on_level_comment].\n\n        Arguments:\n            level: The level to dispatch.\n            comment: The level comment to dispatch.\n        \"\"\"\n        await self.on_level_comment(level, comment)\n\n    async def dispatch_daily_comment(self, daily: Level, comment: LevelComment) -&gt; None:\n\"\"\"Dispatches `level_comment` events via calling\n        [`on_level_comment`][gd.client.Client.on_level_comment].\n\n        Arguments:\n            daily: The daily level to dispatch.\n            comment: The daily comment to dispatch.\n        \"\"\"\n        await self.on_daily_comment(daily, comment)\n\n    async def dispatch_weekly_comment(self, weekly: Level, comment: LevelComment) -&gt; None:\n\"\"\"Dispatches `weekly_comment` events via calling\n        [`on_weekly_comment`][gd.client.Client.on_weekly_comment].\n\n        Arguments:\n            weekly: The weekly level to dispatch.\n            comment: The weekly comment to dispatch.\n        \"\"\"\n        await self.on_weekly_comment(weekly, comment)\n\n    async def dispatch_user_comment(self, user: User, comment: UserComment) -&gt; None:\n\"\"\"Dispatches `user_comment` events via calling\n        [`on_user_comment`][gd.client.Client.on_user_comment].\n\n        Arguments:\n            user: The user to dispatch.\n            comment: The comment to dispatch.\n        \"\"\"\n        await self.on_user_comment(user, comment)\n\n    async def dispatch_user_level_comment(self, user: User, comment: LevelComment) -&gt; None:\n\"\"\"Dispatches `user_level_comment` events via calling\n        [`on_user_level_comment`][gd.client.Client.on_user_level_comment].\n\n        Arguments:\n            user: The user to dispatch.\n            comment: The level comment to dispatch.\n        \"\"\"\n        await self.on_user_level_comment(user, comment)\n\n    def event(self, function: F) -&gt; F:\n\"\"\"Registers an event handler.\n\n        Example:\n            ```python\n            client = Client()\n\n            DAILY = \"new daily! {daily.name} by {daily.creator.name} (ID: {daily.id})\n\n            @client.event\n            async def on_daily(daily: Level) -&gt; None:\n                print(DAILY.format(daily=daily))\n            ```\n\n        Arguments:\n            function: The function to register as an event handler.\n\n        Returns:\n            The function passed.\n        \"\"\"\n        set_attribute(self, function.__name__, function)\n\n        return function\n\n    def listen_for_daily(\n        self, delay: float = DEFAULT_DELAY, reconnect: bool = DEFAULT_RECONNECT\n    ) -&gt; DailyListener:\n        return self.add_listener(DailyListener(self, delay=delay, reconnect=reconnect))\n\n    def listen_for_weekly(\n        self, delay: float = DEFAULT_DELAY, reconnect: bool = DEFAULT_RECONNECT\n    ) -&gt; WeeklyListener:\n        return self.add_listener(WeeklyListener(self, delay=delay, reconnect=reconnect))\n\n    def listen_for_rate(\n        self,\n        pages_count: int = DEFAULT_PAGES_COUNT,\n        delay: float = DEFAULT_DELAY,\n        reconnect: bool = DEFAULT_RECONNECT,\n    ) -&gt; RateListener:\n        return self.add_listener(\n            RateListener(self, delay=delay, reconnect=reconnect, pages_count=pages_count)\n        )\n\n    def listen_for_level(\n        self,\n        pages_count: int = DEFAULT_PAGES_COUNT,\n        filters: Optional[Filters] = None,\n        delay: float = DEFAULT_DELAY,\n        reconnect: bool = DEFAULT_RECONNECT,\n    ) -&gt; LevelListener:\n        if filters is None:\n            filters = Filters()\n\n        return self.add_listener(\n            LevelListener(\n                self,\n                delay=delay,\n                reconnect=reconnect,\n                pages_count=pages_count,\n                filters=filters,\n            )\n        )\n\n    def listen_for_user_level(\n        self,\n        account_id: Optional[int] = None,\n        id: Optional[int] = None,\n        name: Optional[str] = None,\n        pages_count: int = DEFAULT_PAGES_COUNT,\n        update: bool = DEFAULT_UPDATE,\n        delay: float = DEFAULT_DELAY,\n        reconnect: bool = DEFAULT_RECONNECT,\n    ) -&gt; UserLevelListener:\n        return self.add_listener(\n            UserLevelListener(\n                self,\n                delay=delay,\n                reconnect=reconnect,\n                account_id=account_id,\n                id=id,\n                name=name,\n                pages_count=pages_count,\n                update=update,\n            )\n        )\n\n    def listen_for_message(\n        self,\n        pages_count: int = DEFAULT_PAGES_COUNT,\n        delay: float = DEFAULT_DELAY,\n        reconnect: bool = DEFAULT_RECONNECT,\n    ) -&gt; MessageListener:\n        return self.add_listener(\n            MessageListener(self, delay=delay, reconnect=reconnect, pages_count=pages_count)\n        )\n\n    def listen_for_friend_request(\n        self,\n        pages_count: int = DEFAULT_PAGES_COUNT,\n        delay: float = DEFAULT_DELAY,\n        reconnect: bool = DEFAULT_RECONNECT,\n    ) -&gt; FriendRequestListener:\n        return self.add_listener(\n            FriendRequestListener(self, delay=delay, reconnect=reconnect, pages_count=pages_count)\n        )\n\n    def listen_for_level_comment(\n        self,\n        level_id: int,\n        pages_count: int = DEFAULT_PAGES_COUNT,\n        count: int = DEFAULT_COUNT,\n        update: bool = DEFAULT_UPDATE,\n        delay: float = DEFAULT_DELAY,\n        reconnect: bool = DEFAULT_RECONNECT,\n    ) -&gt; LevelCommentListener:\n        return self.add_listener(\n            LevelCommentListener(\n                self,\n                delay=delay,\n                reconnect=reconnect,\n                level_id=level_id,\n                pages_count=pages_count,\n                count=count,\n                update=update,\n            )\n        )\n\n    def listen_for_daily_comment(\n        self,\n        pages_count: int = DEFAULT_PAGES_COUNT,\n        count: int = DEFAULT_COUNT,\n        update: bool = DEFAULT_UPDATE,\n        delay: float = DEFAULT_DELAY,\n        reconnect: bool = DEFAULT_RECONNECT,\n    ) -&gt; DailyCommentListener:\n        return self.add_listener(\n            DailyCommentListener(\n                self,\n                delay=delay,\n                reconnect=reconnect,\n                pages_count=pages_count,\n                count=count,\n                update=update,\n            )\n        )\n\n    def listen_for_weekly_comment(\n        self,\n        pages_count: int = DEFAULT_PAGES_COUNT,\n        count: int = DEFAULT_COUNT,\n        update: bool = DEFAULT_UPDATE,\n        delay: float = DEFAULT_DELAY,\n        reconnect: bool = DEFAULT_RECONNECT,\n    ) -&gt; WeeklyCommentListener:\n        return self.add_listener(\n            WeeklyCommentListener(\n                self,\n                delay=delay,\n                reconnect=reconnect,\n                pages_count=pages_count,\n                count=count,\n                update=update,\n            )\n        )\n\n    def listen_for_user_comment(\n        self,\n        account_id: Optional[int] = None,\n        id: Optional[int] = None,\n        name: Optional[str] = None,\n        update: bool = DEFAULT_UPDATE,\n        delay: float = DEFAULT_DELAY,\n        reconnect: bool = DEFAULT_RECONNECT,\n    ) -&gt; UserCommentListener:\n        return self.add_listener(\n            UserCommentListener(\n                self,\n                delay=delay,\n                reconnect=reconnect,\n                account_id=account_id,\n                id=id,\n                name=name,\n                update=update,\n            )\n        )\n\n    def listen_for_user_level_comment(\n        self,\n        account_id: Optional[int] = None,\n        id: Optional[int] = None,\n        name: Optional[str] = None,\n        update: bool = DEFAULT_UPDATE,\n        delay: float = DEFAULT_DELAY,\n        reconnect: bool = DEFAULT_RECONNECT,\n    ) -&gt; UserLevelCommentListener:\n        return self.add_listener(\n            UserLevelCommentListener(\n                self,\n                delay=delay,\n                reconnect=reconnect,\n                account_id=account_id,\n                id=id,\n                name=name,\n                update=update,\n            )\n        )\n\n    # listeners\n\n    def add_listener(self, listener: L) -&gt; L:\n        self.check_controller()\n\n        self._listeners = (*self._listeners, listener)\n\n        return listener\n\n    def clear_listeners(self) -&gt; None:\n        self.check_controller()\n\n        self._listeners = ()\n\n    def remove_listener(self, listener: Listener) -&gt; bool:\n        self.check_controller()\n\n        listeners = self._listeners\n\n        length = len(listeners)\n\n        self._listeners = listeners = tuple(\n            present_listener for present_listener in listeners if present_listener is not listener\n        )\n\n        return len(listeners) &lt; length\n\n    # controllers\n\n    def check_controller(self) -&gt; None:\n        if self._controller is not None:\n            raise RuntimeError(CONTROLLER_ALREADY_CREATED)\n\n    def create_controller(self) -&gt; Controller:\n        self.check_controller()\n\n        self._controller = controller = Controller(self._listeners)\n\n        return controller\n</code></pre>"},{"location":"reference/client/#gd.client.Client.session","title":"<code>session: Session = field(factory=Session)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The session of the client.</p>"},{"location":"reference/client/#gd.client.Client.credentials","title":"<code>credentials: Credentials = field(factory=Credentials)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The credentials of the client.</p>"},{"location":"reference/client/#gd.client.Client.database_unchecked","title":"<code>database_unchecked: Optional[Database] = field(default=None, repr=False)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The database of the client.</p>"},{"location":"reference/client/#gd.client.Client.load_after_post","title":"<code>load_after_post: bool = field(default=DEFAULT_LOAD_AFTER_POST)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Whether to load items after posting them.</p>"},{"location":"reference/client/#gd.client.Client.account_id","title":"<code>account_id: int</code>  <code>property</code>","text":"<p>The account ID of the client.</p>"},{"location":"reference/client/#gd.client.Client.id","title":"<code>id: int</code>  <code>property</code>","text":"<p>The user ID of the client.</p>"},{"location":"reference/client/#gd.client.Client.name","title":"<code>name: str</code>  <code>property</code>","text":"<p>The name of the client.</p>"},{"location":"reference/client/#gd.client.Client.password","title":"<code>password: str</code>  <code>property</code>","text":"<p>The password of the client.</p>"},{"location":"reference/client/#gd.client.Client.http","title":"<code>http: HTTPClient</code>  <code>property</code>","text":"<p>The <code>HTTPClient</code> used by the client session.</p>"},{"location":"reference/client/#gd.client.Client.encoded_password","title":"<code>encoded_password: str</code>  <code>property</code>","text":"<p>The encoded password of the client.</p>"},{"location":"reference/client/#gd.client.Client.user","title":"<code>user: User</code>  <code>property</code>","text":"<p>The user representing the client.</p>"},{"location":"reference/client/#gd.client.Client.is_logged_in","title":"<code>is_logged_in() -&gt; bool</code>","text":"<p>Checks if the client is logged in.</p> <p>Returns:</p> Type Description <code>bool</code> <p>Whether the client is logged in.</p> Source code in <code>gd/client.py</code> <pre><code>def is_logged_in(self) -&gt; bool:\n\"\"\"Checks if the client is logged in.\n\n    Returns:\n        Whether the client is logged in.\n    \"\"\"\n    return self.credentials.is_loaded()\n</code></pre>"},{"location":"reference/client/#gd.client.Client.ping","title":"<code>ping() -&gt; Duration</code>  <code>async</code>","text":"<p>Pings the Geometry Dash server.</p> <p>Returns:</p> Type Description <code>Duration</code> <p>The <code>Duration</code> representing the latency.</p> Source code in <code>gd/client.py</code> <pre><code>async def ping(self) -&gt; Duration:\n\"\"\"Pings the Geometry Dash server.\n\n    Returns:\n        The [`Duration`][gd.date_time.Duration] representing the latency.\n    \"\"\"\n    return await self.ping_url(self.http.url)\n</code></pre>"},{"location":"reference/client/#gd.client.Client.ping_url","title":"<code>ping_url(url: URLString) -&gt; Duration</code>  <code>async</code>","text":"<p>Pings the given <code>url</code>.</p> <p>Returns:</p> Type Description <code>Duration</code> <p>The <code>Duration</code> representing the latency.</p> Source code in <code>gd/client.py</code> <pre><code>async def ping_url(self, url: URLString) -&gt; Duration:\n\"\"\"Pings the given `url`.\n\n    Returns:\n        The [`Duration`][gd.date_time.Duration] representing the latency.\n    \"\"\"\n    return await self.session.ping(url)\n</code></pre>"},{"location":"reference/client/#gd.client.Client.logout","title":"<code>logout() -&gt; None</code>  <code>async</code>","text":"<p>Performs the logout.</p> Source code in <code>gd/client.py</code> <pre><code>async def logout(self) -&gt; None:\n\"\"\"Performs the logout.\"\"\"\n    self.reset_items()\n</code></pre>"},{"location":"reference/client/#gd.client.Client.login","title":"<code>login(name: str, password: str) -&gt; LoginContextManager[C]</code>","text":"<p>Performs the login.</p> <p>This function returns a context manager that can be used for temporarily logging in:</p> <pre><code>async with client.login(name, password):\n    assert client.is_logged_in()\n\nassert not client.is_logged_in()\n</code></pre> <p>Returns:</p> Type Description <code>LoginContextManager[C]</code> <p>The <code>LoginContextManager</code> for handling login process.</p> Source code in <code>gd/client.py</code> <pre><code>def login(self: C, name: str, password: str) -&gt; LoginContextManager[C]:\n\"\"\"Performs the login.\n\n    This function returns a context manager that can be used for temporarily logging in:\n\n    ```python\n    async with client.login(name, password):\n        assert client.is_logged_in()\n\n    assert not client.is_logged_in()\n    ```\n\n    Returns:\n        The [`LoginContextManager`][gd.client.LoginContextManager] for handling login process.\n    \"\"\"\n    return LoginContextManager(self, name, password)\n</code></pre>"},{"location":"reference/client/#gd.client.Client.unsafe_login","title":"<code>unsafe_login(name: str, password: str) -&gt; UnsafeLoginContextManager[C]</code>","text":"<p>Performs the unsafe login.</p> <p>Unsafe means that the credentials are not confirmed.</p> <p>This function returns a context manager that can be used for temporarily logging in:</p> <pre><code>async with client.unsafe_login(name, password):\n    assert client.is_logged_in()\n\nassert not client.is_logged_in()\n</code></pre> <p>Returns:</p> Type Description <code>UnsafeLoginContextManager[C]</code> <p>The <code>UnsafeLoginContextManager</code> for handling login process.</p> Source code in <code>gd/client.py</code> <pre><code>def unsafe_login(self: C, name: str, password: str) -&gt; UnsafeLoginContextManager[C]:\n\"\"\"Performs the *unsafe* login.\n\n    *Unsafe* means that the credentials are not confirmed.\n\n    This function returns a context manager that can be used for temporarily logging in:\n\n    ```python\n    async with client.unsafe_login(name, password):\n        assert client.is_logged_in()\n\n    assert not client.is_logged_in()\n    ```\n\n    Returns:\n        The [`UnsafeLoginContextManager`][gd.client.UnsafeLoginContextManager]\n            for handling login process.\n    \"\"\"\n    return UnsafeLoginContextManager(self, name, password)\n</code></pre>"},{"location":"reference/client/#gd.client.Client.load","title":"<code>load() -&gt; Database</code>  <code>async</code>","text":"<p>Loads the save from the cloud, saving it in the <code>database</code> attribute.</p> Note <p>This function requires the client to be logged in.</p> <p>Returns:</p> Type Description <code>Database</code> <p>The <code>Database</code> loaded.</p> Source code in <code>gd/client.py</code> <pre><code>@check_login\nasync def load(self) -&gt; Database:\n\"\"\"Loads the save from the cloud, saving it in the\n    [`database`][gd.client.Client.database] attribute.\n\n    Note:\n        This function requires the client to be logged in.\n\n    Returns:\n        The [`Database`][gd.api.database.Database] loaded.\n    \"\"\"\n    database = await self.session.load(\n        account_id=self.account_id, name=self.name, password=self.password\n    )\n\n    self.database = database\n\n    return database\n</code></pre>"},{"location":"reference/client/#gd.client.Client.save","title":"<code>save(database: Optional[Database] = None) -&gt; None</code>  <code>async</code>","text":"<p>Saves the the <code>database</code> to the cloud, optionally fetching it from the <code>database</code> attribute.</p> Note <p>This function requires the client to be logged in.</p> Source code in <code>gd/client.py</code> <pre><code>@check_login\nasync def save(self, database: Optional[Database] = None) -&gt; None:\n\"\"\"Saves the the `database` to the cloud, optionally fetching it from the\n    [`database`][gd.client.Client.database] attribute.\n\n    Note:\n        This function requires the client to be logged in.\n    \"\"\"\n    if database is None:\n        database = self.database\n\n    await self.session.save(\n        database, account_id=self.account_id, name=self.name, password=self.password\n    )\n</code></pre>"},{"location":"reference/client/#gd.client.Client.get_self","title":"<code>get_self(simple: bool = DEFAULT_SIMPLE) -&gt; User</code>  <code>async</code>","text":"<p>Gets the user representing this client.</p> <p>This is a shorthand for:</p> <pre><code>await client.user.get(simple=simple)\n</code></pre> <p>See <code>User.get</code> for more information.</p> Note <p>This function requires the client to be logged in.</p> <p>Parameters:</p> Name Type Description Default <code>simple</code> <code>bool</code> <p>Whether to fetch simple information.</p> <code>DEFAULT_SIMPLE</code> <p>Returns:</p> Type Description <code>User</code> <p>The <code>User</code> representing the client.</p> Source code in <code>gd/client.py</code> <pre><code>@check_login\nasync def get_self(self, simple: bool = DEFAULT_SIMPLE) -&gt; User:\n\"\"\"Gets the user representing this client.\n\n    This is a shorthand for:\n\n    ```python\n    await client.user.get(simple=simple)\n    ```\n\n    See [`User.get`][gd.user.User.get] for more information.\n\n    Note:\n        This function requires the client to be logged in.\n\n    Arguments:\n        simple: Whether to fetch simple information.\n\n    Returns:\n        The [`User`][gd.user.User] representing the client.\n    \"\"\"\n    return await self.user.get(simple=simple)\n</code></pre>"},{"location":"reference/client/#gd.client.Client.get_user","title":"<code>get_user(account_id: int, simple: bool = DEFAULT_SIMPLE, friend_state: bool = DEFAULT_FRIEND_STATE) -&gt; User</code>  <code>async</code>","text":"<p>Fetches the user by <code>account_id</code>.</p> <p>Parameters:</p> Name Type Description Default <code>account_id</code> <code>int</code> <p>The account ID of the user to fetch.</p> required <code>simple</code> <code>bool</code> <p>Whether to fetch simple information only.</p> <code>DEFAULT_SIMPLE</code> <code>friend_state</code> <code>bool</code> <p>Whether to fetch friend state.</p> <code>DEFAULT_FRIEND_STATE</code> Note <p><code>friend_state</code> requires the client to be logged in.</p> <p>Returns:</p> Type Description <code>User</code> <p>The <code>User</code> fetched.</p> Source code in <code>gd/client.py</code> <pre><code>async def get_user(\n    self,\n    account_id: int,\n    simple: bool = DEFAULT_SIMPLE,\n    friend_state: bool = DEFAULT_FRIEND_STATE,\n) -&gt; User:\n\"\"\"Fetches the user by `account_id`.\n\n    Arguments:\n        account_id: The account ID of the user to fetch.\n        simple: Whether to fetch simple information only.\n        friend_state: Whether to fetch friend state.\n\n    Note:\n        `friend_state` requires the client to be logged in.\n\n    Returns:\n        The [`User`][gd.user.User] fetched.\n    \"\"\"\n    if friend_state:  # if we need to fetch friend state\n        check_client_login(self)\n\n        profile_model = await self.session.get_user_profile(  # request profile\n            account_id=account_id,\n            client_account_id=self.account_id,\n            encoded_password=self.encoded_password,\n        )\n\n    else:  # otherwise, simply request normally\n        profile_model = await self.session.get_user_profile(account_id=account_id)\n\n    if simple:  # if only the profile is needed, return right away\n        return User.from_profile_model(profile_model).attach_client(self)\n\n    search_model = await self.session.search_user(profile_model.id)  # search by ID\n\n    return User.from_search_user_and_profile_models(search_model, profile_model).attach_client(\n        self\n    )\n</code></pre>"},{"location":"reference/client/#gd.client.Client.on_daily","title":"<code>on_daily(daily: Level) -&gt; None</code>  <code>async</code>","text":"<p>Handles <code>daily</code> events.</p> <p>Parameters:</p> Name Type Description Default <code>daily</code> <code>Level</code> <p>The daily level to handle.</p> required Source code in <code>gd/client.py</code> <pre><code>async def on_daily(self, daily: Level) -&gt; None:\n\"\"\"Handles `daily` events.\n\n    Arguments:\n        daily: The daily level to handle.\n    \"\"\"\n</code></pre>"},{"location":"reference/client/#gd.client.Client.on_weekly","title":"<code>on_weekly(weekly: Level) -&gt; None</code>  <code>async</code>","text":"<p>Handles <code>weekly</code> events.</p> <p>Parameters:</p> Name Type Description Default <code>weekly</code> <code>Level</code> <p>The weekly level to handle.</p> required Source code in <code>gd/client.py</code> <pre><code>async def on_weekly(self, weekly: Level) -&gt; None:\n\"\"\"Handles `weekly` events.\n\n    Arguments:\n        weekly: The weekly level to handle.\n    \"\"\"\n</code></pre>"},{"location":"reference/client/#gd.client.Client.on_rate","title":"<code>on_rate(level: Level) -&gt; None</code>  <code>async</code>","text":"<p>Handles <code>rate</code> events.</p> <p>Parameters:</p> Name Type Description Default <code>level</code> <code>Level</code> <p>The rated level to handle.</p> required Source code in <code>gd/client.py</code> <pre><code>async def on_rate(self, level: Level) -&gt; None:\n\"\"\"Handles `rate` events.\n\n    Arguments:\n        level: The rated level to handle.\n    \"\"\"\n</code></pre>"},{"location":"reference/client/#gd.client.Client.on_level","title":"<code>on_level(level: Level) -&gt; None</code>  <code>async</code>","text":"<p>Handles <code>level</code> events.</p> <p>Parameters:</p> Name Type Description Default <code>level</code> <code>Level</code> <p>The level to handle.</p> required Source code in <code>gd/client.py</code> <pre><code>async def on_level(self, level: Level) -&gt; None:\n\"\"\"Handles `level` events.\n\n    Arguments:\n        level: The level to handle.\n    \"\"\"\n</code></pre>"},{"location":"reference/client/#gd.client.Client.on_user_level","title":"<code>on_user_level(user: User, level: Level) -&gt; None</code>  <code>async</code>","text":"<p>Handles <code>user_level</code> events.</p> <p>Parameters:</p> Name Type Description Default <code>user</code> <code>User</code> <p>The user to handle.</p> required <code>level</code> <code>Level</code> <p>The level to handle.</p> required Source code in <code>gd/client.py</code> <pre><code>async def on_user_level(self, user: User, level: Level) -&gt; None:\n\"\"\"Handles `user_level` events.\n\n    Arguments:\n        user: The user to handle.\n        level: The level to handle.\n    \"\"\"\n</code></pre>"},{"location":"reference/client/#gd.client.Client.on_message","title":"<code>on_message(message: Message) -&gt; None</code>  <code>async</code>","text":"<p>Handles <code>message</code> events.</p> <p>Parameters:</p> Name Type Description Default <code>message</code> <code>Message</code> <p>The message to handle.</p> required Source code in <code>gd/client.py</code> <pre><code>async def on_message(self, message: Message) -&gt; None:\n\"\"\"Handles `message` events.\n\n    Arguments:\n        message: The message to handle.\n    \"\"\"\n</code></pre>"},{"location":"reference/client/#gd.client.Client.on_friend_request","title":"<code>on_friend_request(friend_request: FriendRequest) -&gt; None</code>  <code>async</code>","text":"<p>Handles <code>friend_request</code> events.</p> <p>Parameters:</p> Name Type Description Default <code>friend_request</code> <code>FriendRequest</code> <p>The friend request to handle.</p> required Source code in <code>gd/client.py</code> <pre><code>async def on_friend_request(self, friend_request: FriendRequest) -&gt; None:\n\"\"\"Handles `friend_request` events.\n\n    Arguments:\n        friend_request: The friend request to handle.\n    \"\"\"\n</code></pre>"},{"location":"reference/client/#gd.client.Client.on_level_comment","title":"<code>on_level_comment(level: Level, comment: LevelComment) -&gt; None</code>  <code>async</code>","text":"<p>Handles <code>level_comment</code> events.</p> <p>Parameters:</p> Name Type Description Default <code>level</code> <code>Level</code> <p>The level to handle.</p> required <code>comment</code> <code>LevelComment</code> <p>The level comment to handle.</p> required Source code in <code>gd/client.py</code> <pre><code>async def on_level_comment(self, level: Level, comment: LevelComment) -&gt; None:\n\"\"\"Handles `level_comment` events.\n\n    Arguments:\n        level: The level to handle.\n        comment: The level comment to handle.\n    \"\"\"\n</code></pre>"},{"location":"reference/client/#gd.client.Client.on_daily_comment","title":"<code>on_daily_comment(daily: Level, comment: LevelComment) -&gt; None</code>  <code>async</code>","text":"<p>Handles <code>daily_comment</code> events.</p> <p>Parameters:</p> Name Type Description Default <code>daily</code> <code>Level</code> <p>The daily level to handle.</p> required <code>comment</code> <code>LevelComment</code> <p>The daily comment to handle.</p> required Source code in <code>gd/client.py</code> <pre><code>async def on_daily_comment(self, daily: Level, comment: LevelComment) -&gt; None:\n\"\"\"Handles `daily_comment` events.\n\n    Arguments:\n        daily: The daily level to handle.\n        comment: The daily comment to handle.\n    \"\"\"\n</code></pre>"},{"location":"reference/client/#gd.client.Client.on_weekly_comment","title":"<code>on_weekly_comment(weekly: Level, comment: LevelComment) -&gt; None</code>  <code>async</code>","text":"<p>Handles <code>weekly_comment</code> events.</p> <p>Parameters:</p> Name Type Description Default <code>weekly</code> <code>Level</code> <p>The weekly level to handle.</p> required <code>comment</code> <code>LevelComment</code> <p>The weekly comment to handle.</p> required Source code in <code>gd/client.py</code> <pre><code>async def on_weekly_comment(self, weekly: Level, comment: LevelComment) -&gt; None:\n\"\"\"Handles `weekly_comment` events.\n\n    Arguments:\n        weekly: The weekly level to handle.\n        comment: The weekly comment to handle.\n    \"\"\"\n</code></pre>"},{"location":"reference/client/#gd.client.Client.on_user_comment","title":"<code>on_user_comment(user: User, comment: UserComment) -&gt; None</code>  <code>async</code>","text":"<p>Handles <code>user_comment</code> events.</p> <p>Parameters:</p> Name Type Description Default <code>user</code> <code>User</code> <p>The user to handle.</p> required <code>comment</code> <code>UserComment</code> <p>The comment to handle.</p> required Source code in <code>gd/client.py</code> <pre><code>async def on_user_comment(self, user: User, comment: UserComment) -&gt; None:\n\"\"\"Handles `user_comment` events.\n\n    Arguments:\n        user: The user to handle.\n        comment: The comment to handle.\n    \"\"\"\n</code></pre>"},{"location":"reference/client/#gd.client.Client.on_user_level_comment","title":"<code>on_user_level_comment(user: User, comment: LevelComment) -&gt; None</code>  <code>async</code>","text":"<p>Handles <code>user_level_comment</code> events.</p> <p>Parameters:</p> Name Type Description Default <code>user</code> <code>User</code> <p>The user to handle.</p> required <code>comment</code> <code>LevelComment</code> <p>The level comment to handle.</p> required Source code in <code>gd/client.py</code> <pre><code>async def on_user_level_comment(self, user: User, comment: LevelComment) -&gt; None:\n\"\"\"Handles `user_level_comment` events.\n\n    Arguments:\n        user: The user to handle.\n        comment: The level comment to handle.\n    \"\"\"\n</code></pre>"},{"location":"reference/client/#gd.client.Client.dispatch_daily","title":"<code>dispatch_daily(daily: Level) -&gt; None</code>  <code>async</code>","text":"<p>Dispatches <code>daily</code> events via calling <code>on_daily</code>.</p> <p>Parameters:</p> Name Type Description Default <code>daily</code> <code>Level</code> <p>The daily level to dispatch.</p> required Source code in <code>gd/client.py</code> <pre><code>async def dispatch_daily(self, daily: Level) -&gt; None:\n\"\"\"Dispatches `daily` events via calling [`on_daily`][gd.client.Client.on_daily].\n\n    Arguments:\n        daily: The daily level to dispatch.\n    \"\"\"\n    await self.on_daily(daily)\n</code></pre>"},{"location":"reference/client/#gd.client.Client.dispatch_weekly","title":"<code>dispatch_weekly(weekly: Level) -&gt; None</code>  <code>async</code>","text":"<p>Dispatches <code>weekly</code> events via calling <code>on_weekly</code>.</p> <p>Parameters:</p> Name Type Description Default <code>weekly</code> <code>Level</code> <p>The weekly level to dispatch.</p> required Source code in <code>gd/client.py</code> <pre><code>async def dispatch_weekly(self, weekly: Level) -&gt; None:\n\"\"\"Dispatches `weekly` events via calling [`on_weekly`][gd.client.Client.on_weekly].\n\n    Arguments:\n        weekly: The weekly level to dispatch.\n    \"\"\"\n    await self.on_weekly(weekly)\n</code></pre>"},{"location":"reference/client/#gd.client.Client.dispatch_rate","title":"<code>dispatch_rate(level: Level) -&gt; None</code>  <code>async</code>","text":"<p>Dispatches <code>rate</code> events via calling <code>on_rate</code>.</p> <p>Parameters:</p> Name Type Description Default <code>level</code> <code>Level</code> <p>The rated level to dispatch.</p> required Source code in <code>gd/client.py</code> <pre><code>async def dispatch_rate(self, level: Level) -&gt; None:\n\"\"\"Dispatches `rate` events via calling [`on_rate`][gd.client.Client.on_rate].\n\n    Arguments:\n        level: The rated level to dispatch.\n    \"\"\"\n    await self.on_rate(level)\n</code></pre>"},{"location":"reference/client/#gd.client.Client.dispatch_level","title":"<code>dispatch_level(level: Level) -&gt; None</code>  <code>async</code>","text":"<p>Dispatches <code>level</code> events via calling <code>on_level</code>.</p> <p>Parameters:</p> Name Type Description Default <code>level</code> <code>Level</code> <p>The level to dispatch.</p> required Source code in <code>gd/client.py</code> <pre><code>async def dispatch_level(self, level: Level) -&gt; None:\n\"\"\"Dispatches `level` events via calling [`on_level`][gd.client.Client.on_level].\n\n    Arguments:\n        level: The level to dispatch.\n    \"\"\"\n    await self.on_level(level)\n</code></pre>"},{"location":"reference/client/#gd.client.Client.dispatch_user_level","title":"<code>dispatch_user_level(user: User, level: Level) -&gt; None</code>  <code>async</code>","text":"<p>Dispatches <code>user_level</code> events via calling <code>on_user_level</code>.</p> <p>Parameters:</p> Name Type Description Default <code>user</code> <code>User</code> <p>The user to dispatch.</p> required <code>level</code> <code>Level</code> <p>The level to dispatch.</p> required Source code in <code>gd/client.py</code> <pre><code>async def dispatch_user_level(self, user: User, level: Level) -&gt; None:\n\"\"\"Dispatches `user_level` events via calling\n    [`on_user_level`][gd.client.Client.on_user_level].\n\n    Arguments:\n        user: The user to dispatch.\n        level: The level to dispatch.\n    \"\"\"\n    await self.on_user_level(user, level)\n</code></pre>"},{"location":"reference/client/#gd.client.Client.dispatch_message","title":"<code>dispatch_message(message: Message) -&gt; None</code>  <code>async</code>","text":"<p>Dispatches <code>message</code> events via calling <code>on_message</code>.</p> <p>Parameters:</p> Name Type Description Default <code>message</code> <code>Message</code> <p>The message to dispatch.</p> required Source code in <code>gd/client.py</code> <pre><code>async def dispatch_message(self, message: Message) -&gt; None:\n\"\"\"Dispatches `message` events via calling [`on_message`][gd.client.Client.on_message].\n\n    Arguments:\n        message: The message to dispatch.\n    \"\"\"\n    await self.on_message(message)\n</code></pre>"},{"location":"reference/client/#gd.client.Client.dispatch_friend_request","title":"<code>dispatch_friend_request(friend_request: FriendRequest) -&gt; None</code>  <code>async</code>","text":"<p>Dispatches <code>friend_request</code> events via calling <code>on_friend_request</code>.</p> <p>Parameters:</p> Name Type Description Default <code>friend_request</code> <code>FriendRequest</code> <p>The friend request to dispatch.</p> required Source code in <code>gd/client.py</code> <pre><code>async def dispatch_friend_request(self, friend_request: FriendRequest) -&gt; None:\n\"\"\"Dispatches `friend_request` events via calling\n    [`on_friend_request`][gd.client.Client.on_friend_request].\n\n    Arguments:\n        friend_request: The friend request to dispatch.\n    \"\"\"\n    await self.on_friend_request(friend_request)\n</code></pre>"},{"location":"reference/client/#gd.client.Client.dispatch_level_comment","title":"<code>dispatch_level_comment(level: Level, comment: LevelComment) -&gt; None</code>  <code>async</code>","text":"<p>Dispatches <code>level_comment</code> events via calling <code>on_level_comment</code>.</p> <p>Parameters:</p> Name Type Description Default <code>level</code> <code>Level</code> <p>The level to dispatch.</p> required <code>comment</code> <code>LevelComment</code> <p>The level comment to dispatch.</p> required Source code in <code>gd/client.py</code> <pre><code>async def dispatch_level_comment(self, level: Level, comment: LevelComment) -&gt; None:\n\"\"\"Dispatches `level_comment` events via calling\n    [`on_level_comment`][gd.client.Client.on_level_comment].\n\n    Arguments:\n        level: The level to dispatch.\n        comment: The level comment to dispatch.\n    \"\"\"\n    await self.on_level_comment(level, comment)\n</code></pre>"},{"location":"reference/client/#gd.client.Client.dispatch_daily_comment","title":"<code>dispatch_daily_comment(daily: Level, comment: LevelComment) -&gt; None</code>  <code>async</code>","text":"<p>Dispatches <code>level_comment</code> events via calling <code>on_level_comment</code>.</p> <p>Parameters:</p> Name Type Description Default <code>daily</code> <code>Level</code> <p>The daily level to dispatch.</p> required <code>comment</code> <code>LevelComment</code> <p>The daily comment to dispatch.</p> required Source code in <code>gd/client.py</code> <pre><code>async def dispatch_daily_comment(self, daily: Level, comment: LevelComment) -&gt; None:\n\"\"\"Dispatches `level_comment` events via calling\n    [`on_level_comment`][gd.client.Client.on_level_comment].\n\n    Arguments:\n        daily: The daily level to dispatch.\n        comment: The daily comment to dispatch.\n    \"\"\"\n    await self.on_daily_comment(daily, comment)\n</code></pre>"},{"location":"reference/client/#gd.client.Client.dispatch_weekly_comment","title":"<code>dispatch_weekly_comment(weekly: Level, comment: LevelComment) -&gt; None</code>  <code>async</code>","text":"<p>Dispatches <code>weekly_comment</code> events via calling <code>on_weekly_comment</code>.</p> <p>Parameters:</p> Name Type Description Default <code>weekly</code> <code>Level</code> <p>The weekly level to dispatch.</p> required <code>comment</code> <code>LevelComment</code> <p>The weekly comment to dispatch.</p> required Source code in <code>gd/client.py</code> <pre><code>async def dispatch_weekly_comment(self, weekly: Level, comment: LevelComment) -&gt; None:\n\"\"\"Dispatches `weekly_comment` events via calling\n    [`on_weekly_comment`][gd.client.Client.on_weekly_comment].\n\n    Arguments:\n        weekly: The weekly level to dispatch.\n        comment: The weekly comment to dispatch.\n    \"\"\"\n    await self.on_weekly_comment(weekly, comment)\n</code></pre>"},{"location":"reference/client/#gd.client.Client.dispatch_user_comment","title":"<code>dispatch_user_comment(user: User, comment: UserComment) -&gt; None</code>  <code>async</code>","text":"<p>Dispatches <code>user_comment</code> events via calling <code>on_user_comment</code>.</p> <p>Parameters:</p> Name Type Description Default <code>user</code> <code>User</code> <p>The user to dispatch.</p> required <code>comment</code> <code>UserComment</code> <p>The comment to dispatch.</p> required Source code in <code>gd/client.py</code> <pre><code>async def dispatch_user_comment(self, user: User, comment: UserComment) -&gt; None:\n\"\"\"Dispatches `user_comment` events via calling\n    [`on_user_comment`][gd.client.Client.on_user_comment].\n\n    Arguments:\n        user: The user to dispatch.\n        comment: The comment to dispatch.\n    \"\"\"\n    await self.on_user_comment(user, comment)\n</code></pre>"},{"location":"reference/client/#gd.client.Client.dispatch_user_level_comment","title":"<code>dispatch_user_level_comment(user: User, comment: LevelComment) -&gt; None</code>  <code>async</code>","text":"<p>Dispatches <code>user_level_comment</code> events via calling <code>on_user_level_comment</code>.</p> <p>Parameters:</p> Name Type Description Default <code>user</code> <code>User</code> <p>The user to dispatch.</p> required <code>comment</code> <code>LevelComment</code> <p>The level comment to dispatch.</p> required Source code in <code>gd/client.py</code> <pre><code>async def dispatch_user_level_comment(self, user: User, comment: LevelComment) -&gt; None:\n\"\"\"Dispatches `user_level_comment` events via calling\n    [`on_user_level_comment`][gd.client.Client.on_user_level_comment].\n\n    Arguments:\n        user: The user to dispatch.\n        comment: The level comment to dispatch.\n    \"\"\"\n    await self.on_user_level_comment(user, comment)\n</code></pre>"},{"location":"reference/client/#gd.client.Client.event","title":"<code>event(function: F) -&gt; F</code>","text":"<p>Registers an event handler.</p> Example <pre><code>client = Client()\n\nDAILY = \"new daily! {daily.name} by {daily.creator.name} (ID: {daily.id})\n\n@client.event\nasync def on_daily(daily: Level) -&gt; None:\n    print(DAILY.format(daily=daily))\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>function</code> <code>F</code> <p>The function to register as an event handler.</p> required <p>Returns:</p> Type Description <code>F</code> <p>The function passed.</p> Source code in <code>gd/client.py</code> <pre><code>def event(self, function: F) -&gt; F:\n\"\"\"Registers an event handler.\n\n    Example:\n        ```python\n        client = Client()\n\n        DAILY = \"new daily! {daily.name} by {daily.creator.name} (ID: {daily.id})\n\n        @client.event\n        async def on_daily(daily: Level) -&gt; None:\n            print(DAILY.format(daily=daily))\n        ```\n\n    Arguments:\n        function: The function to register as an event handler.\n\n    Returns:\n        The function passed.\n    \"\"\"\n    set_attribute(self, function.__name__, function)\n\n    return function\n</code></pre>"},{"location":"reference/enums/","title":"Enums","text":""},{"location":"reference/enums/#gd.enums.SimpleKey","title":"<code>SimpleKey</code>","text":"<p>         Bases: <code>Enum</code></p> <p>An enumertion of keys used in XOR ciphering.</p> Source code in <code>gd/enums.py</code> <pre><code>class SimpleKey(Enum):\n\"\"\"An enumertion of keys used in *XOR* ciphering.\"\"\"\n\n    SAVE = 11\n</code></pre>"},{"location":"reference/enums/#gd.enums.Key","title":"<code>Key</code>","text":"<p>         Bases: <code>Enum</code></p> <p>An enumeration of keys used in cyclic XOR ciphering.</p> Source code in <code>gd/enums.py</code> <pre><code>class Key(Enum):\n\"\"\"An enumeration of keys used in cyclic *XOR* ciphering.\"\"\"\n\n    MESSAGE = 14251\n    QUESTS = 19847\n    LEVEL_PASSWORD = 26364\n    COMMENT = 29481\n    USER_PASSWORD = 37526\n    LEVEL_LEADERBOARD = 39673\n    LEVEL = 41274\n    LIKE_RATE = 58281\n    CHESTS = 59182\n    USER_LEADERBOARD = 85271\n\n    def __init__(\n        self, value: int, encoding: str = DEFAULT_ENCODING, errors: str = DEFAULT_ERRORS\n    ) -&gt; None:\n        self.string = string = str(value)\n        self.bytes = string.encode(encoding, errors)\n</code></pre>"},{"location":"reference/enums/#gd.enums.Salt","title":"<code>Salt</code>","text":"<p>         Bases: <code>Enum</code></p> <p>An enumeration of salts used in hashing.</p> Source code in <code>gd/enums.py</code> <pre><code>class Salt(Enum):\n\"\"\"An enumeration of salts used in hashing.\"\"\"\n\n    LEVEL = \"xI25fpAapCQg\"\n    COMMENT = \"xPT6iUrtws0J\"\n    LIKE_RATE = \"ysg6pUrtjn0J\"\n    USER_LEADERBOARD = \"xI35fsAapCRg\"\n    LEVEL_LEADERBOARD = \"yPg6pUrtWn0J\"\n    QUESTS = \"oC36fpYaPtdg\"\n    CHESTS = \"pC26fpYaQCtg\"\n\n    EMPTY = EMPTY\n\n    def __init__(\n        self, string: str, encoding: str = DEFAULT_ENCODING, errors: str = DEFAULT_ERRORS\n    ) -&gt; None:\n        self.string = string\n        self.bytes = string.encode(encoding, errors)\n</code></pre>"},{"location":"reference/enums/#gd.enums.Secret","title":"<code>Secret</code>","text":"<p>         Bases: <code>Enum</code></p> <p>An enumeration of request secrets.</p> Source code in <code>gd/enums.py</code> <pre><code>class Secret(Enum):\n\"\"\"An enumeration of request secrets.\"\"\"\n\n    MAIN = \"Wmfd2893gb7\"\n    LEVEL = \"Wmfv2898gc9\"\n    USER = \"Wmfv3899gc9\"\n    MOD = \"Wmfp3879gc3\"\n</code></pre>"},{"location":"reference/enums/#gd.enums.AccountURLType","title":"<code>AccountURLType</code>","text":"<p>         Bases: <code>Enum</code></p> <p>An enumeration of account URL types.</p> Source code in <code>gd/enums.py</code> <pre><code>class AccountURLType(Enum):\n\"\"\"An enumeration of account URL types.\"\"\"\n\n    SAVE = 1\n    LOAD = 2\n</code></pre>"},{"location":"reference/enums/#gd.enums.IconType","title":"<code>IconType</code>","text":"<p>         Bases: <code>Enum</code></p> <p>An enumeration of icon types.</p> Source code in <code>gd/enums.py</code> <pre><code>class IconType(Enum):\n\"\"\"An enumeration of icon types.\"\"\"\n\n    CUBE = 0\n    SHIP = 1\n    BALL = 2\n    UFO = 3\n    WAVE = 4\n    ROBOT = 5\n    SPIDER = 6\n    # SWING_COPTER = 7\n\n    DEFAULT = CUBE\n\n    def is_default(self) -&gt; bool:\n        return self is type(self).DEFAULT\n\n    def is_cube(self) -&gt; bool:\n        return self is type(self).CUBE\n\n    def is_ship(self) -&gt; bool:\n        return self is type(self).SHIP\n\n    def is_ball(self) -&gt; bool:\n        return self is type(self).BALL\n\n    def is_ufo(self) -&gt; bool:\n        return self is type(self).UFO\n\n    def is_wave(self) -&gt; bool:\n        return self is type(self).WAVE\n\n    def is_robot(self) -&gt; bool:\n        return self is type(self).ROBOT\n\n    def is_spider(self) -&gt; bool:\n        return self is type(self).SPIDER\n</code></pre>"},{"location":"reference/enums/#gd.enums.MessageState","title":"<code>MessageState</code>","text":"<p>         Bases: <code>Enum</code></p> <p>An enumeration of message states.</p> Source code in <code>gd/enums.py</code> <pre><code>class MessageState(Enum):\n\"\"\"An enumeration of message states.\"\"\"\n\n    OPEN_TO_ALL = 0\n    OPEN_TO_FRIENDS = 1\n    CLOSED = 2\n\n    DEFAULT = OPEN_TO_ALL\n</code></pre>"},{"location":"reference/enums/#gd.enums.CommentState","title":"<code>CommentState</code>","text":"<p>         Bases: <code>Enum</code></p> <p>An enumeration of comment states.</p> Source code in <code>gd/enums.py</code> <pre><code>class CommentState(Enum):\n\"\"\"An enumeration of comment states.\"\"\"\n\n    OPEN_TO_ALL = 0\n    OPEN_TO_FRIENDS = 1\n    CLOSED = 2\n\n    DEFAULT = OPEN_TO_ALL\n</code></pre>"},{"location":"reference/enums/#gd.enums.FriendState","title":"<code>FriendState</code>","text":"<p>         Bases: <code>Enum</code></p> <p>An enumeration of friend states.</p> Source code in <code>gd/enums.py</code> <pre><code>class FriendState(Enum):\n\"\"\"An enumeration of friend states.\"\"\"\n\n    NOT_FRIEND = 0\n    FRIEND = 1\n    BLOCKED = 2\n    OUTGOING_REQUEST = 3\n    INCOMING_REQUEST = 4\n\n    DEFAULT = NOT_FRIEND\n</code></pre>"},{"location":"reference/enums/#gd.enums.FriendRequestState","title":"<code>FriendRequestState</code>","text":"<p>         Bases: <code>Enum</code></p> <p>An enumeration of friend request states.</p> Source code in <code>gd/enums.py</code> <pre><code>class FriendRequestState(Enum):\n\"\"\"An enumeration of friend request states.\"\"\"\n\n    OPEN = 0\n    CLOSED = 1\n\n    DEFAULT = OPEN\n</code></pre>"},{"location":"reference/enums/#gd.enums.Role","title":"<code>Role</code>","text":"<p>         Bases: <code>Enum</code></p> <p>An enumeration of server roles.</p> Source code in <code>gd/enums.py</code> <pre><code>class Role(Enum):\n\"\"\"An enumeration of server roles.\"\"\"\n\n    USER = 0\n    MODERATOR = 1\n    ELDER_MODERATOR = 2\n\n    DEFAULT = USER\n</code></pre>"},{"location":"reference/enums/#gd.enums.LevelLength","title":"<code>LevelLength</code>","text":"<p>         Bases: <code>Enum</code></p> <p>An enumeration of level lengths.</p> Source code in <code>gd/enums.py</code> <pre><code>class LevelLength(Enum):\n\"\"\"An enumeration of level lengths.\"\"\"\n\n    TINY = 0\n    SHORT = 1\n    MEDIUM = 2\n    LONG = 3\n    XL = 4\n    PLATFORMER = 5\n\n    DEFAULT = TINY\n\n    @classmethod\n    def _missing_(cls, value: Any) -&gt; Optional[LevelLength]:  # type: ignore\n        if value &lt; 0:\n            return cls.TINY\n\n        return cls.XL\n</code></pre>"},{"location":"reference/enums/#gd.enums.LevelPrivacy","title":"<code>LevelPrivacy</code>","text":"<p>         Bases: <code>Enum</code></p> <p>An enumeration of level publicity modes.</p> Source code in <code>gd/enums.py</code> <pre><code>class LevelPrivacy(Enum):\n\"\"\"An enumeration of level publicity modes.\"\"\"\n\n    PUBLIC = 0\n    FRIENDS = 1\n    PRIVATE = 2\n\n    DEFAULT = PUBLIC\n\n    def is_private(self) -&gt; bool:\n        return self is type(self).PRIVATE\n\n    def is_friends(self) -&gt; bool:\n        return self is type(self).FRIENDS\n\n    def is_public(self) -&gt; bool:\n        return self is type(self).PUBLIC\n</code></pre>"},{"location":"reference/enums/#gd.enums.Difficulty","title":"<code>Difficulty</code>","text":"<p>         Bases: <code>Enum</code></p> <p>An enumeration of level difficulties.</p> Source code in <code>gd/enums.py</code> <pre><code>class Difficulty(Enum):\n\"\"\"An enumeration of level difficulties.\"\"\"\n\n    UNKNOWN = 0\n\n    AUTO = 1\n    EASY = 2\n    NORMAL = 3\n    HARD = 4\n    HARDER = 5\n    INSANE = 6\n    DEMON = 7\n    EASY_DEMON = 8\n    MEDIUM_DEMON = 9\n    HARD_DEMON = 10\n    INSANE_DEMON = 11\n    EXTREME_DEMON = 12\n\n    NA = UNKNOWN\n\n    DEFAULT = UNKNOWN\n\n    def into_level_difficulty(self) -&gt; LevelDifficulty:\n        return DIFFICULTY_TO_LEVEL_DIFFICULTY[self]\n\n    def into_demon_difficulty(self) -&gt; DemonDifficulty:\n        return DIFFICULTY_TO_DEMON_DIFFICULTY[self]\n\n    def is_unknown(self) -&gt; bool:\n        return self is type(self).UNKNOWN\n\n    def is_auto(self) -&gt; bool:\n        return self is type(self).AUTO\n\n    def is_unspecified_demon(self) -&gt; bool:\n        return self is type(self).DEMON\n\n    def is_specified_demon(self) -&gt; bool:\n        return self in DEMON\n\n    def is_demon(self) -&gt; bool:\n        return self.is_unspecified_demon() or self.is_specified_demon()\n</code></pre>"},{"location":"reference/enums/#gd.enums.LevelDifficulty","title":"<code>LevelDifficulty</code>","text":"<p>         Bases: <code>Enum</code></p> <p>An enumeration of server level difficulties.</p> Source code in <code>gd/enums.py</code> <pre><code>class LevelDifficulty(Enum):\n\"\"\"An enumeration of server level difficulties.\"\"\"\n\n    UNKNOWN = -1\n    DEMON = -2\n    AUTO = -3\n    EASY = 1\n    NORMAL = 2\n    HARD = 3\n    HARDER = 4\n    INSANE = 5\n    EASY_DEMON = 6\n    MEDIUM_DEMON = 7\n    HARD_DEMON = 8\n    INSANE_DEMON = 9\n    EXTREME_DEMON = 10\n\n    NA = UNKNOWN\n\n    DEFAULT = UNKNOWN\n\n    def into_difficulty(self) -&gt; Difficulty:\n        return LEVEL_DIFFICULTY_TO_DIFFICULTY[self]\n</code></pre>"},{"location":"reference/enums/#gd.enums.DemonDifficulty","title":"<code>DemonDifficulty</code>","text":"<p>         Bases: <code>Enum</code></p> <p>An enumeration of demon difficulties.</p> Source code in <code>gd/enums.py</code> <pre><code>class DemonDifficulty(Enum):\n\"\"\"An enumeration of demon difficulties.\"\"\"\n\n    DEMON = 0\n    EASY_DEMON = 1\n    MEDIUM_DEMON = 2\n    HARD_DEMON = 3\n    INSANE_DEMON = 4\n    EXTREME_DEMON = 5\n\n    DEFAULT = DEMON\n\n    def into_difficulty(self) -&gt; Difficulty:\n        return DEMON_DIFFICULTY_TO_DIFFICULTY[self]\n\n    def into_level_difficulty(self) -&gt; LevelDifficulty:\n        return DEMON_DIFFICULTY_TO_LEVEL_DIFFICULTY[self]\n</code></pre>"},{"location":"reference/enums/#gd.enums.TimelyType","title":"<code>TimelyType</code>","text":"<p>         Bases: <code>Enum</code></p> <p>An enumeration of timely types.</p> Source code in <code>gd/enums.py</code> <pre><code>class TimelyType(Enum):\n\"\"\"An enumeration of timely types.\"\"\"\n\n    NOT_TIMELY = 0\n    DAILY = 1\n    WEEKLY = 2\n    EVENT = 3\n\n    DEFAULT = NOT_TIMELY\n\n    def into_timely_id(self) -&gt; TimelyID:\n        return TIMELY_TYPE_TO_ID[self]\n\n    def is_not_timely(self) -&gt; bool:\n        return self is type(self).NOT_TIMELY\n\n    def is_timely(self) -&gt; bool:\n        return not self.is_not_timely()\n\n    def is_daily(self) -&gt; bool:\n        return self is type(self).DAILY\n\n    def is_weekly(self) -&gt; bool:\n        return self is type(self).WEEKLY\n</code></pre>"},{"location":"reference/enums/#gd.enums.TimelyID","title":"<code>TimelyID</code>","text":"<p>         Bases: <code>Enum</code></p> <p>An enumeration of timely level IDs.</p> Source code in <code>gd/enums.py</code> <pre><code>class TimelyID(Enum):\n\"\"\"An enumeration of timely level IDs.\"\"\"\n\n    NOT_TIMELY = 0\n    DAILY = -1\n    WEEKLY = -2\n    EVENT = -3\n\n    DEFAULT = NOT_TIMELY\n\n    def into_timely_type(self) -&gt; TimelyType:\n        return TIMELY_ID_TO_TYPE[self]\n\n    def is_not_timely(self) -&gt; bool:\n        return self is type(self).NOT_TIMELY\n\n    def is_daily(self) -&gt; bool:\n        return self is type(self).DAILY\n\n    def is_weekly(self) -&gt; bool:\n        return self is type(self).WEEKLY\n</code></pre>"},{"location":"reference/enums/#gd.enums.RateFilter","title":"<code>RateFilter</code>","text":"<p>         Bases: <code>Enum</code></p> <p>An enumeration of rate filters.</p> Source code in <code>gd/enums.py</code> <pre><code>class RateFilter(Enum):\n\"\"\"An enumeration of rate filters.\"\"\"\n\n    NOT_RATED = 0\n    RATED = 1\n    FEATURED = 2\n    EPIC = 3\n    GODLIKE = 4\n\n    def is_not_rated(self) -&gt; bool:\n        return self is type(self).NOT_RATED\n\n    def is_rated(self) -&gt; bool:\n        return self is type(self).RATED\n\n    def is_featured(self) -&gt; bool:\n        return self is type(self).FEATURED\n\n    def is_epic(self) -&gt; bool:\n        return self is type(self).EPIC\n\n    def is_godlike(self) -&gt; bool:\n        return self is type(self).GODLIKE\n</code></pre>"},{"location":"reference/enums/#gd.enums.CommentType","title":"<code>CommentType</code>","text":"<p>         Bases: <code>Enum</code></p> <p>An enumeration of comment types.</p> Source code in <code>gd/enums.py</code> <pre><code>class CommentType(Enum):\n\"\"\"An enumeration of comment types.\"\"\"\n\n    LEVEL = 0\n    USER = 1\n</code></pre>"},{"location":"reference/enums/#gd.enums.RelationshipType","title":"<code>RelationshipType</code>","text":"<p>         Bases: <code>Enum</code></p> <p>An enumeration of relationship types.</p> Source code in <code>gd/enums.py</code> <pre><code>class RelationshipType(Enum):\n\"\"\"An enumeration of relationship types.\"\"\"\n\n    FRIEND = 1\n    BLOCKED = 2\n    INCOMING_REQUEST = 3\n    OUTGOING_REQUEST = 4\n</code></pre>"},{"location":"reference/enums/#gd.enums.SimpleRelationshipType","title":"<code>SimpleRelationshipType</code>","text":"<p>         Bases: <code>Enum</code></p> <p>An enumeration of simple relationship types.</p> Source code in <code>gd/enums.py</code> <pre><code>class SimpleRelationshipType(Enum):\n\"\"\"An enumeration of simple relationship types.\"\"\"\n\n    FRIEND = 0\n    BLOCKED = 1\n\n    def is_friend(self) -&gt; bool:\n        return self is type(self).FRIEND\n\n    def is_outgoing(self) -&gt; bool:\n        return self is type(self).BLOCKED\n\n    def into_relationship_type(self) -&gt; RelationshipType:\n        return SIMPLE_RELATIONSHIP_TYPE_TO_RELATIONSHIP_TYPE[self]\n</code></pre>"},{"location":"reference/enums/#gd.enums.FriendRequestType","title":"<code>FriendRequestType</code>","text":"<p>         Bases: <code>Enum</code></p> <p>An enumeration of friend request types.</p> Source code in <code>gd/enums.py</code> <pre><code>class FriendRequestType(Enum):\n\"\"\"An enumeration of friend request types.\"\"\"\n\n    INCOMING = 0\n    OUTGOING = 1\n\n    DEFAULT = INCOMING\n\n    def is_incoming(self) -&gt; bool:\n        return self is type(self).INCOMING\n\n    def is_outgoing(self) -&gt; bool:\n        return self is type(self).OUTGOING\n\n    def into_relationship_type(self) -&gt; RelationshipType:\n        return FRIEND_REQUEST_TYPE_TO_RELATIONSHIP_TYPE[self]\n</code></pre>"},{"location":"reference/enums/#gd.enums.MessageType","title":"<code>MessageType</code>","text":"<p>         Bases: <code>Enum</code></p> <p>An enumeration of message types.</p> Source code in <code>gd/enums.py</code> <pre><code>class MessageType(Enum):\n\"\"\"An enumeration of message types.\"\"\"\n\n    INCOMING = 0\n    OUTGOING = 1\n\n    DEFAULT = INCOMING\n\n    def is_incoming(self) -&gt; bool:\n        return self is type(self).INCOMING\n\n    def is_outgoing(self) -&gt; bool:\n        return self is type(self).OUTGOING\n</code></pre>"},{"location":"reference/enums/#gd.enums.CommentStrategy","title":"<code>CommentStrategy</code>","text":"<p>         Bases: <code>Enum</code></p> <p>An enumeration of comment searching strategies.</p> Source code in <code>gd/enums.py</code> <pre><code>class CommentStrategy(Enum):\n\"\"\"An enumeration of comment searching strategies.\"\"\"\n\n    RECENT = 0\n    MOST_LIKED = 1\n\n    DEFAULT = RECENT\n</code></pre>"},{"location":"reference/enums/#gd.enums.LeaderboardStrategy","title":"<code>LeaderboardStrategy</code>","text":"<p>         Bases: <code>Enum</code></p> <p>An enumeration of leaderboard strategies.</p> Source code in <code>gd/enums.py</code> <pre><code>class LeaderboardStrategy(Enum):\n\"\"\"An enumeration of leaderboard strategies.\"\"\"\n\n    PLAYERS = 0\n    FRIENDS = 1\n    RELATIVE = 2\n    CREATORS = 3\n\n    DEFAULT = PLAYERS\n\n    def requires_login(self) -&gt; bool:\n        return self in REQUIRES_LOGIN\n</code></pre>"},{"location":"reference/enums/#gd.enums.LevelLeaderboardStrategy","title":"<code>LevelLeaderboardStrategy</code>","text":"<p>         Bases: <code>Enum</code></p> <p>An enumeration of level leaderboard strategies.</p> Source code in <code>gd/enums.py</code> <pre><code>class LevelLeaderboardStrategy(Enum):\n\"\"\"An enumeration of level leaderboard strategies.\"\"\"\n\n    FRIENDS = 0\n    ALL = 1\n    WEEKLY = 2\n\n    DEFAULT = ALL\n</code></pre>"},{"location":"reference/enums/#gd.enums.LikeType","title":"<code>LikeType</code>","text":"<p>         Bases: <code>Enum</code></p> <p>An enumeration of like item types.</p> Source code in <code>gd/enums.py</code> <pre><code>class LikeType(Enum):\n\"\"\"An enumeration of like item types.\"\"\"\n\n    LEVEL = 1\n    LEVEL_COMMENT = 2\n    USER_COMMENT = 3\n</code></pre>"},{"location":"reference/enums/#gd.enums.GauntletID","title":"<code>GauntletID</code>","text":"<p>         Bases: <code>Enum</code></p> <p>An enumeration of gauntlet IDs.</p> Source code in <code>gd/enums.py</code> <pre><code>class GauntletID(Enum):\n\"\"\"An enumeration of gauntlet IDs.\"\"\"\n\n    UNKNOWN = 0\n    FIRE = 1\n    ICE = 2\n    POISON = 3\n    SHADOW = 4\n    LAVA = 5\n    BONUS = 6\n    CHAOS = 7\n    DEMON = 8\n    TIME = 9\n    CRYSTAL = 10\n    MAGIC = 11\n    SPIKE = 12\n    MONSTER = 13\n    DOOM = 14\n    DEATH = 15\n\n    @classmethod\n    def _missing_(cls, value: Any) -&gt; GauntletID:  # type: ignore\n        return cls.UNKNOWN\n</code></pre>"},{"location":"reference/enums/#gd.enums.SearchStrategy","title":"<code>SearchStrategy</code>","text":"<p>         Bases: <code>Enum</code></p> <p>An enumeration of search strategies.</p> Source code in <code>gd/enums.py</code> <pre><code>class SearchStrategy(Enum):\n\"\"\"An enumeration of search strategies.\"\"\"\n\n    DEFAULT = 0\n    MOST_DOWNLOADED = 1\n    MOST_LIKED = 2\n    TRENDING = 3\n    RECENT = 4\n    BY_USER = 5\n    FEATURED = 6\n    MAGIC = 7\n    SENT = 8\n    SEARCH_MANY = 10\n    RATED = 11\n    FOLLOWED = 12\n    FRIENDS = 13\n    MOST_LIKED_WORLD = 15\n    HALL_OF_FAME = 16\n    FEATURED_WORLD = 17\n    UNKNOWN = 18\n    DAILY_HISTORY = 21\n    WEEKLY_HISTORY = 22\n\n    def is_default(self) -&gt; bool:\n        return self is type(self).DEFAULT\n\n    def is_most_downloaded(self) -&gt; bool:\n        return self is type(self).MOST_DOWNLOADED\n\n    def is_most_liked(self) -&gt; bool:\n        return self is type(self).MOST_LIKED\n\n    def is_trending(self) -&gt; bool:\n        return self is type(self).TRENDING\n\n    def is_recent(self) -&gt; bool:\n        return self is type(self).RECENT\n\n    def is_by_user(self) -&gt; bool:\n        return self is type(self).BY_USER\n\n    def is_featured(self) -&gt; bool:\n        return self is type(self).FEATURED\n\n    def is_magic(self) -&gt; bool:\n        return self is type(self).MAGIC\n\n    def is_sent(self) -&gt; bool:\n        return self is type(self).SENT\n\n    def is_search_many(self) -&gt; bool:\n        return self is type(self).SEARCH_MANY\n\n    def is_rated(self) -&gt; bool:\n        return self is type(self).RATED\n\n    def is_followed(self) -&gt; bool:\n        return self is type(self).FOLLOWED\n\n    def is_friends(self) -&gt; bool:\n        return self is type(self).FRIENDS\n\n    def is_most_liked_world(self) -&gt; bool:\n        return self is type(self).MOST_LIKED_WORLD\n\n    def is_hall_of_fame(self) -&gt; bool:\n        return self is type(self).HALL_OF_FAME\n\n    def is_featured_world(self) -&gt; bool:\n        return self is type(self).FEATURED_WORLD\n\n    def is_unknown(self) -&gt; bool:\n        return self is type(self).UNKNOWN\n\n    def is_daily_history(self) -&gt; bool:\n        return self is type(self).DAILY_HISTORY\n\n    def is_weekly_history(self) -&gt; bool:\n        return self is type(self).WEEKLY_HISTORY\n</code></pre>"},{"location":"reference/enums/#gd.enums.RewardType","title":"<code>RewardType</code>","text":"<p>         Bases: <code>Enum</code></p> <p>An enumeration of reward types.</p> Source code in <code>gd/enums.py</code> <pre><code>class RewardType(Enum):\n\"\"\"An enumeration of reward types.\"\"\"\n\n    GET_INFO = 0\n    CLAIM_SMALL = 1\n    CLAIM_LARGE = 2\n\n    DEFAULT = GET_INFO\n</code></pre>"},{"location":"reference/enums/#gd.enums.ShardType","title":"<code>ShardType</code>","text":"<p>         Bases: <code>Enum</code></p> <p>An enumeration of shard types.</p> Source code in <code>gd/enums.py</code> <pre><code>class ShardType(Enum):\n\"\"\"An enumeration of shard types.\"\"\"\n\n    UNKNOWN = 0\n    FIRE = 1\n    ICE = 2\n    POISON = 3\n    SHADOW = 4\n    LAVA = 5\n    NULL = 6\n\n    DEFAULT = UNKNOWN\n</code></pre>"},{"location":"reference/enums/#gd.enums.ItemType","title":"<code>ItemType</code>","text":"<p>         Bases: <code>Enum</code></p> <p>An enumeration of item types.</p> Source code in <code>gd/enums.py</code> <pre><code>class ItemType(Enum):\n\"\"\"An enumeration of item types.\"\"\"\n\n    UNKNOWN = 0\n\n    FIRE_SHARD = 1\n    ICE_SHARD = 2\n    POISON_SHARD = 3\n    SHADOW_SHARD = 4\n    LAVA_SHARD = 5\n    KEY = 6\n    ORB = 7\n    DIAMOND = 8\n    CUSTOM = 9\n\n    DEFAULT = UNKNOWN\n\n    def is_custom(self) -&gt; bool:\n        return self is type(self).CUSTOM\n</code></pre>"},{"location":"reference/enums/#gd.enums.QuestType","title":"<code>QuestType</code>","text":"<p>         Bases: <code>Enum</code></p> <p>An enumeration of quest types.</p> Source code in <code>gd/enums.py</code> <pre><code>class QuestType(Enum):\n\"\"\"An enumeration of quest types.\"\"\"\n\n    UNKNOWN = 0\n    ORBS = 1\n    COINS = 2\n    STARS = 3\n\n    DEFAULT = UNKNOWN\n\n    def is_unknown(self) -&gt; bool:\n        return self is type(self).UNKNOWN\n</code></pre>"},{"location":"reference/enums/#gd.enums.Scene","title":"<code>Scene</code>","text":"<p>         Bases: <code>Enum</code></p> <p>An enumeration of different scene IDs.</p> Source code in <code>gd/enums.py</code> <pre><code>class Scene(Enum):\n\"\"\"An enumeration of different scene IDs.\"\"\"\n\n    MAIN = 0\n    SELECT = 1\n    OLD = 2\n    EDITOR_OR_LEVEL = 3\n    SEARCH = 4\n    UNUSED = 5\n    LEADERBOARD = 6\n    ONLINE = 7\n    OFFICIAL_SELECT = 8\n    OFFICIAL_LEVEL = 9\n    THE_CHALLENGE = 12\n</code></pre>"},{"location":"reference/enums/#gd.enums.PlayerColor","title":"<code>PlayerColor</code>","text":"<p>         Bases: <code>Enum</code></p> <p>An enumeration of player color settings.</p> Source code in <code>gd/enums.py</code> <pre><code>class PlayerColor(Enum):\n\"\"\"An enumeration of player color settings.\"\"\"\n\n    NOT_USED = 0\n\n    COLOR_1 = 1\n    COLOR_2 = 2\n\n    P1 = COLOR_1\n    P2 = COLOR_2\n\n    DEFAULT = NOT_USED\n\n    def is_not_used(self) -&gt; bool:\n        return self is type(self).NOT_USED\n\n    def is_default(self) -&gt; bool:\n        return self is type(self).DEFAULT\n\n    def is_color_1(self) -&gt; bool:\n        return self is type(self).COLOR_1\n\n    def is_color_2(self) -&gt; bool:\n        return self is type(self).COLOR_2\n</code></pre>"},{"location":"reference/enums/#gd.enums.CustomParticleGrouping","title":"<code>CustomParticleGrouping</code>","text":"<p>         Bases: <code>Enum</code></p> <p>An enumeration of particle grouping types.</p> Source code in <code>gd/enums.py</code> <pre><code>class CustomParticleGrouping(Enum):\n\"\"\"An enumeration of particle grouping types.\"\"\"\n\n    FREE = 0\n    RELATIVE = 1\n    GROUPED = 2\n</code></pre>"},{"location":"reference/enums/#gd.enums.CustomParticleProperty","title":"<code>CustomParticleProperty</code>","text":"<p>         Bases: <code>Enum</code></p> <p>An enumeration of particle system types.</p> Source code in <code>gd/enums.py</code> <pre><code>class CustomParticleProperty(Enum):\n\"\"\"An enumeration of particle system types.\"\"\"\n\n    GRAVITY = 0\n    RADIUS = 1\n</code></pre>"},{"location":"reference/enums/#gd.enums.Easing","title":"<code>Easing</code>","text":"<p>         Bases: <code>Enum</code></p> <p>An enumeration of easing types.</p> Source code in <code>gd/enums.py</code> <pre><code>class Easing(Enum):\n\"\"\"An enumeration of easing types.\"\"\"\n\n    NONE = 0\n    EASE_IN_OUT = 1\n    EASE_IN = 2\n    EASE_OUT = 3\n    ELASTIC_IN_OUT = 4\n    ELASTIC_IN = 5\n    ELASTIC_OUT = 6\n    BOUNCE_IN_OUT = 7\n    BOUNCE_IN = 8\n    BOUNCE_OUT = 9\n    EXPONENTIAL_IN_OUT = 10\n    EXPONENTIAL_IN = 11\n    EXPONENTIAL_OUT = 12\n    SINE_IN_OUT = 13\n    SINE_IN = 14\n    SINE_OUT = 15\n    BACK_IN_OUT = 16\n    BACK_IN = 17\n    BACK_OUT = 18\n\n    DEFAULT = NONE\n</code></pre>"},{"location":"reference/enums/#gd.enums.EasingMethod","title":"<code>EasingMethod</code>","text":"<p>         Bases: <code>Flag</code></p> <p>An enumeration of easing method flags.</p> Source code in <code>gd/enums.py</code> <pre><code>class EasingMethod(Flag):\n\"\"\"An enumeration of easing method flags.\"\"\"\n\n    NONE = 0\n    IN = 1\n    OUT = 2\n    EASE = 4\n    ELASTIC = 8\n    BOUNCE = 16\n    EXPONENTIAL = 32\n    SINE = 64\n    BACK = 128\n\n    DEFAULT = NONE\n\n    def into_easing(self) -&gt; Easing:\n        cls = type(self)\n        value = self.value\n\n        if not value:\n            return Easing.NONE\n\n        has_easing_in = cls.IN in self\n        has_easing_out = cls.OUT in self\n\n        if not has_easing_in and not has_easing_out:\n            raise ValueError(f\"{self!r} does not have In / Out modifiers.\")\n\n        value = (value.bit_length() - IN_OUT_SHIFT) * MULTIPLIER\n\n        if has_easing_in:\n            value -= 1\n\n        if has_easing_out:\n            value -= 1\n\n        return Easing(value)\n\n    @classmethod\n    def from_easing(cls, easing: Easing) -&gt; EasingMethod:\n        value = easing.value\n\n        if not value:\n            return cls.DEFAULT\n\n        IN = cls.IN\n        OUT = cls.OUT\n\n        shift, remainder = divmod((value - 1), MULTIPLIER)\n        shift += IN_OUT_SHIFT\n\n        has_easing_in = remainder != OUT.value\n        has_easing_out = remainder != IN.value\n\n        result = cls(1 &lt;&lt; shift)\n\n        if has_easing_in:\n            result |= IN\n\n        if has_easing_out:\n            result |= OUT\n\n        return result\n</code></pre>"},{"location":"reference/enums/#gd.enums.PulseMode","title":"<code>PulseMode</code>","text":"<p>         Bases: <code>Enum</code></p> <p>An enumeration of pulse modes.</p> Source code in <code>gd/enums.py</code> <pre><code>class PulseMode(Enum):\n\"\"\"An enumeration of pulse modes.\"\"\"\n\n    COLOR = 0\n    HSV = 1\n\n    DEFAULT = COLOR\n\n    def is_color(self) -&gt; bool:\n        return self is type(self).COLOR\n\n    def is_hsv(self) -&gt; bool:\n        return self is type(self).HSV\n</code></pre>"},{"location":"reference/enums/#gd.enums.ToggleType","title":"<code>ToggleType</code>","text":"<p>         Bases: <code>Enum</code></p> <p>An enumeration of toggle types.</p> Source code in <code>gd/enums.py</code> <pre><code>class ToggleType(Enum):\n\"\"\"An enumeration of toggle types.\"\"\"\n\n    SPAWN = 0\n    TOGGLE_ON = 1\n    TOGGLE_OFF = 2\n\n    DEFAULT = SPAWN\n</code></pre>"},{"location":"reference/enums/#gd.enums.InstantCountComparison","title":"<code>InstantCountComparison</code>","text":"<p>         Bases: <code>Enum</code></p> <p>An enumeration of instant count comparison types.</p> Source code in <code>gd/enums.py</code> <pre><code>class InstantCountComparison(Enum):\n\"\"\"An enumeration of instant count comparison types.\"\"\"\n\n    EQUALS = 0\n    LARGER = 1\n    SMALLER = 2\n\n    DEFAULT = EQUALS\n</code></pre>"},{"location":"reference/enums/#gd.enums.OrbType","title":"<code>OrbType</code>","text":"<p>         Bases: <code>Enum</code></p> <p>An enumeration of IDs of orb objects.</p> Source code in <code>gd/enums.py</code> <pre><code>class OrbType(Enum):\n\"\"\"An enumeration of IDs of orb objects.\"\"\"\n\n    YELLOW = 36\n    BLUE = 84\n    PINK = 141\n    GREEN = 1022\n    RED = 1333\n    BLACK = 1330\n    DASH = 1704\n    REVERSE_DASH = 1751\n    TRIGGER = 1594\n\n    @property\n    def id(self) -&gt; int:\n        return self.value\n\n    def is_trigger(self) -&gt; int:\n        return self is type(self).TRIGGER\n</code></pre>"},{"location":"reference/enums/#gd.enums.PadType","title":"<code>PadType</code>","text":"<p>         Bases: <code>Enum</code></p> <p>An enumeration of IDs of pad objects.</p> Source code in <code>gd/enums.py</code> <pre><code>class PadType(Enum):\n\"\"\"An enumeration of IDs of pad objects.\"\"\"\n\n    YELLOW = 35\n    BLUE = 67\n    PINK = 140\n    RED = 1332\n\n    @property\n    def id(self) -&gt; int:\n        return self.value\n</code></pre>"},{"location":"reference/enums/#gd.enums.MiscType","title":"<code>MiscType</code>","text":"<p>         Bases: <code>Enum</code></p> <p>An enumeration of IDs of miscellaneous objects.</p> Source code in <code>gd/enums.py</code> <pre><code>class MiscType(Enum):\n\"\"\"An enumeration of IDs of miscellaneous objects.\"\"\"\n\n    TEXT = 914\n    START_POSITION = 31\n    ITEM_COUNTER = 1615\n    COLLISION_BLOCK = 1816\n\n    @property\n    def id(self) -&gt; int:\n        return self.value\n</code></pre>"},{"location":"reference/enums/#gd.enums.PickupItemMode","title":"<code>PickupItemMode</code>","text":"<p>         Bases: <code>Enum</code></p> <p>An enumeration of pickup item modes.</p> Source code in <code>gd/enums.py</code> <pre><code>class PickupItemMode(Enum):\n\"\"\"An enumeration of pickup item modes.\"\"\"\n\n    DEFAULT = 0\n    PICKUP = 1\n    TOGGLE_TRIGGER = 2\n\n    def is_pickup(self) -&gt; bool:\n        return self is type(self).PICKUP\n\n    def is_toggle_trigger(self) -&gt; bool:\n        return self is type(self).TOGGLE_TRIGGER\n</code></pre>"},{"location":"reference/enums/#gd.enums.GameMode","title":"<code>GameMode</code>","text":"<p>         Bases: <code>Enum</code></p> <p>An enumeration of game modes.</p> Source code in <code>gd/enums.py</code> <pre><code>class GameMode(Enum):\n\"\"\"An enumeration of game modes.\"\"\"\n\n    CUBE = 0\n    SHIP = 1\n    BALL = 2\n    UFO = 3\n    WAVE = 4\n    ROBOT = 5\n    SPIDER = 6\n    # SWING_COPTER = 7\n\n    DEFAULT = CUBE\n</code></pre>"},{"location":"reference/enums/#gd.enums.LevelType","title":"<code>LevelType</code>","text":"<p>         Bases: <code>Enum</code></p> <p>An enumeration of level types.</p> Source code in <code>gd/enums.py</code> <pre><code>class LevelType(Enum):\n\"\"\"An enumeration of level types.\"\"\"\n\n    NULL = 0\n    OFFICIAL = 1\n    EDITOR = 2\n    SAVED = 3\n    ONLINE = 4\n\n    def is_null(self) -&gt; bool:\n        return self is type(self).NULL\n\n    def is_official(self) -&gt; bool:\n        return self is type(self).OFFICIAL\n\n    def is_editor(self) -&gt; bool:\n        return self is type(self).EDITOR\n\n    def is_saved(self) -&gt; bool:\n        return self is type(self).SAVED\n\n    def is_online(self) -&gt; bool:\n        return self is type(self).ONLINE\n\n    DEFAULT = NULL\n</code></pre>"},{"location":"reference/enums/#gd.enums.PortalType","title":"<code>PortalType</code>","text":"<p>         Bases: <code>Enum</code></p> <p>An enumeration of IDs of portals.</p> Source code in <code>gd/enums.py</code> <pre><code>class PortalType(Enum):\n\"\"\"An enumeration of IDs of portals.\"\"\"\n\n    CUBE = 12\n    SHIP = 13\n    BALL = 47\n    UFO = 111\n    WAVE = 660\n    ROBOT = 745\n    SPIDER = 1331\n\n    YELLOW_GRAVITY = 11\n    BLUE_GRAVITY = 10\n    YELLOW_MIRROR = 45\n    BLUE_MIRROR = 46\n    PINK_SIZE = 101\n    GREEN_SIZE = 99\n    YELLOW_DUAL = 286\n    BLUE_DUAL = 287\n    BLUE_TELEPORT = 747\n    YELLOW_TELEPORT = 749\n\n    @property\n    def id(self) -&gt; int:\n        return self.value\n</code></pre>"},{"location":"reference/enums/#gd.enums.SpeedChangeType","title":"<code>SpeedChangeType</code>","text":"<p>         Bases: <code>Enum</code></p> <p>An enumeration of IDs of speed changes.</p> Source code in <code>gd/enums.py</code> <pre><code>class SpeedChangeType(Enum):\n\"\"\"An enumeration of IDs of speed changes.\"\"\"\n\n    SLOW = 200\n    NORMAL = 201\n    FAST = 202\n    FASTER = 203\n    FASTEST = 1334\n\n    @property\n    def id(self) -&gt; int:\n        return self.value\n</code></pre>"},{"location":"reference/enums/#gd.enums.PulseTargetType","title":"<code>PulseTargetType</code>","text":"<p>         Bases: <code>Enum</code></p> <p>An enumeration of pulse target types.</p> Source code in <code>gd/enums.py</code> <pre><code>class PulseTargetType(Enum):\n\"\"\"An enumeration of pulse target types.\"\"\"\n\n    COLOR_CHANNEL = 0\n    GROUP = 1\n\n    DEFAULT = COLOR_CHANNEL\n\n    def is_color_channel(self) -&gt; bool:\n        return self is type(self).COLOR_CHANNEL\n\n    def is_group(self) -&gt; bool:\n        return self is type(self).GROUP\n</code></pre>"},{"location":"reference/enums/#gd.enums.PulseType","title":"<code>PulseType</code>","text":"<p>         Bases: <code>Flag</code></p> <p>An enumeration of pulse types.</p> Source code in <code>gd/enums.py</code> <pre><code>class PulseType(Flag):\n\"\"\"An enumeration of pulse types.\"\"\"\n\n    MAIN = 1\n    DETAIL = 2\n\n    BOTH = MAIN | DETAIL\n\n    DEFAULT = BOTH\n\n    def is_main_only(self) -&gt; bool:\n        return self is type(self).MAIN\n\n    def is_detail_only(self) -&gt; bool:\n        return self is type(self).DETAIL\n</code></pre>"},{"location":"reference/enums/#gd.enums.SpecialBlockType","title":"<code>SpecialBlockType</code>","text":"<p>         Bases: <code>Enum</code></p> <p>An enumeration of IDs of special objects (<code>D</code>, <code>J</code>, <code>S</code>, <code>H</code>).</p> Source code in <code>gd/enums.py</code> <pre><code>class SpecialBlockType(Enum):\n\"\"\"An enumeration of IDs of special objects (`D`, `J`, `S`, `H`).\"\"\"\n\n    D = 1755\n    J = 1813\n    S = 1829\n    H = 1859\n</code></pre>"},{"location":"reference/enums/#gd.enums.SpecialColorID","title":"<code>SpecialColorID</code>","text":"<p>         Bases: <code>Enum</code></p> <p>An enumeration of IDs of special colors.</p> Source code in <code>gd/enums.py</code> <pre><code>class SpecialColorID(Enum):\n\"\"\"An enumeration of IDs of special colors.\"\"\"\n\n    BACKGROUND = BG = 1000\n    GROUND = G = 1001\n    LINE = L = 1002\n    LINE_3D = L3D = 1003\n    OBJECT = OBJ = 1004\n    PLAYER_1 = P1 = 1005\n    PLAYER_2 = P2 = 1006\n    LIGHT_BACKGROUND = LBG = 1007\n    SECONDARY_GROUND = GROUND_2 = G2 = 1009\n    BLACK = 1010\n    WHITE = 1011\n    LIGHTER = 1012\n\n    @property\n    def id(self) -&gt; int:\n        return self.value\n</code></pre>"},{"location":"reference/enums/#gd.enums.TargetType","title":"<code>TargetType</code>","text":"<p>         Bases: <code>Flag</code></p> <p>An enumeration of move target types.</p> Source code in <code>gd/enums.py</code> <pre><code>class TargetType(Flag):\n\"\"\"An enumeration of move target types.\"\"\"\n\n    NONE = 0\n\n    X = 1\n    Y = 2\n\n    BOTH = X | Y\n\n    DEFAULT = NONE\n\n    def is_none(self) -&gt; bool:\n        return self is type(self).NONE\n\n    def into_simple_target_type(self) -&gt; SimpleTargetType:\n        return TARGET_TYPE_TO_SIMPLE_TARGET_TYPE[self]\n</code></pre>"},{"location":"reference/enums/#gd.enums.SimpleTargetType","title":"<code>SimpleTargetType</code>","text":"<p>         Bases: <code>Flag</code></p> <p>An enumeration of simple move target types.</p> Source code in <code>gd/enums.py</code> <pre><code>class SimpleTargetType(Flag):\n\"\"\"An enumeration of simple move target types.\"\"\"\n\n    BOTH = 0\n\n    X_ONLY = 1\n    Y_ONLY = 2\n\n    DEFAULT = BOTH\n\n    def into_target_type(self) -&gt; TargetType:\n        return SIMPLE_TARGET_TYPE_TO_TARGET_TYPE[self]\n</code></pre>"},{"location":"reference/enums/#gd.enums.TouchToggleMode","title":"<code>TouchToggleMode</code>","text":"<p>         Bases: <code>Enum</code></p> <p>An enumeration of touch toggle modes.</p> Source code in <code>gd/enums.py</code> <pre><code>class TouchToggleMode(Enum):\n\"\"\"An enumeration of touch toggle modes.\"\"\"\n\n    DEFAULT = 0\n    ON = 1\n    OFF = 2\n</code></pre>"},{"location":"reference/enums/#gd.enums.TriggerType","title":"<code>TriggerType</code>","text":"<p>         Bases: <code>Enum</code></p> <p>An enumeration of IDs of triggers.</p> Source code in <code>gd/enums.py</code> <pre><code>class TriggerType(Enum):\n\"\"\"An enumeration of IDs of triggers.\"\"\"\n\n    BACKGROUND = BG = 29\n    GROUND = G = 30\n    LINE = L = 104\n    OBJECT = OBJ = 105\n    COLOR_1 = C1 = 221\n    COLOR_2 = C2 = 717\n    COLOR_3 = C3 = 718\n    COLOR_4 = C4 = 743\n    LINE_3D = L3D = 744\n    COLOR = 899\n    SECONDARY_GROUND = GROUND_2 = G2 = 900\n    MOVE = 901\n    LINE_2 = L2 = 915\n    PULSE = 1006\n    ALPHA = 1007\n    TOGGLE = 1049\n    SPAWN = 1268\n    ROTATE = 1346\n    FOLLOW = 1347\n    SHAKE = 1520\n    ANIMATE = 1585\n    TOUCH = 1595\n    COUNT = 1611\n    STOP = 1616\n    INSTANT_COUNT = 1811\n    ON_DEATH = 1812\n    FOLLOW_PLAYER_Y = 1814\n    COLLISION = 1815\n    PICKUP = 1817\n\n    @property\n    def id(self) -&gt; int:\n        return self.value\n</code></pre>"},{"location":"reference/enums/#gd.enums.ZLayer","title":"<code>ZLayer</code>","text":"<p>         Bases: <code>Enum</code></p> <p>An enumeration of Z layers.</p> Source code in <code>gd/enums.py</code> <pre><code>class ZLayer(Enum):\n\"\"\"An enumeration of Z layers.\"\"\"\n\n    BOTTOM_4 = B4 = 1\n    BOTTOM_3 = B3 = 2\n    BOTTOM_2 = B2 = 3\n    BOTTOM_1 = B1 = 4\n\n    DEFAULT = D = 0\n\n    TOP_1 = T1 = 5\n    TOP_2 = T2 = 6\n    TOP_3 = T3 = 7\n\n    def is_default(self) -&gt; bool:\n        return self is type(self).DEFAULT\n\n    def into_simple_z_layer(self) -&gt; SimpleZLayer:\n        return Z_LAYER_TO_SIMPLE_Z_LAYER[self]\n</code></pre>"},{"location":"reference/enums/#gd.enums.SimpleZLayer","title":"<code>SimpleZLayer</code>","text":"<p>         Bases: <code>Enum</code></p> <p>An enumeration of simple Z layers.</p> Source code in <code>gd/enums.py</code> <pre><code>class SimpleZLayer(Enum):\n\"\"\"An enumeration of simple Z layers.\"\"\"\n\n    BOTTOM_4 = B4 = -3\n    BOTTOM_3 = B3 = -1\n    BOTTOM_2 = B2 = 1\n    BOTTOM_1 = B1 = 3\n    TOP_1 = T1 = 5\n    TOP_2 = T2 = 7\n    TOP_3 = T3 = 9\n\n    DEFAULT = D = 0\n\n    BOTTOM = 1\n    MIDDLE = 3\n    TOP = 5\n    VERY_TOP = 7\n\n    ABS_ZERO = 4\n\n    def is_default(self) -&gt; bool:\n        return self is type(self).DEFAULT\n\n    def into_z_layer(self) -&gt; ZLayer:\n        return SIMPLE_Z_LAYER_TO_Z_LAYER[self]\n</code></pre>"},{"location":"reference/enums/#gd.enums.Speed","title":"<code>Speed</code>","text":"<p>         Bases: <code>Enum</code></p> <p>An enumeration of speed modifiers.</p> Source code in <code>gd/enums.py</code> <pre><code>class Speed(Enum):\n\"\"\"An enumeration of speed modifiers.\"\"\"\n\n    NORMAL = 0\n    SLOW = 1\n    FAST = 2\n    FASTER = 3\n    FASTEST = 4\n\n    DEFAULT = NORMAL\n</code></pre>"},{"location":"reference/enums/#gd.enums.SpeedConstant","title":"<code>SpeedConstant</code>","text":"<p>         Bases: <code>float</code>, <code>Enum</code></p> <p>An enumeration of actual speed modifiers.</p> Source code in <code>gd/enums.py</code> <pre><code>class SpeedConstant(float, Enum):\n\"\"\"An enumeration of actual speed modifiers.\"\"\"\n\n    NULL = 0.0\n    SLOW = 0.7\n    NORMAL = 0.9\n    FAST = 1.1\n    FASTER = 1.3\n    FASTEST = 1.6\n</code></pre>"},{"location":"reference/enums/#gd.enums.SpeedMagic","title":"<code>SpeedMagic</code>","text":"<p>         Bases: <code>float</code>, <code>Enum</code></p> <p>An enumeration of magic speed constants.</p> Source code in <code>gd/enums.py</code> <pre><code>class SpeedMagic(float, Enum):\n\"\"\"An enumeration of *magic* speed constants.\"\"\"\n\n    SLOW = 251.16\n    NORMAL = 311.58\n    FAST = 387.42\n    FASTER = 468.0\n    FASTEST = 576.0\n    DEFAULT = NORMAL\n</code></pre>"},{"location":"reference/enums/#gd.enums.GuidelineColor","title":"<code>GuidelineColor</code>","text":"<p>         Bases: <code>float</code>, <code>Enum</code></p> <p>An enumeration of guideline colors.</p> Source code in <code>gd/enums.py</code> <pre><code>class GuidelineColor(float, Enum):\n\"\"\"An enumeration of guideline colors.\"\"\"\n\n    DEFAULT = 0.0\n    TRANSPARENT = 0.7\n    ORANGE = 0.8\n    YELLOW = 0.9\n    GREEN = 1.0\n\n    @classmethod\n    def _missing_(cls, value: Any) -&gt; GuidelineColor:  # type: ignore\n        if cls.ORANGE &lt; value &lt; cls.GREEN:\n            return cls.ORANGE\n\n        return cls.TRANSPARENT\n</code></pre>"},{"location":"reference/enums/#gd.enums.InternalType","title":"<code>InternalType</code>","text":"<p>         Bases: <code>Enum</code></p> <p>An enumeration of internal types.</p> Source code in <code>gd/enums.py</code> <pre><code>class InternalType(Enum):\n\"\"\"An enumeration of internal types.\"\"\"\n\n    LEVEL = 4\n    SONG = 6\n    QUEST = 7\n    REWARD_ITEM = 8\n    REWARD = 9\n</code></pre>"},{"location":"reference/enums/#gd.enums.Filter","title":"<code>Filter</code>","text":"<p>         Bases: <code>Enum</code></p> <p>An enumeration of filter types.</p> Source code in <code>gd/enums.py</code> <pre><code>class Filter(Enum):\n\"\"\"An enumeration of filter types.\"\"\"\n\n    NONE = 0\n    DETAIL = 1\n    STATIC = 2\n    CUSTOM = 3\n\n    DEFAULT = NONE\n\n    def is_none(self) -&gt; bool:\n        return self is type(self).NONE\n\n    def is_detail(self) -&gt; bool:\n        return self is type(self).DETAIL\n\n    def is_static(self) -&gt; bool:\n        return self is type(self).STATIC\n\n    def is_custom(self) -&gt; bool:\n        return self is type(self).CUSTOM\n\n    def is_default(self) -&gt; bool:\n        return self is type(self).DEFAULT\n</code></pre>"},{"location":"reference/enums/#gd.enums.ByteOrder","title":"<code>ByteOrder</code>","text":"<p>         Bases: <code>Enum</code></p> <p>An enumeration of binary orders (used in binary protocols).</p> Source code in <code>gd/enums.py</code> <pre><code>class ByteOrder(Enum):\n\"\"\"An enumeration of binary orders (used in binary protocols).\"\"\"\n\n    NATIVE = \"=\"\n    LITTLE = \"&lt;\"\n    BIG = \"&gt;\"\n\n    DEFAULT = LITTLE\n\n    def is_native(self) -&gt; bool:\n        return self is type(self).NATIVE\n\n    def is_little(self) -&gt; bool:\n        return self is type(self).LITTLE\n\n    def is_big(self) -&gt; bool:\n        return self is type(self).BIG\n\n    def is_default(self) -&gt; bool:\n        return self is type(self).DEFAULT\n</code></pre>"},{"location":"reference/enums/#gd.enums.Platform","title":"<code>Platform</code>","text":"<p>         Bases: <code>Enum</code></p> <p>An enumeration of system platforms.</p> Source code in <code>gd/enums.py</code> <pre><code>class Platform(Enum):\n\"\"\"An enumeration of system platforms.\"\"\"\n\n    UNKNOWN = 0\n\n    ANDROID = 1\n    DARWIN = 2\n    LINUX = 3\n    WINDOWS = 4\n\n    DEFAULT = UNKNOWN\n\n    def is_unknown(self) -&gt; bool:\n        return self is type(self).UNKNOWN\n\n    def is_android(self) -&gt; bool:\n        return self is type(self).ANDROID\n\n    def is_darwin(self) -&gt; bool:\n        return self is type(self).DARWIN\n\n    def is_linux(self) -&gt; bool:\n        return self is type(self).LINUX\n\n    def is_windows(self) -&gt; bool:\n        return self is type(self).WINDOWS\n</code></pre>"},{"location":"reference/enums/#gd.enums.Orientation","title":"<code>Orientation</code>","text":"<p>         Bases: <code>Enum</code></p> <p>An enumeration of orientations.</p> Source code in <code>gd/enums.py</code> <pre><code>class Orientation(Enum):\n\"\"\"An enumeration of orientations.\"\"\"\n\n    HORIZONTAL = 0\n    VERTICAL = 1\n\n    DEFAULT = HORIZONTAL\n\n    def is_horizontal(self) -&gt; bool:\n        return self is type(self).HORIZONTAL\n\n    def is_vertical(self) -&gt; bool:\n        return self is type(self).VERTICAL\n</code></pre>"},{"location":"reference/enums/#gd.enums.ResponseType","title":"<code>ResponseType</code>","text":"<p>         Bases: <code>Enum</code></p> <p>An enumeration of response types.</p> Source code in <code>gd/enums.py</code> <pre><code>class ResponseType(Enum):\n\"\"\"An enumeration of response types.\"\"\"\n\n    BYTES = 0\n    TEXT = 1\n    JSON = 2\n\n    DEFAULT = TEXT\n</code></pre>"},{"location":"reference/enums/#gd.enums.CollectedCoins","title":"<code>CollectedCoins</code>","text":"<p>         Bases: <code>Flag</code></p> <p>An enumeration of collected coins.</p> Source code in <code>gd/enums.py</code> <pre><code>class CollectedCoins(Flag):\n\"\"\"An enumeration of collected coins.\"\"\"\n\n    NONE = 0\n\n    FIRST = 1\n    SECOND = 2\n    THIRD = 4\n\n    ALL = FIRST | SECOND | THIRD\n\n    DEFAULT = NONE\n\n    def first(self) -&gt; bool:\n        return type(self).FIRST in self\n\n    def second(self) -&gt; bool:\n        return type(self).SECOND in self\n\n    def third(self) -&gt; bool:\n        return type(self).THIRD in self\n\n    def all(self) -&gt; bool:\n        return type(self).ALL in self\n</code></pre>"},{"location":"reference/song/","title":"Song","text":""},{"location":"reference/song/#gd.song.Song","title":"<code>Song</code>","text":"<p>         Bases: <code>Entity</code></p> <p>Represents Geometry Dash and Newgrounds songs.</p> Binary <pre><code>const CUSTOM_BIT: u8 = 0b00000001;\n\nstruct Song {\nid: u32,\nname_length: u8,\nname: [u8; name_length],  // utf-8 string\nartist: Artist,\nsize: f32,\nvalue: u8,  // contains `custom`\ndownload_url_length: u16,\ndownload_url: [u8; download_url_length],  // utf-8 string\n}\n</code></pre> Source code in <code>gd/song.py</code> <pre><code>@register_unstructure_hook_omit_client\n@define()\nclass Song(Entity):\n\"\"\"Represents *Geometry Dash* and *Newgrounds* songs.\n\n    Binary:\n\n        ```rust\n        const CUSTOM_BIT: u8 = 0b00000001;\n\n        struct Song {\n            id: u32,\n            name_length: u8,\n            name: [u8; name_length],  // utf-8 string\n            artist: Artist,\n            size: f32,\n            value: u8,  // contains `custom`\n            download_url_length: u16,\n            download_url: [u8; download_url_length],  // utf-8 string\n        }\n        ```\n    \"\"\"\n\n    name: str\n    artist: Artist\n    size: float = DEFAULT_SIZE\n\n    custom: bool = DEFAULT_CUSTOM\n\n    download_url: Optional[URL] = None\n\n    def __hash__(self) -&gt; int:\n        return hash(type(self)) ^ self.id\n\n    @property\n    def url(self) -&gt; URL:\n        return URL(NEWGROUNDS_SONG.format(self.id))\n\n    @classmethod\n    def from_data(cls: Type[S], data: SongData) -&gt; S:  # type: ignore\n        return CONVERTER.structure(data, cls)\n\n    def into_data(self) -&gt; SongData:\n        return CONVERTER.unstructure(self)  # type: ignore\n\n    @classmethod\n    def from_binary(\n        cls: Type[S],\n        binary: BinaryReader,\n        order: ByteOrder = ByteOrder.DEFAULT,\n        version: int = VERSION,\n        encoding: str = DEFAULT_ENCODING,\n        errors: str = DEFAULT_ERRORS,\n    ) -&gt; S:\n        custom_bit = CUSTOM_BIT\n\n        reader = Reader(binary, order)\n\n        id = reader.read_u32()\n\n        name_length = reader.read_u8()\n\n        name = reader.read(name_length).decode(encoding, errors)\n\n        artist = Artist.from_binary(binary, order, version, encoding, errors)\n\n        size = reader.read_f32()\n\n        value = reader.read_u8()\n\n        custom = value &amp; custom_bit == custom_bit\n\n        download_url_length = reader.read_u16()\n\n        string = reader.read(download_url_length).decode(encoding, errors)\n\n        if not string:\n            download_url = None\n\n        else:\n            download_url = URL(string)\n\n        return cls(\n            id=id, name=name, artist=artist, size=size, custom=custom, download_url=download_url\n        )\n\n    def to_binary(\n        self,\n        binary: BinaryWriter,\n        order: ByteOrder = ByteOrder.DEFAULT,\n        version: int = VERSION,\n        encoding: str = DEFAULT_ENCODING,\n        errors: str = DEFAULT_ERRORS,\n    ) -&gt; None:\n        writer = Writer(binary, order)\n\n        writer.write_u32(self.id)\n\n        data = self.name.encode(encoding, errors)\n\n        writer.write_u8(len(data))\n\n        writer.write(data)\n\n        self.artist.to_binary(binary, order, version, encoding, errors)\n\n        writer.write_f32(self.size)\n\n        value = 0\n\n        if self.is_custom():\n            value |= CUSTOM_BIT\n\n        writer.write_u8(value)\n\n        download_url = self.download_url\n\n        if download_url is None:\n            string = EMPTY\n\n        else:\n            string = str(download_url)\n\n        data = string.encode(encoding, errors)\n\n        writer.write_u16(len(data))\n\n        writer.write(data)\n\n    @classmethod\n    def default(cls: Type[S]) -&gt; S:\n        return cls(id=DEFAULT_ID, name=UNKNOWN, artist=Artist.default())\n\n    @classmethod\n    def from_model(cls: Type[S], model: SongModel) -&gt; S:\n        return cls(\n            id=model.id,\n            name=model.name,\n            artist=Artist(model.artist_name),\n            size=model.size,\n            download_url=model.download_url,\n        )\n\n    def __str__(self) -&gt; str:\n        return self.name\n\n    def is_custom(self) -&gt; bool:\n        return self.custom\n\n    @classmethod\n    def official(\n        cls: Type[S],\n        id: Optional[int] = None,\n        name: Optional[str] = None,\n        server_style: bool = DEFAULT_SERVER_STYLE,\n        return_default: bool = DEFAULT_RETURN_DEFAULT,\n    ) -&gt; S:\n        official_songs = OFFICIAL_SERVER_SONGS if server_style else OFFICIAL_CLIENT_SONGS\n\n        if id is None:\n            if name is None:\n                raise LookupError(EXPECTED_QUERY)\n\n            official_song = iter(official_songs).find(by_name(name)).extract()\n\n        else:\n            official_song = iter(official_songs).find(by_id(id)).extract()\n\n        if official_song is None:\n            if return_default:\n                official_song = default_official_song() if id is None else default_official_song(id)\n\n            else:\n                raise LookupError(CAN_NOT_FIND_SONG)\n\n        return cls(\n            id=official_song.id,\n            name=official_song.name,\n            size=DEFAULT_SIZE,\n            artist=official_song.artist,\n            custom=False,\n        )\n\n    async def get(self, from_newgrounds: bool = DEFAULT_FROM_NEWGROUNDS) -&gt; Song:\n        if from_newgrounds:\n            return await self.client.get_newgrounds_song(self.id)\n\n        else:\n            return await self.client.get_song(self.id)\n\n    async def update(self: S, from_newgrounds: bool = DEFAULT_FROM_NEWGROUNDS) -&gt; S:\n        return self.update_from(await self.get(from_newgrounds=from_newgrounds))\n\n    async def ensure_download_url(self) -&gt; None:\n        download_url = self.download_url\n\n        if download_url is None:\n            await self.update(from_newgrounds=True)\n\n        download_url = self.download_url\n\n        if download_url is None:\n            raise MissingAccess(CAN_NOT_FIND_URL)\n\n    async def download(self, file: BinaryIO, with_bar: bool = DEFAULT_WITH_BAR) -&gt; None:\n        if self.is_custom():\n            await self.ensure_download_url()\n\n            await self.client.http.download(\n                file, self.download_url, with_bar=with_bar  # type: ignore\n            )\n\n        else:\n            raise MissingAccess(CAN_NOT_DOWNLOAD)\n\n    async def download_bytes(self, with_bar: bool = DEFAULT_WITH_BAR) -&gt; bytes:\n        if self.is_custom():\n            await self.ensure_download_url()\n\n            return await self.client.http.download_bytes(\n                self.download_url, with_bar=with_bar  # type: ignore\n            )\n\n        raise MissingAccess(CAN_NOT_DOWNLOAD)\n\n    async def download_to(self, path: IntoPath, with_bar: bool = DEFAULT_WITH_BAR) -&gt; None:\n        if self.is_custom():\n            await self.ensure_download_url()\n\n            await self.client.http.download_to(\n                path, self.download_url, with_bar=with_bar  # type: ignore\n            )\n\n        else:\n            raise MissingAccess(CAN_NOT_DOWNLOAD)\n</code></pre>"},{"location":"reference/tasks/","title":"Tasks","text":"<p>..., adapted from <code>discord.py</code> library.</p>"},{"location":"reference/tasks/#gd.tasks.ExponentialBackoff","title":"<code>ExponentialBackoff</code>","text":"<p>Implements the exponential backoff algorithm.</p> <p>Provides a convenient interface to implement an exponential backoff for reconnecting or retrying transmissions in a distributed network.</p> <p>Once instantiated, the delay method will return the next interval to wait for when retrying a connection or transmission. The maximum delay increases exponentially with each retry up to a maximum of \\(m \\cdot b^l\\) (where \\(m\\) is <code>multiply</code>, \\(b\\) is <code>base</code> and \\(l\\) is <code>limit</code>), and is reset if no more attempts are needed in a period of \\(m \\cdot b^{l + 1}\\) seconds.</p> Source code in <code>gd/tasks.py</code> <pre><code>@define()\nclass ExponentialBackoff:\n\"\"\"Implements the *exponential backoff* algorithm.\n\n    Provides a convenient interface to implement an exponential backoff\n    for reconnecting or retrying transmissions in a distributed network.\n\n    Once instantiated, the delay method will return the next interval to\n    wait for when retrying a connection or transmission. The maximum\n    delay increases exponentially with each retry up to a maximum of\n    $m \\\\cdot b^l$ (where $m$ is `multiply`, $b$ is `base` and $l$ is `limit`),\n    and is reset if no more attempts are needed in a period of $m \\\\cdot b^{l + 1}$ seconds.\n    \"\"\"\n\n    multiply: float = field(default=DEFAULT_MULTIPLY)\n    base: float = field(default=DEFAULT_BASE)\n    limit: int = field(default=DEFAULT_LIMIT)\n\n    _clock: Clock = field(default=clock)\n\n    _exponent: int = field(default=0, init=False)\n    _last_called: float = field(init=False)\n    _reset_delta: float = field(init=False)\n\n    @_last_called.default\n    def default_last_called(self) -&gt; float:\n        return self._clock()\n\n    @_reset_delta.default\n    def default_reset_delta(self) -&gt; float:\n        return self.multiply * pow(self.base, self.limit + 1)\n\n    def delay(self) -&gt; float:\n\"\"\"Computes the next delay.\n\n        Returns the next delay to wait according to the exponential\n        backoff algorithm. This is a value between $0$ and $m \\\\cdot b^e$\n        where $e$ (`exponent`) starts off at $0$ and is incremented at every\n        invocation of this method up to a maximum of $l$ (`limit`).\n\n        If a period of more than $m \\\\cdot b^{l + 1}$ has passed since the last\n        retry, the `exponent` ($e$) is reset to $0$.\n        \"\"\"\n        called = self._clock()\n\n        interval = called - self._last_called\n        self._last_called = called\n\n        if interval &gt; self._reset_delta:\n            self._exponent = 0\n\n        if self._exponent &lt; self.limit:\n            self._exponent += 1\n\n        return uniform_to(self.multiply * pow(self.base, self._exponent))\n</code></pre>"},{"location":"reference/tasks/#gd.tasks.ExponentialBackoff.delay","title":"<code>delay() -&gt; float</code>","text":"<p>Computes the next delay.</p> <p>Returns the next delay to wait according to the exponential backoff algorithm. This is a value between \\(0\\) and \\(m \\cdot b^e\\) where \\(e\\) (<code>exponent</code>) starts off at \\(0\\) and is incremented at every invocation of this method up to a maximum of \\(l\\) (<code>limit</code>).</p> <p>If a period of more than \\(m \\cdot b^{l + 1}\\) has passed since the last retry, the <code>exponent</code> (\\(e\\)) is reset to \\(0\\).</p> Source code in <code>gd/tasks.py</code> <pre><code>def delay(self) -&gt; float:\n\"\"\"Computes the next delay.\n\n    Returns the next delay to wait according to the exponential\n    backoff algorithm. This is a value between $0$ and $m \\\\cdot b^e$\n    where $e$ (`exponent`) starts off at $0$ and is incremented at every\n    invocation of this method up to a maximum of $l$ (`limit`).\n\n    If a period of more than $m \\\\cdot b^{l + 1}$ has passed since the last\n    retry, the `exponent` ($e$) is reset to $0$.\n    \"\"\"\n    called = self._clock()\n\n    interval = called - self._last_called\n    self._last_called = called\n\n    if interval &gt; self._reset_delta:\n        self._exponent = 0\n\n    if self._exponent &lt; self.limit:\n        self._exponent += 1\n\n    return uniform_to(self.multiply * pow(self.base, self._exponent))\n</code></pre>"},{"location":"reference/tasks/#gd.tasks.Loop","title":"<code>Loop</code>","text":"<p>         Bases: <code>Generic[P]</code></p> <p>Abstracts away event loop handling and reconnection logic.</p> <p>The main interface to create this is through <code>loop</code>.</p> Source code in <code>gd/tasks.py</code> <pre><code>@define()\nclass Loop(Generic[P]):\n\"\"\"Abstracts away event loop handling and reconnection logic.\n\n    The main interface to create this is through [`loop`][gd.tasks.loop].\n    \"\"\"\n\n    function: AsyncCallable[P, None] = field()\n\n    delay: float = field(default=DEFAULT_DELAY)\n\n    count: Optional[int] = field(default=None)\n\n    reconnect: bool = field(default=DEFAULT_RECONNECT)\n\n    _task: Optional[Task[None]] = field(default=None, init=False)\n\n    _current_count: int = field(default=0, init=False)\n\n    _error_types: AnyErrorTypes = field(\n        default=(OSError, GDError, ClientError, TimeoutError),\n        init=False,\n    )\n\n    _is_being_cancelled: bool = field(default=False, init=False)\n    _has_failed: bool = field(default=False, init=False)\n    _stop_next_iteration: bool = field(default=False, init=False)\n\n    _injected: Optional[Any] = field(default=None, init=False)\n\n    _before_loop: Optional[LoopFunction[Any]] = field(default=None, init=False)\n    _after_loop: Optional[LoopFunction[Any]] = field(default=None, init=False)\n\n    async def _call_before_loop(self) -&gt; None:\n        before_loop = self._before_loop\n\n        if before_loop is None:\n            return\n\n        injected = self._injected\n\n        if injected is None:\n            await before_loop()  # type: ignore\n\n        else:\n            await before_loop(injected)  # type: ignore\n\n    async def _call_after_loop(self) -&gt; None:\n        after_loop = self._after_loop\n\n        if after_loop is None:\n            return\n\n        injected = self._injected\n\n        if injected is None:\n            await after_loop()  # type: ignore\n\n        else:\n            await after_loop(injected)  # type: ignore\n\n    async def _loop(self, *args: P.args, **kwargs: P.kwargs) -&gt; None:\n        backoff = ExponentialBackoff()\n\n        await self._call_before_loop()\n\n        try:\n            while True:\n                try:\n                    await self.function(*args, **kwargs)\n\n                except self._error_types:\n\n                    if not self.reconnect:\n                        raise\n\n                    await sleep(backoff.delay())\n\n                else:\n                    if self._stop_next_iteration:\n                        return\n\n                    self._current_count += 1\n\n                    if self._current_count == self.count:\n                        break\n\n                    await sleep(self.delay)\n\n        except CancelledError:\n            self._is_being_cancelled = True\n\n            raise\n\n        except Exception:\n            self._has_failed = True\n\n            raise\n\n        finally:\n            await self._call_after_loop()\n\n            self._current_count = 0\n\n            self._is_being_cancelled = False\n            self._has_failed = False\n            self._stop_next_iteration = False\n\n    def __get__(self: L, instance: Optional[S], type: Optional[Type[S]] = None) -&gt; L:\n        if instance is None:\n            return self\n\n        self._injected = instance\n\n        return self\n\n    @property\n    def current_count(self) -&gt; int:\n        return self._current_count\n\n    def start(self, *args: Any, **kwargs: Any) -&gt; Task[None]:\n        task = self._task\n\n        if task is not None and not task.done():\n            raise RuntimeError(TASK_ALREADY_LAUNCHED)\n\n        injected = self._injected\n\n        if injected is not None:\n            args = (injected, *args)\n\n        self._task = task = get_event_loop().create_task(self._loop(*args, **kwargs))\n\n        return task\n\n    def stop(self) -&gt; None:\n        task = self._task\n\n        if task is not None and not task.done():\n            self._stop_next_iteration = True\n\n    @property\n    def _can_be_cancelled(self) -&gt; bool:\n        task = self._task\n\n        return not self._is_being_cancelled and task is not None and not task.done()\n\n    def cancel(self) -&gt; None:\n        if self._can_be_cancelled:\n            self._task.cancel()  # type: ignore\n\n    def restart(self, *args: Any, **kwargs: Any) -&gt; None:\n        def restart_when_over(\n            task: Task[None],\n            *,\n            args: DynamicTuple[Any] = args,\n            kwargs: StringDict[Any] = kwargs,\n        ) -&gt; None:\n            self._task.remove_done_callback(restart_when_over)  # type: ignore\n            self.start(*args, **kwargs)\n\n        if self._can_be_cancelled:\n            self._task.add_done_callback(restart_when_over)  # type: ignore\n            self._task.cancel()  # type: ignore\n\n    def add_error_type(self, error_type: AnyErrorType) -&gt; None:\n        self._error_types = (*self._error_types, error_type)\n\n    def clear_error_types(self) -&gt; None:\n        self._error_types = ()\n\n    def remove_error_type(self, error_type: AnyErrorType) -&gt; bool:\n        error_types = self._error_types\n\n        length = len(error_types)\n\n        self._error_types = error_types = tuple(\n            present_error_type\n            for present_error_type in error_types\n            if present_error_type is not error_type\n        )\n\n        return len(error_types) &lt; length\n\n    def is_being_cancelled(self) -&gt; bool:\n        return self._is_being_cancelled\n\n    def has_failed(self) -&gt; bool:\n        return self._has_failed\n\n    def before_loop(self, loop_function: F) -&gt; F:\n        self._before_loop = loop_function\n\n        return loop_function\n\n    def after_loop(self, loop_function: F) -&gt; F:\n        self._after_loop = loop_function\n\n        return loop_function\n</code></pre>"},{"location":"reference/api/color_channels/","title":"Color Channels","text":""},{"location":"reference/api/color_channels/#gd.api.color_channels.ColorChannel","title":"<code>ColorChannel</code>","text":"<p>         Bases: <code>Binary</code>, <code>RobTop</code></p> <p>Represents color channels.</p> Binary <pre><code>struct ColorChannel {\nid: u16,\ncopied_id: u16,\nnested: NestedColorChannel,\n}\n\nenum NestedColorChannel {\nNormal(NormalColorChannel),  // if `copied_id == 0`\nCopied(CopiedColorChannel),  // if `copied_id != 0`\n}\n\nconst BLENDING_BIT: u8 = 0b00000001;\nconst COPY_OPACITY_BIT: u8 = 0b00000010;\n\nstruct CopiedColorChannel {\nhsv: HSV,\nvalue: u8,\n// copy_opacity = value &amp; COPY_OPACITY_BIT == COPY_OPACITY_BIT\n// blending = value &amp; BLENDING_BIT == BLENDING_BIT\nopacity: Option&lt;f32&gt;,  // if `!copy_opacity`\n}\n\nconst BYTE: u32 = 0b11111111;\nconst BITS: u32 = u8::BITS;\n\nconst PLAYER_COLOR_MASK: u8 = 0b00000110;\nconst PLAYER_COLOR_SHIFT: u8 = PLAYER_COLOR_MASK.trailing_zeros() as u8;\n\nstruct NormalColorChannel {\nvalue: u32,\n// player_color_and_blending = (value &amp; BYTE) as u8\n// player_color = (value &amp; PLAYER_COLOR_MASK) &gt;&gt; PLAYER_COLOR_SHIFT\n// blending = value &amp; BLENDING_BIT == BLENDING_BIT\n// color = value &gt;&gt; BITS\nopacity: f32,\n}\n</code></pre> Source code in <code>gd/api/color_channels.py</code> <pre><code>@define()\nclass ColorChannel(Binary, RobTop):\n\"\"\"Represents color channels.\n\n    Binary:\n        ```rust\n        struct ColorChannel {\n            id: u16,\n            copied_id: u16,\n            nested: NestedColorChannel,\n        }\n\n        enum NestedColorChannel {\n            Normal(NormalColorChannel),  // if `copied_id == 0`\n            Copied(CopiedColorChannel),  // if `copied_id != 0`\n        }\n\n        const BLENDING_BIT: u8 = 0b00000001;\n        const COPY_OPACITY_BIT: u8 = 0b00000010;\n\n        struct CopiedColorChannel {\n            hsv: HSV,\n            value: u8,\n            // copy_opacity = value &amp; COPY_OPACITY_BIT == COPY_OPACITY_BIT\n            // blending = value &amp; BLENDING_BIT == BLENDING_BIT\n            opacity: Option&lt;f32&gt;,  // if `!copy_opacity`\n        }\n\n        const BYTE: u32 = 0b11111111;\n        const BITS: u32 = u8::BITS;\n\n        const PLAYER_COLOR_MASK: u8 = 0b00000110;\n        const PLAYER_COLOR_SHIFT: u8 = PLAYER_COLOR_MASK.trailing_zeros() as u8;\n\n        struct NormalColorChannel {\n            value: u32,\n            // player_color_and_blending = (value &amp; BYTE) as u8\n            // player_color = (value &amp; PLAYER_COLOR_MASK) &gt;&gt; PLAYER_COLOR_SHIFT\n            // blending = value &amp; BLENDING_BIT == BLENDING_BIT\n            // color = value &gt;&gt; BITS\n            opacity: f32,\n        }\n        ```\n    \"\"\"\n\n    id: int = field()\n    color: Color = field(factory=Color.default)\n    player_color: PlayerColor = field(default=PlayerColor.DEFAULT)\n    blending: bool = field(default=DEFAULT_BLENDING)\n    opacity: float = field(default=DEFAULT_OPACITY)\n    copied_id: int = field(default=DEFAULT_ID)\n    hsv: HSV = field(factory=HSV)\n    copy_opacity: bool = field(default=DEFAULT_COPY_OPACITY)\n\n    @classmethod\n    def from_robtop(cls: Type[CC], string: str) -&gt; CC:\n        mapping = split_color_channel(string)\n\n        id = parse_get_or(int, DEFAULT_ID, mapping.get(ID))\n\n        copied_id = parse_get_or(int, DEFAULT_ID, mapping.get(COPIED_ID))\n\n        blending = parse_get_or(int_bool, DEFAULT_BLENDING, mapping.get(BLENDING))\n\n        if copied_id:\n            hsv = parse_get_or(HSV.from_robtop, HSV(), mapping.get(COLOR_HSV))\n\n            copy_opacity = parse_get_or(int_bool, DEFAULT_COPY_OPACITY, mapping.get(COPY_OPACITY))\n\n            player_color = PlayerColor.DEFAULT\n\n            if not copy_opacity:\n                opacity = parse_get_or(float, DEFAULT_OPACITY, mapping.get(OPACITY))\n\n            else:\n                opacity = DEFAULT_OPACITY\n\n            color = Color.default()\n\n        else:\n            hsv = HSV()\n\n            copy_opacity = DEFAULT_COPY_OPACITY\n\n            player_color_value = parse_get_or(\n                int, DEFAULT_PLAYER_COLOR_VALUE, mapping.get(PLAYER_COLOR)\n            )\n\n            if player_color_value &lt; 0:\n                player_color_value = 0\n\n            player_color = PlayerColor(player_color_value)\n\n            red, green, blue = (\n                parse_get_or(int, DEFAULT_RED, mapping.get(RED)),\n                parse_get_or(int, DEFAULT_GREEN, mapping.get(GREEN)),\n                parse_get_or(int, DEFAULT_BLUE, mapping.get(BLUE)),\n            )\n\n            color = Color.from_rgb(red, green, blue)\n\n            opacity = parse_get_or(float, DEFAULT_OPACITY, mapping.get(OPACITY))\n\n        return cls(\n            id=id,\n            color=color,\n            player_color=player_color,\n            blending=blending,\n            opacity=opacity,\n            copied_id=copied_id,\n            hsv=hsv,\n            copy_opacity=copy_opacity,\n        )\n\n    def to_robtop(self) -&gt; str:\n        red, green, blue = self.color.to_rgb()\n\n        mapping = {\n            RED: str(red),\n            GREEN: str(green),\n            BLUE: str(blue),\n            PLAYER_COLOR: str(self.player_color.value),\n            BLENDING: str(int(self.is_blending())),\n            ID: str(self.id),\n            OPACITY: float_str(self.opacity),\n            UNKNOWN: str(int(DEFAULT_UNKNOWN)),\n            COPIED_ID: str(self.copied_id),\n            COLOR_HSV: self.hsv.to_robtop(),\n            TO_RED: str(DEFAULT_TO_RED),\n            TO_GREEN: str(DEFAULT_TO_GREEN),\n            TO_BLUE: str(DEFAULT_TO_BLUE),\n            DURATION: float_str(DEFAULT_DURATION),\n            TO_OPACITY: float_str(DEFAULT_TO_OPACITY),\n            COPY_OPACITY: str(int(self.is_copy_opacity())),\n            UNKNOWN_ANOTHER: str(int(DEFAULT_UNKNOWN_ANOTHER)),\n        }\n\n        return concat_color_channel(mapping)\n\n    @classmethod\n    def from_binary(\n        cls: Type[CC],\n        binary: BinaryReader,\n        order: ByteOrder = ByteOrder.DEFAULT,\n        version: int = VERSION,\n    ) -&gt; CC:\n        bits = BITS\n        byte = BYTE\n\n        player_color_mask = PLAYER_COLOR_MASK\n        blending_bit = BLENDING_BIT\n        copy_opacity_bit = COPY_OPACITY_BIT\n\n        reader = Reader(binary, order)\n\n        id = reader.read_u16()\n\n        copied_id = reader.read_u16()\n\n        if copied_id:\n            hsv = HSV.from_binary(binary, order, version)\n\n            copy_opacity_and_blending = reader.read_u8()\n\n            blending = copy_opacity_and_blending &amp; blending_bit == blending_bit\n\n            copy_opacity = copy_opacity_and_blending &amp; copy_opacity_bit == copy_opacity_bit\n\n            player_color = PlayerColor.DEFAULT\n\n            if not copy_opacity:\n                opacity = reader.read_f32()\n\n            else:\n                opacity = DEFAULT_OPACITY  # does not matter\n\n            color = Color.default()\n\n        else:\n            hsv = HSV()\n\n            copy_opacity = DEFAULT_COPY_OPACITY\n\n            value = reader.read_u32()\n\n            player_color_and_blending = value &amp; byte\n\n            player_color_value = (\n                player_color_and_blending &amp; player_color_mask\n            ) &gt;&gt; PLAYER_COLOR_SHIFT\n\n            player_color = PlayerColor(player_color_value)\n\n            blending = player_color_and_blending &amp; blending_bit == blending_bit\n\n            value &gt;&gt;= bits\n\n            color = Color(value)\n\n            opacity = reader.read_f32()\n\n        return cls(\n            id=id,\n            color=color,\n            player_color=player_color,\n            blending=blending,\n            opacity=opacity,\n            copied_id=copied_id,\n            hsv=hsv,\n            copy_opacity=copy_opacity,\n        )\n\n    def to_binary(\n        self, binary: BinaryWriter, order: ByteOrder = ByteOrder.DEFAULT, version: int = VERSION\n    ) -&gt; None:\n        bits = BITS\n\n        writer = Writer(binary, order)\n\n        writer.write_u16(self.id)\n\n        copied_id = self.copied_id\n\n        writer.write_u16(copied_id)\n\n        if copied_id:\n            self.hsv.to_binary(binary, order, version)\n\n            value = 0\n\n            if self.is_blending():\n                value |= BLENDING_BIT\n\n            copy_opacity = self.is_copy_opacity()\n\n            if copy_opacity:\n                value |= COPY_OPACITY_BIT\n\n            writer.write_u8(value)\n\n            if not copy_opacity:\n                writer.write_f32(self.opacity)\n\n        else:\n            value = 0\n\n            if self.is_blending():\n                value |= BLENDING_BIT\n\n            value |= self.player_color.value &lt;&lt; PLAYER_COLOR_SHIFT\n\n            value |= self.color.value &lt;&lt; bits\n\n            writer.write_u32(value)\n\n            writer.write_f32(self.opacity)\n\n    def is_blending(self) -&gt; bool:\n        return self.blending\n\n    def is_copied(self) -&gt; bool:\n        return bool(self.copied_id)\n\n    def is_copy_opacity(self) -&gt; bool:\n        return self.copy_opacity\n</code></pre>"},{"location":"reference/api/color_channels/#gd.api.color_channels.ColorChannels","title":"<code>ColorChannels</code>","text":"<p>         Bases: <code>Binary</code>, <code>Dict[int, ColorChannel]</code></p> <p>Represents collections of color channels.</p> Binary <pre><code>struct ColorChannels {\ncolor_channels_length: u16,\ncolor_channels: [ColorChannel; color_channels_length],\n}\n</code></pre> Source code in <code>gd/api/color_channels.py</code> <pre><code>class ColorChannels(Binary, Dict[int, ColorChannel]):\n\"\"\"Represents collections of color channels.\n\n    Binary:\n        ```rust\n        struct ColorChannels {\n            color_channels_length: u16,\n            color_channels: [ColorChannel; color_channels_length],\n        }\n        ```\n    \"\"\"\n\n    def copy(self: CCS) -&gt; CCS:\n        return type(self)(self)\n\n    @classmethod\n    def from_color_channel_iterable(cls: Type[CCS], color_channels: Iterable[ColorChannel]) -&gt; CCS:\n        return cls({color_channel.id: color_channel for color_channel in color_channels})\n\n    from_channel_iterable = from_color_channel_iterable\n\n    @classmethod\n    def from_color_channels(cls: Type[CCS], *color_channels: ColorChannel) -&gt; CCS:\n        return cls.from_color_channel_iterable(color_channels)\n\n    from_channels = from_color_channels\n\n    @property\n    def length(self) -&gt; int:\n        return len(self)\n\n    def add(self, color_channel: ColorChannel) -&gt; None:\n        self[color_channel.id] = color_channel\n\n    @classmethod\n    def from_robtop(cls: Type[CCS], string: str) -&gt; CCS:\n        return cls.from_color_channel_iterable(\n            iter(split_color_channels(string)).map(ColorChannel.from_robtop).unwrap()\n        )\n\n    def to_robtop(self) -&gt; str:\n        return concat_color_channels(color_channel.to_robtop() for color_channel in self.values())\n\n    @classmethod\n    def from_binary(\n        cls: Type[CCS],\n        binary: BinaryReader,\n        order: ByteOrder = ByteOrder.DEFAULT,\n        version: int = VERSION,\n    ) -&gt; CCS:\n        reader = Reader(binary, order)\n\n        length = reader.read_u16()\n\n        color_channel_from_binary = partial(ColorChannel.from_binary, binary, order, version)\n\n        color_channels = iter.repeat_exactly_with(color_channel_from_binary, length).unwrap()\n\n        return cls.from_color_channel_iterable(color_channels)\n\n    def to_binary(\n        self, binary: BinaryWriter, order: ByteOrder = ByteOrder.DEFAULT, version: int = VERSION\n    ) -&gt; None:\n        writer = Writer(binary, order)\n\n        writer.write_u16(self.length)\n\n        for color_channel in self.values():\n            color_channel.to_binary(binary, order, version)\n</code></pre>"},{"location":"reference/api/editor/","title":"Editor","text":""},{"location":"reference/api/editor/#gd.api.editor.Editor","title":"<code>Editor</code>","text":"<p>         Bases: <code>RobTop</code>, <code>Binary</code>, <code>Sequence[Object]</code></p> <p>Represents editors.</p> Binary <pre><code>struct Editor {\nheader: Header,\nobjects_length: u32,\nobjects: [Object; objects_length],\n}\n</code></pre> Source code in <code>gd/api/editor.py</code> <pre><code>@define()\nclass Editor(RobTop, Binary, Sequence[Object]):\n\"\"\"Represents editors.\n\n    Binary:\n        ```rust\n        struct Editor {\n            header: Header,\n            objects_length: u32,\n            objects: [Object; objects_length],\n        }\n        ```\n    \"\"\"\n\n    header: Header = field(factory=Header)\n\"\"\"The header of the editor.\"\"\"\n    objects: List[Object] = field(factory=list)\n\"\"\"The objects of the editor.\"\"\"\n\n    @classmethod\n    def from_objects(cls: Type[E], *objects: Object, header: Header) -&gt; E:\n        return cls(header, list(objects))\n\n    @classmethod\n    def from_object_iterable(cls: Type[E], objects: Iterable[Object], header: Header) -&gt; E:\n        return cls(header, list(objects))\n\n    def __len__(self) -&gt; int:\n        return len(self.objects)\n\n    @overload\n    def __getitem__(self, index: int) -&gt; Object:\n        ...\n\n    @overload\n    def __getitem__(self: E, index: slice) -&gt; E:\n        ...\n\n    def __getitem__(self: E, index: Union[int, slice]) -&gt; Union[Object, E]:\n        if is_int(index):\n            return self.objects[index]\n\n        return self.from_object_iterable(self.objects[index], self.header)  # type: ignore\n\n    @property\n    def color_channels(self) -&gt; ColorChannels:\n        return self.header.color_channels\n\n    def set_header(self: E, header: Header) -&gt; E:\n        self.header = header\n\n        return self\n\n    def set_color_channels(self: E, color_channels: ColorChannels) -&gt; E:\n        self.header.color_channels = color_channels\n\n        return self\n\n    @wrap_iter\n    def iter_groups(self) -&gt; Iterator[int]:\n        for object in self.objects:\n            yield from object.groups\n\n            if has_target_group(object):\n                yield object.target_group_id\n\n            if has_additional_group(object):\n                yield object.additional_group_id\n\n    @property\n    def groups(self) -&gt; Set[int]:\n        return self.iter_groups().set()\n\n    @property\n    def free_group(self) -&gt; int:\n        return find_next(self.groups)\n\n    @wrap_iter\n    def iter_color_ids(self) -&gt; Iterator[int]:\n        for object in self.objects:\n            yield object.base_color_id\n            yield object.detail_color_id\n\n        yield from self.color_channels\n\n    @property\n    def color_ids(self) -&gt; Set[int]:\n        return self.iter_color_ids().set()\n\n    @property\n    def free_color_id(self) -&gt; int:\n        return find_next(self.color_ids)\n\n    @wrap_iter\n    def iter_start_positions(self) -&gt; Iterator[StartPosition]:\n        return filter(is_start_position, self.objects)\n\n    @property\n    def start_position(self) -&gt; List[StartPosition]:\n        return self.iter_start_positions().sorted_by(get_x)\n\n    @wrap_iter\n    def iter_portals(self) -&gt; Iterator[Object]:\n        return (object for object in self.objects if object.is_portal())\n\n    @property\n    def portals(self) -&gt; List[Object]:\n        return self.iter_portals().sorted_by(get_x)\n\n    @wrap_iter\n    def iter_speed_changes(self) -&gt; Iterator[Object]:\n        return (object for object in self.objects if object.is_speed_change())\n\n    @property\n    def speed_changes(self) -&gt; List[Object]:\n        return self.iter_speed_changes().sorted_by(get_x)\n\n    @wrap_iter\n    def iter_triggers(self) -&gt; Iterator[Trigger]:\n        return filter(is_trigger, self.objects)\n\n    @property\n    def triggers(self) -&gt; List[Trigger]:\n        return self.iter_triggers().sorted_by(get_x)\n\n    @property\n    def x_length(self) -&gt; float:\n        return iter(self.objects).map(get_x).max().unwrap_or(DEFAULT_X)\n\n    @property\n    def start_speed(self) -&gt; Speed:\n        return self.header.speed\n\n    @property\n    def length(self) -&gt; float:\n        return time_length(self.x_length, self.start_speed, self.speed_changes)\n\n    @classmethod\n    def from_binary(\n        cls: Type[E],\n        binary: BinaryReader,\n        order: ByteOrder = ByteOrder.DEFAULT,\n        version: int = VERSION,\n    ) -&gt; E:\n        header = Header.from_binary(binary, order, version)\n\n        reader = Reader(binary, order)\n\n        iterable_length = reader.read_u32()\n\n        object_from_binary_function = partial(object_from_binary, binary, order, version)\n\n        iterable = iter.repeat_exactly_with(object_from_binary_function, iterable_length).unwrap()\n\n        return cls.from_object_iterable(iterable, header)\n\n    def to_binary(\n        self, binary: BinaryWriter, order: ByteOrder = ByteOrder.DEFAULT, version: int = VERSION\n    ) -&gt; None:\n        self.header.to_binary(binary, order, version)\n\n        writer = Writer(binary, order)\n\n        objects = self.objects\n\n        writer.write_u32(len(objects))\n\n        for object in objects:\n            object_to_binary(object, binary, order, version)\n\n    @classmethod\n    def from_robtop(cls: Type[E], string: str) -&gt; E:\n        iterator = iter(split_objects(string)).filter(None)\n\n        header_option = iterator.next().extract()\n\n        if header_option is None:\n            header = Header()\n\n        else:\n            header = Header.from_robtop(header_option)\n\n        objects = iterator.map(object_from_robtop).list()\n\n        return cls(header, objects)\n\n    def to_robtop(self) -&gt; str:\n        return (\n            iter(self.objects)\n            .map(object_to_robtop)\n            .prepend(self.header.to_robtop())\n            .collect(concat_objects)\n        )\n\n    @classmethod\n    def can_be_in(cls, string: str) -&gt; bool:\n        return OBJECTS_SEPARATOR in string\n</code></pre>"},{"location":"reference/api/editor/#gd.api.editor.Editor.header","title":"<code>header: Header = field(factory=Header)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The header of the editor.</p>"},{"location":"reference/api/editor/#gd.api.editor.Editor.objects","title":"<code>objects: List[Object] = field(factory=list)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The objects of the editor.</p>"},{"location":"reference/api/editor/#gd.api.editor.time_length","title":"<code>time_length(distance: float, start_speed: Speed = Speed.NORMAL, speed_changes: Iterable[Object] = ()) -&gt; float</code>","text":"<p>Computes the time (in seconds) to travel from <code>0</code> to <code>distance</code>, respecting speed portals.</p> <p>Parameters:</p> Name Type Description Default <code>distance</code> <code>float</code> <p>The distance to stop calculating at.</p> required <code>start_speed</code> <code>Speed</code> <p>The starting speed (found in the header).</p> <code>Speed.NORMAL</code> <code>speed_changes</code> <code>Iterable[Object]</code> <p>Speed changes in the level, ordered by <code>x</code> position.</p> <code>()</code> <p>Returns:</p> Type Description <code>float</code> <p>The calculated time (in seconds).</p> Source code in <code>gd/api/editor.py</code> <pre><code>def time_length(\n    distance: float,\n    start_speed: Speed = Speed.NORMAL,\n    speed_changes: Iterable[Object] = (),\n) -&gt; float:\n\"\"\"Computes the time (in seconds) to travel from `0` to `distance`, respecting speed portals.\n\n    Parameters:\n        distance: The distance to stop calculating at.\n        start_speed: The starting speed (found in the header).\n        speed_changes: Speed changes in the level, ordered by `x` position.\n\n    Returns:\n        The calculated time (in seconds).\n    \"\"\"\n    magic = SPEED_TO_MAGIC[start_speed]\n\n    if not speed_changes:\n        return distance / magic\n\n    last_x = 0.0\n    total = 0.0\n\n    for speed_change in speed_changes:\n        x = speed_change.x\n\n        if x &gt; distance:\n            break\n\n        delta = x - last_x\n\n        total += delta / magic\n\n        magic = SPEED_CHANGE_TO_MAGIC[SpeedChangeType(speed_change.id)]\n\n        last_x = x\n\n    delta = distance - last_x\n\n    total += delta / magic\n\n    return total\n</code></pre>"},{"location":"reference/api/folder/","title":"Folder","text":""},{"location":"reference/api/folder/#gd.api.folder.Folder","title":"<code>Folder</code>","text":"<p>         Bases: <code>Binary</code></p> <p>Represents level folders.</p> Binary <pre><code>struct Folder {\nid: u8,\nname_length: u8,\nname: [u8; name_length],  // utf-8 string\n}\n</code></pre> Source code in <code>gd/api/folder.py</code> <pre><code>@define()\nclass Folder(Binary):\n\"\"\"Represents level folders.\n\n    Binary:\n        ```rust\n        struct Folder {\n            id: u8,\n            name_length: u8,\n            name: [u8; name_length],  // utf-8 string\n        }\n        ```\n    \"\"\"\n\n    id: int\n\"\"\"The ID of the folder.\"\"\"\n    name: str\n\"\"\"The name of the folder.\"\"\"\n\n    def __hash__(self) -&gt; int:\n        return self.id\n\n    @classmethod\n    def from_binary(\n        cls: Type[F],\n        binary: BinaryReader,\n        order: ByteOrder = ByteOrder.DEFAULT,\n        version: int = VERSION,\n        encoding: str = DEFAULT_ENCODING,\n        errors: str = DEFAULT_ERRORS,\n    ) -&gt; F:\n        reader = Reader(binary, order)\n\n        id = reader.read_u8()\n\n        name_length = reader.read_u8()\n\n        name = reader.read(name_length).decode(encoding, errors)\n\n        return cls(id, name)\n\n    def to_binary(\n        self,\n        binary: BinaryWriter,\n        order: ByteOrder = ByteOrder.DEFAULT,\n        version: int = VERSION,\n        encoding: str = DEFAULT_ENCODING,\n        errors: str = DEFAULT_ERRORS,\n    ) -&gt; None:\n        writer = Writer(binary, order)\n\n        writer.write_u8(self.id)\n\n        data = self.name.encode(encoding, errors)\n\n        writer.write_u8(len(data))\n\n        writer.write(data)\n</code></pre>"},{"location":"reference/api/folder/#gd.api.folder.Folder.id","title":"<code>id: int</code>  <code>instance-attribute</code>","text":"<p>The ID of the folder.</p>"},{"location":"reference/api/folder/#gd.api.folder.Folder.name","title":"<code>name: str</code>  <code>instance-attribute</code>","text":"<p>The name of the folder.</p>"},{"location":"reference/api/guidelines/","title":"Guidelines","text":""},{"location":"reference/api/guidelines/#gd.api.guidelines.Guidelines","title":"<code>Guidelines</code>","text":"<p>         Bases: <code>RobTop</code>, <code>Binary</code>, <code>Dict[float, GuidelineColor]</code></p> <p>Represents guidelines.</p> Binary <pre><code>struct Guideline {\ntimestamp: f32,\ncolor: f32,\n}\n\nstruct Guidelines {\nguidelines_length: u32,\nguidelines: [Guideline; guidelines_length],\n}\n</code></pre> Source code in <code>gd/api/guidelines.py</code> <pre><code>class Guidelines(RobTop, Binary, Dict[float, GuidelineColor]):\n\"\"\"Represents guidelines.\n\n    Binary:\n        ```rust\n        struct Guideline {\n            timestamp: f32,\n            color: f32,\n        }\n\n        struct Guidelines {\n            guidelines_length: u32,\n            guidelines: [Guideline; guidelines_length],\n        }\n        ```\n    \"\"\"\n\n    def add(self, timestamp: float, color: GuidelineColor = GuidelineColor.DEFAULT) -&gt; None:\n\"\"\"Adds the guideline described by `timestamp` and `color`.\n\n        Arguments:\n            timestamp: The timestamp of the guideline.\n            color: The color of the guideline.\n\n        Example:\n            ```python\n            &gt;&gt;&gt; guidelines = Guidelines()\n            &gt;&gt;&gt; guidelines.add(1.0, GuidelineColor.GREEN)\n            &gt;&gt;&gt; guidelines\n            {1.0: &lt;GuidelineColor.GREEN: 1.0&gt;}\n            ```\n        \"\"\"\n        self[timestamp] = color\n\n    @classmethod\n    def from_binary(\n        cls: Type[G],\n        binary: BinaryReader,\n        order: ByteOrder = ByteOrder.DEFAULT,\n        version: int = VERSION,\n    ) -&gt; G:\n        reader = Reader(binary, order)\n\n        length = reader.read_u32()\n\n        color = GuidelineColor\n\n        return cls({reader.read_f32(): color(reader.read_f32()) for _ in range(length)})\n\n    def to_binary(\n        self, binary: BinaryWriter, order: ByteOrder = ByteOrder.DEFAULT, version: int = VERSION\n    ) -&gt; None:\n        writer = Writer(binary, order)\n\n        writer.write_u32(len(self))\n\n        for timestamp, color in self.items():\n            writer.write_f32(timestamp)\n            writer.write_f32(color.value)\n\n    @classmethod\n    def from_robtop(cls: Type[G], string: str) -&gt; G:\n        color = GuidelineColor\n\n        return cls(\n            {timestamp: color(value) for timestamp, value in split_guidelines(string).items()}\n        )\n\n    def to_robtop(self) -&gt; str:\n        return concat_guidelines({timestamp: color.value for timestamp, color in self.items()})\n\n    @classmethod\n    def can_be_in(cls, string: str) -&gt; bool:\n        return GUIDELINES_SEPARATOR in string\n</code></pre>"},{"location":"reference/api/guidelines/#gd.api.guidelines.Guidelines.add","title":"<code>add(timestamp: float, color: GuidelineColor = GuidelineColor.DEFAULT) -&gt; None</code>","text":"<p>Adds the guideline described by <code>timestamp</code> and <code>color</code>.</p> <p>Parameters:</p> Name Type Description Default <code>timestamp</code> <code>float</code> <p>The timestamp of the guideline.</p> required <code>color</code> <code>GuidelineColor</code> <p>The color of the guideline.</p> <code>GuidelineColor.DEFAULT</code> Example <pre><code>&gt;&gt;&gt; guidelines = Guidelines()\n&gt;&gt;&gt; guidelines.add(1.0, GuidelineColor.GREEN)\n&gt;&gt;&gt; guidelines\n{1.0: &lt;GuidelineColor.GREEN: 1.0&gt;}\n</code></pre> Source code in <code>gd/api/guidelines.py</code> <pre><code>def add(self, timestamp: float, color: GuidelineColor = GuidelineColor.DEFAULT) -&gt; None:\n\"\"\"Adds the guideline described by `timestamp` and `color`.\n\n    Arguments:\n        timestamp: The timestamp of the guideline.\n        color: The color of the guideline.\n\n    Example:\n        ```python\n        &gt;&gt;&gt; guidelines = Guidelines()\n        &gt;&gt;&gt; guidelines.add(1.0, GuidelineColor.GREEN)\n        &gt;&gt;&gt; guidelines\n        {1.0: &lt;GuidelineColor.GREEN: 1.0&gt;}\n        ```\n    \"\"\"\n    self[timestamp] = color\n</code></pre>"},{"location":"reference/memory/internal/","title":"Internal","text":"<p>Internal memory interfaces for different platforms.</p>"},{"location":"reference/memory/internal/#gd.memory.internal--functions","title":"Functions","text":"<ul> <li><code>open</code></li> <li><code>close</code></li> <li><code>terminate</code></li> <li><code>allocate</code></li> <li><code>free</code></li> <li><code>protect</code></li> <li><code>read</code></li> <li><code>write</code></li> <li><code>get_base_address</code></li> <li><code>get_base_address_from_handle</code>?</li> <li><code>get_process_bits</code></li> <li><code>get_process_bits_from_handle</code>?</li> <li><code>get_process_id_from_name</code></li> <li><code>get_process_id_from_title</code>?</li> </ul> <p>Functions marked with <code>?</code> are not required for the library to work.</p>"}]}