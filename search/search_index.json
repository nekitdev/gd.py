{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"<code>gd.py</code>","text":"<p>An API wrapper for Geometry Dash written in Python.</p>"},{"location":"#installing","title":"Installing","text":"<p>Python 3.7 or above is required.</p>"},{"location":"#pip","title":"pip","text":"<p>Installing the library with <code>pip</code> is quite simple:</p> <pre><code>$ pip install gd.py\n</code></pre> <p>Alternatively, the library can be installed from source:</p> <pre><code>$ git clone https://github.com/nekitdev/gd.py.git\n$ cd gd.py\n$ python -m pip install .\n</code></pre>"},{"location":"#poetry","title":"poetry","text":"<p>You can add <code>gd.py</code> as a dependency with the following command:</p> <pre><code>$ poetry add gd.py\n</code></pre> <p>Or by directly specifying it in the configuration like so:</p> <pre><code>[tool.poetry.dependencies]\n\"gd.py\" = \"^1.0.0\"\n</code></pre> <p>Alternatively, you can add it directly from the source:</p> <pre><code>[tool.poetry.dependencies.\"gd.py\"]\ngit = \"https://github.com/nekitdev/gd.py.git\"\n</code></pre>"},{"location":"#examples","title":"Examples","text":""},{"location":"#fetching","title":"Fetching","text":"<pre><code># file.py\n\nimport asyncio\n\nimport gd\n\nSONG_ID = 1081309\nSONG = \"{} by {} (ID: {}, size: {} MB)\"\n\n\nasync def main() -&gt; None:\n    client = gd.Client()\n\n    song = await client.get_song(SONG_ID)\n\n    print(SONG.format(song.name, song.artist.name, song.id, song.size))\n\n\nasyncio.run(main())\n</code></pre> <pre><code>$ python file.py\nPANDA EYES - BROKEN by PandaEyesOfficial (ID: 1081309, size: 9.71 MB)\n</code></pre>"},{"location":"#listening","title":"Listening","text":"<pre><code>import gd\n\nclient = gd.Client()\n\nDAILY = \"new daily! {daily.name} by {daily.creator.name} (ID: {daily.id})\"\n\n\n@client.event\nasync def on_daily(daily: gd.Level) -&gt; None:\n    print(DAILY.format(daily=daily))\n\n\nclient.listen_for_daily()\n\nclient.create_controller().run()\n</code></pre>"},{"location":"#documentation","title":"Documentation","text":"<p>You can find the documentation here.</p>"},{"location":"#support","title":"Support","text":"<p>If you need support with the library, you can send an email or refer to the official Discord server.</p>"},{"location":"#changelog","title":"Changelog","text":"<p>You can find the changelog here.</p>"},{"location":"#security-policy","title":"Security Policy","text":"<p>You can find the Security Policy of <code>gd.py</code> here.</p>"},{"location":"#contributing","title":"Contributing","text":"<p>If you are interested in contributing to <code>gd.py</code>, make sure to take a look at the Contributing Guide, as well as the Code of Conduct.</p>"},{"location":"#license","title":"License","text":"<p><code>gd.py</code> is licensed under the MIT License terms. See License for details.</p>"},{"location":"changelog/","title":"Changelog","text":""},{"location":"code_of_conduct/","title":"Code of Conduct","text":""},{"location":"code_of_conduct/#our-pledge","title":"Our Pledge","text":"<p>We as members, contributors, and leaders pledge to make participation in our community a harassment-free experience for everyone, regardless of age, body size, visible or invisible disability, ethnicity, sex characteristics, gender identity and expression, level of experience, education, socio-economic status, nationality, personal appearance, race, caste, color, religion, or sexual identity and orientation.</p> <p>We pledge to act and interact in ways that contribute to an open, welcoming, diverse, inclusive, and healthy community.</p>"},{"location":"code_of_conduct/#our-standards","title":"Our Standards","text":"<p>Examples of behavior that contributes to a positive environment for our community include:</p> <ul> <li>Demonstrating empathy and kindness toward other people</li> <li>Being respectful of differing opinions, viewpoints, and experiences</li> <li>Giving and gracefully accepting constructive feedback</li> <li>Accepting responsibility and apologizing to those affected by our mistakes,   and learning from the experience</li> <li>Focusing on what is best not just for us as individuals, but for the overall   community</li> </ul> <p>Examples of unacceptable behavior include:</p> <ul> <li>The use of sexualized language or imagery, and sexual attention or advances of   any kind</li> <li>Trolling, insulting or derogatory comments, and personal or political attacks</li> <li>Public or private harassment</li> <li>Publishing others' private information, such as a physical or email address,   without their explicit permission</li> <li>Other conduct which could reasonably be considered inappropriate in a   professional setting</li> </ul>"},{"location":"code_of_conduct/#enforcement-responsibilities","title":"Enforcement Responsibilities","text":"<p>Community leaders are responsible for clarifying and enforcing our standards of acceptable behavior and will take appropriate and fair corrective action in response to any behavior that they deem inappropriate, threatening, offensive, or harmful.</p> <p>Community leaders have the right and responsibility to remove, edit, or reject comments, commits, code, wiki edits, issues, and other contributions that are not aligned to this Code of Conduct, and will communicate reasons for moderation decisions when appropriate.</p>"},{"location":"code_of_conduct/#scope","title":"Scope","text":"<p>This Code of Conduct applies within all community spaces, and also applies when an individual is officially representing the community in public spaces. Examples of representing our community include using an official email address, posting via an official social media account, or acting as an appointed representative at an online or offline event.</p>"},{"location":"code_of_conduct/#enforcement","title":"Enforcement","text":"<p>Instances of abusive, harassing, or otherwise unacceptable behavior may be reported to the community leaders responsible for enforcement to conduct@nekit.dev.</p> <p>All complaints will be reviewed and investigated promptly and fairly.</p> <p>All community leaders are obligated to respect the privacy and security of the reporter of any incident.</p>"},{"location":"code_of_conduct/#enforcement-guidelines","title":"Enforcement Guidelines","text":"<p>Community leaders will follow these Community Impact Guidelines in determining the consequences for any action they deem in violation of this Code of Conduct:</p>"},{"location":"code_of_conduct/#1-correction","title":"1. Correction","text":"<p>Community Impact: Use of inappropriate language or other behavior deemed unprofessional or unwelcome in the community.</p> <p>Consequence: A private, written warning from community leaders, providing clarity around the nature of the violation and an explanation of why the behavior was inappropriate. A public apology may be requested.</p>"},{"location":"code_of_conduct/#2-warning","title":"2. Warning","text":"<p>Community Impact: A violation through a single incident or series of actions.</p> <p>Consequence: A warning with consequences for continued behavior. No interaction with the people involved, including unsolicited interaction with those enforcing the Code of Conduct, for a specified period of time. This includes avoiding interactions in community spaces as well as external channels like social media. Violating these terms may lead to a temporary or permanent ban.</p>"},{"location":"code_of_conduct/#3-temporary-ban","title":"3. Temporary Ban","text":"<p>Community Impact: A serious violation of community standards, including sustained inappropriate behavior.</p> <p>Consequence: A temporary ban from any sort of interaction or public communication with the community for a specified period of time. No public or private interaction with the people involved, including unsolicited interaction with those enforcing the Code of Conduct, is allowed during this period. Violating these terms may lead to a permanent ban.</p>"},{"location":"code_of_conduct/#4-permanent-ban","title":"4. Permanent Ban","text":"<p>Community Impact: Demonstrating a pattern of violation of community standards, including sustained inappropriate behavior, harassment of an individual, or aggression toward or disparagement of classes of individuals.</p> <p>Consequence: A permanent ban from any sort of public interaction within the community.</p>"},{"location":"code_of_conduct/#attribution","title":"Attribution","text":"<p>This Code of Conduct is adapted from the Contributor Covenant, version 2.1, available at https://contributor-covenant.org/version/2/1/code_of_conduct.</p> <p>Community Impact Guidelines were inspired by Mozilla's Code of Conduct enforcement ladder.</p> <p>For answers to common questions about this code of conduct, see the FAQ at https://contributor-covenant.org/faq. Translations are available at https://contributor-covenant.org/translations.</p>"},{"location":"security/","title":"Security Policy","text":""},{"location":"security/#reporting","title":"Reporting","text":"<p>Thank you for taking the time to responsibly disclose any problems you find.</p> <p>Do not file public issues as they are open for everyone to see!</p> <p>All security vulnerabilities in <code>gd.py</code> should be reported by email to security@nekit.dev. Your report will be acknowledged within 24 hours, and you will receive a more detailed response within 48 hours indicating the next steps in handling your report.</p> <p>You can encrypt your report using our public key: <code>BB2D8194464001E0B9B60EB8741A1EAD20FFDE8A</code>. This key is also available on MIT's Key Server and reproduced below.</p> <p>After the initial reply to your report, the core team will try to keep you informed of the progress being made towards a fix and official announcement. These updates will be sent at least every five days. In reality, this is more likely to be every 24-48 hours.</p>"},{"location":"security/#disclosure-policy","title":"Disclosure Policy","text":"<p><code>gd.py</code> has a 5-step disclosure process:</p> <ol> <li> <p>The security report is received and is assigned a primary handler.    This person will coordinate the fix and release process.</p> </li> <li> <p>The problem is confirmed and a list of all affected versions is determined.</p> </li> <li> <p>Code is audited to find any potential similar problems.</p> </li> <li> <p>Fixes are prepared for all releases which are still under maintenance.    These fixes are not committed to the public repository but rather    held locally pending the announcement.</p> </li> <li> <p>On the embargo date, the changes are pushed to the public repository    and new builds are deployed.</p> </li> </ol> <p>This process can take some time, especially when coordination is required with maintainers of other projects. Every effort will be made to handle the issue in as timely a manner as possible, however it is important that we follow the release process above to ensure that the disclosure is handled in a consistent manner.</p>"},{"location":"security/#security-key","title":"Security Key","text":"<pre><code>-----BEGIN PGP PUBLIC KEY BLOCK-----\n\nmQINBGKJEuEBEAC37iPX5u8sN+DZQ8c4Of+85u/hboSqNLp7VtTGgr/d8RCFhGZk\n25ZwqGWeJbhnlPuzT6u96CZFRe3TMHYJR+A2NZBVjAQQjDRGbIGgaS6/9lvMLcRx\nD+hFQNPgwUTfPhSHIan+9EuYK/Bz+jyyIplwTrIBq1Mo0NG+cUNvAB+he22xhBQ7\ny/Xal+sapHfYedqywhYEQUgP94IGURIMiBlAB7nKW+qs7YiQBShBbfxxffMgK6W6\nsNNSybUQDqjj1AWkOBj5uizkA6FLF80xULypbhe1gbqsIt4d1Lj/mxI5zvj84wy5\noQ6QOpYlBUQwl8kqfszYaqKCviflA+riAFMAE8NVL+5BuVN0QSvQb6cRzIV1SL0p\nMCA6s2+plK/9K+JyR5yyjY7FxvatYNLW5LsubmS+YeBdO4l4A7YEElOGMexUb61H\n3ejlb/9UUrZ7hd09Hsi1J6nthrI26o0XBdB8UJ9QAdfoHWka3fgSgopBBcI+S3tU\niWGngFrUhiXcBS+0xHjrk4USKwFyFr8fmL4Y8Yu31ViHRFj6gVjC/PHP0apCnakB\nUEEMHnAQfztodH9o2ew2kew77+q9VblDGpb3BYaiptl4c6h6WBcEULpRfWERfB8H\nSt4L49Ob6CCNpVw9qgsDfNw2fFjUIsT6OGwJxhv9StIFW2JEhgxEvfHr1wARAQAB\ntC9OaWtpdGEgVGlraG9ub3YgKHNlY3VyaXR5KSA8c2VjdXJpdHlAbmVraXQuZGV2\nPokCUgQTAQgAPAIbAwIXgAIeBxYhBLstgZRGQAHgubYOuHQaHq0g/96KBQJiiR6G\nBQsJCAcCAyICAQYVCgkICwIEFgIDAQAKCRB0Gh6tIP/einfmD/9y69eqwjRfdmnW\ns0ph8Rh99JHtgA+zm1akRl+eymiqLuJwmZge7PPFb68Wj4lI6s1M1dIkyRuYMtIM\n3rEcMmGUlcVnPldx/wdcPyhYZDUXnYCK64dsloftrWFWoSr5a/AILyVh/L6Fkf+L\nRU9h3KPMXhLTyK127ZF5WuzpjSJms0hDMDV/idfiDeWn/VGaZz1Wiks4l8R9kisR\nLI3RKNR537f0KFS8jkqlI41Lj9XQTUdqMRp+eqi/zUMM7OZzKQg1ohDsLi4MR6wa\nbXIu7LeAp1M0XlB+MO09KOxR8i19ST89EapAp4gHprbG5hJyV3XHK4txcWHG0YjB\ng5/fOvytljf/ue5YGe5nQUcxucq6i4d6jsB66Gk/4nnKutlMG2ZtVyIZZZActPZ5\nqKI64HQJOpag+ERXwrv0optEhTC7RHOFRuZ4pCKuVjdJE9W7ZpAIAi8yHeVvpgJY\nglo+DqZH1/kLD1u2Jb/8yUuMeCYc3aBlfZswO6IeMFeXbPaMtIHzY5q7blIdKIAb\nYxS5KCYn8VHG6Nz8lFMu2z4jpH4QY9vTaxZnG3Xp23uxbP0pznih4DMiHIACyCBP\nWgRReZTCVU6Z9FvBq8t/hcrwli33lTa5hkuuzqcojn80+1g9st7DOzxVFtR2MoSS\nWkv8ss8apRyeLNZAM5M8v+AiiyVCrLkCDQRiiRLhARAApEJFgvQVDMYpuo754cRK\nWC/17DH1BQ9y78h/0MXmOOf/0MpzJBkPjn4++BdXQGoOCBleHrWmbtmfYLcQFmZ/\neiUzxFDS/pkC7aZUb+YA7JzcwZQP2yOhlMfFK0qCoQKw/45q+AkOUR+Z+VGExkM1\n5+PAcQ+7cQRiyina6/MG7FHAOcvuEwjiyt/0zBm3izeWmXL0Gngisl1jvd8bGn4T\nbK68q2d09NNHdXJ9UDFdGJ+FVIqJCyLyBl0ZfWazSkD/4ZNchdjFcSOzTTMvqWWn\n6i5awbVyMPZkKS88vRVwTtcjk4+hrzaIyNbTw7y55qQxFe0NEoj4SK+iMwCkax19\nnjGQeB8GqmieC+0WYUSt10xXZ6tDf6a9F2cg6zv1ZklOuYU9x8GYwU7zvhrGhvXU\nUn1ZtP/OaHoQsS/+AS7KJtm/NWHGsfjd8vwDirIoZ31D7X52QrN07NQ0H7+uqtDL\nc7BAhsLI1G/r9Kz0+P0nC/6bMWvQWiomB1BSwUTfXLkT0RoKZ3Yub8XMk46N9XKE\nRtTk5x0/rZ40uOg8wzT1GvwYFA4tpavAqLejOftE05lKXAb5tQhYRupZywzXM6HN\nDR7CbP1e26g0p8GAuz1aFny6cN8T3wTHHyYn7aQk7i1BboV8zFpVlF6EmoHNCZtG\nhkl28kYa0Yvu+9mw0SPNiIsAEQEAAYkCNgQYAQgAIBYhBLstgZRGQAHgubYOuHQa\nHq0g/96KBQJiiRLhAhsMAAoJEHQaHq0g/96KeCoP/3i3A629wvjPn7m3y7pTcV8p\nriTlH5OeXhg4jCORgJrgL4PSoeFCITA0u0djtcvctmCrHMsZe0hyH5+X+/B9Bsf6\neFQKWXLidqkxD/M6lnE6t34d17DvaWCP27MsS/f0u0FsLom11TTFgp4wGKZfRBNH\nvX5xuhjoYXYwZwWqCYyEXFTbsUTDce2oaqc7Yw/GmM3fCodLX0/0eYh5u2fiKA57\n7VuUWD74/TkgcEOMa/IZ/jPmJHuHOteaIJR0pYUvLQ1EJh3jI4LhmH8DqxoUrmKy\n8z2VM0iLIiev86EXM+yzqTpRIFnm6Ts+47L18rb9D5IUo68gr5B2bMKPOfvMVzdN\n/vw2RKdCVJ70nh3qqRis5RsJrn/3T8H1CQtuPvsAd/oB86YGWPpWBtpTyI+VBp+x\n+XR434K8D9QXFst73wTCnQwSX6j0sIotQC5GsPJEKky2Wijg3BlxqTxtYjLhwKWg\nx3e63TEw7IgU+lE/ybzWLJ7EndbKsC7stZh+Lyh5b3YHgI3cfJUxjZNFpniKr/Fy\n4EjjLZzFf3QRmNNJ/7VlYLYztGZsOWxRsLk7QfUPSZY4iHUr8aiwfL7IFwnAlzIo\n36HDjJi80UakMlf45UcxRaJwWiaj7G4x3h1D1BZLtMiypiaw/mesrithmfHg+KYu\n1oYi7ft0FnZ67Wnk5+E+\n=VRe2\n-----END PGP PUBLIC KEY BLOCK-----\n</code></pre>"},{"location":"security/#attribution","title":"Attribution","text":"<p>This Security Policy is adapted from Rust's Security Policy.</p>"},{"location":"reference/artist/","title":"Artist","text":""},{"location":"reference/artist/#gd.artist.Artist","title":"<code>Artist</code>","text":"<p>         Bases: <code>Entity</code></p> <p>Represents artists on Newgrounds.</p> Binary <pre><code>const VERIFIED_BIT: u8 = 1 &lt;&lt; 0;\nconst HAS_ID_BIT: u8 = 1 &lt;&lt; 1;\n\nstruct Artist {\nvalue: u8,  // contains `verified` and `has_id`\nid: Option&lt;u32&gt;,  // if `has_id`\nname_length: u8,\nname: [u8; name_length],  // utf-8 string\n}\n</code></pre> Source code in <code>gd/artist.py</code> <pre><code>@register_unstructure_hook_omit_client\n@define()\nclass Artist(Entity):\n\"\"\"Represents artists on *Newgrounds*.\n\n    Binary:\n        ```rust\n        const VERIFIED_BIT: u8 = 1 &lt;&lt; 0;\n        const HAS_ID_BIT: u8 = 1 &lt;&lt; 1;\n\n        struct Artist {\n            value: u8,  // contains `verified` and `has_id`\n            id: Option&lt;u32&gt;,  // if `has_id`\n            name_length: u8,\n            name: [u8; name_length],  // utf-8 string\n        }\n        ```\n    \"\"\"\n\n    name: str = field(eq=False)\n    verified: bool = field(default=DEFAULT_ARTIST_VERIFIED, eq=False)\n\n    @property\n    def url(self) -&gt; URL:\n        return URL(artist_url(self.id_name))\n\n    @property\n    def id_name(self) -&gt; str:\n        return clear_whitespace(case_fold(self.name))\n\n    @classmethod\n    def default(cls: Type[A], id: int = DEFAULT_ID) -&gt; A:\n        return cls(id=id, name=EMPTY)\n\n    @classmethod\n    def name_only(cls: Type[A], name: str) -&gt; A:\n        return cls(id=DEFAULT_ID, name=name)\n\n    def __hash__(self) -&gt; int:\n        return hash(type(self)) ^ hash(self.id_name)\n\n    def __str__(self) -&gt; str:\n        return self.name or UNKNOWN\n\n    @classmethod\n    def from_model(cls: Type[A], model: ArtistModel, id: int = DEFAULT_ID) -&gt; A:\n        return cls(id=id, name=model.name)\n\n    @classmethod\n    def from_data(cls: Type[A], data: ArtistData) -&gt; A:  # type: ignore\n        return CONVERTER.structure(data, cls)\n\n    def into_data(self) -&gt; ArtistData:\n        return CONVERTER.unstructure(self)  # type: ignore\n\n    @classmethod\n    def from_binary(\n        cls: Type[A],\n        binary: BinaryReader,\n        order: ByteOrder = ByteOrder.DEFAULT,\n        version: int = VERSION,\n        encoding: str = DEFAULT_ENCODING,\n        errors: str = DEFAULT_ERRORS,\n    ) -&gt; A:\n        reader = Reader(binary, order)\n\n        artist_flag_value = reader.read_u8()\n\n        artist_flag = ArtistFlag(artist_flag_value)\n\n        if artist_flag.has_id():\n            id = reader.read_u32()\n\n        else:\n            id = DEFAULT_ID\n\n        name_length = reader.read_u8()\n\n        data = reader.read(name_length)\n\n        name = data.decode(encoding, errors)\n\n        verified = artist_flag.is_verified()\n\n        return cls(id=id, name=name, verified=verified)\n\n    def to_binary(\n        self,\n        binary: BinaryWriter,\n        order: ByteOrder = ByteOrder.DEFAULT,\n        version: int = VERSION,\n        encoding: str = DEFAULT_ENCODING,\n        errors: str = DEFAULT_ERRORS,\n    ) -&gt; None:\n        writer = Writer(binary, order)\n\n        artist_flag = ArtistFlag.SIMPLE\n\n        if self.is_verified():\n            artist_flag |= ArtistFlag.VERIFIED\n\n        id = self.id\n\n        if id:\n            artist_flag |= ArtistFlag.ID\n\n        writer.write_u8(artist_flag.value)\n\n        if id:\n            writer.write_u32(id)\n\n        data = self.name.encode(encoding, errors)\n\n        writer.write_u8(len(data))\n\n        writer.write(data)\n\n    def is_verified(self) -&gt; bool:\n        return self.verified\n\n    @wrap_async_iter\n    def get_songs_on_page(self, page: int = DEFAULT_PAGE) -&gt; AsyncIterator[Song]:\n        return self.client.get_newgrounds_artist_songs_on_page(self, page=page).unwrap()\n\n    @wrap_async_iter\n    def get_songs(self, pages: Iterable[int] = DEFAULT_PAGES) -&gt; AsyncIterator[Song]:\n        return self.client.get_newgrounds_artist_songs(self, pages=pages).unwrap()\n</code></pre>"},{"location":"reference/client/","title":"Client","text":""},{"location":"reference/client/#gd.client.Client","title":"<code>Client</code>","text":"Source code in <code>gd/client.py</code> <pre><code>@define(slots=False)\nclass Client:\n    session: Session = field(factory=Session)\n\"\"\"The session of the client.\"\"\"\n\n    credentials: Credentials = field(factory=Credentials)\n\"\"\"The credentials of the client.\"\"\"\n\n    database_unchecked: Optional[Database] = field(default=None, repr=False)\n\"\"\"The database of the client.\"\"\"\n\n    load_after_post: bool = field(default=DEFAULT_LOAD_AFTER_POST)\n\"\"\"Whether to load items after posting them.\"\"\"\n\n    _listeners: DynamicTuple[Listener] = field(default=(), repr=False, init=False)\n    _controller: Optional[Controller] = field(default=None, repr=False, init=False)\n\n    def apply_items(\n        self: C,\n        credentials: Optional[Credentials] = None,\n        database: Optional[Database] = None,\n        credentials_type: Type[Credentials] = Credentials,\n    ) -&gt; C:\n        if credentials is None:\n            self.credentials = credentials_type()\n\n        else:\n            self.credentials = credentials\n\n        self.database_unchecked = database\n\n        return self\n\n    @property\n    def database(self) -&gt; Database:\n        database = self.database_unchecked\n\n        if database is None:\n            raise ValueError(NO_DATABASE)\n\n        return database\n\n    @database.setter\n    def database(self, database: Database) -&gt; None:\n        self.database_unchecked = database\n\n    @database.deleter\n    def database(self) -&gt; None:\n        self.database_unchecked = None\n\n    def reset_items(self: C) -&gt; C:\n        return self.apply_items()\n\n    def is_logged_in(self) -&gt; bool:\n\"\"\"Checks if the client is logged in.\n\n        Returns:\n            Whether the client is logged in.\n        \"\"\"\n        return self.credentials.is_loaded()\n\n    def run(self, awaitable: Awaitable[T]) -&gt; T:\n        return run(awaiting(awaitable))\n\n    @property\n    def account_id(self) -&gt; int:\n\"\"\"The account ID of the client.\"\"\"\n        return self.credentials.account_id\n\n    @property\n    def id(self) -&gt; int:\n\"\"\"The user ID of the client.\"\"\"\n        return self.credentials.id\n\n    @property\n    def name(self) -&gt; str:\n\"\"\"The name of the client.\"\"\"\n        return self.credentials.name\n\n    @property\n    def password(self) -&gt; str:\n\"\"\"The password of the client.\"\"\"\n        return self.credentials.password\n\n    @property\n    def http(self) -&gt; HTTPClient:\n\"\"\"The [`HTTPClient`][gd.http.HTTPClient] used by the client session.\"\"\"\n        return self.session.http\n\n    @property\n    def encoded_password(self) -&gt; str:\n\"\"\"The encoded password of the client.\"\"\"\n        return encode_robtop_string(self.password, Key.USER_PASSWORD)\n\n    @property\n    @check_login\n    def user(self) -&gt; User:\n\"\"\"The user representing the client.\"\"\"\n        return User(id=self.id, name=self.name, account_id=self.account_id).attach_client(self)\n\n    async def ping(self) -&gt; Duration:\n\"\"\"Pings the Geometry Dash server.\n\n        Returns:\n            The [`Duration`][gd.date_time.Duration] representing the latency.\n        \"\"\"\n        return await self.ping_url(self.http.url)\n\n    async def ping_url(self, url: URLString) -&gt; Duration:\n\"\"\"Pings the given `url`.\n\n        Returns:\n            The [`Duration`][gd.date_time.Duration] representing the latency.\n        \"\"\"\n        return await self.session.ping(url)\n\n    async def logout(self) -&gt; None:\n\"\"\"Performs the logout.\"\"\"\n        self.reset_items()\n\n    def login(self: C, name: str, password: str) -&gt; LoginContextManager[C]:\n\"\"\"Performs the login.\n\n        This function returns a context manager that can be used for temporarily logging in:\n\n        ```python\n        async with client.login(name, password):\n            assert client.is_logged_in()\n\n        assert not client.is_logged_in()\n        ```\n\n        Returns:\n            The [`LoginContextManager`][gd.client.LoginContextManager] for handling login process.\n        \"\"\"\n        return LoginContextManager(self, name, password)\n\n    async def try_login(self, name: str, password: str) -&gt; None:\n        model = await self.session.login(name, password)\n\n        self.apply_items(Credentials(model.account_id, model.id, name, password))\n\n    def unsafe_login(self: C, name: str, password: str) -&gt; UnsafeLoginContextManager[C]:\n\"\"\"Performs the *unsafe* login.\n\n        *Unsafe* means that the credentials are not confirmed.\n\n        This function returns a context manager that can be used for temporarily logging in:\n\n        ```python\n        async with client.unsafe_login(name, password):\n            assert client.is_logged_in()\n\n        assert not client.is_logged_in()\n        ```\n\n        Returns:\n            The [`UnsafeLoginContextManager`][gd.client.UnsafeLoginContextManager]\n                for handling login process.\n        \"\"\"\n        return UnsafeLoginContextManager(self, name, password)\n\n    async def try_unsafe_login(self, name: str, password: str) -&gt; None:\n        user = await self.search_user(name, simple=True)\n\n        self.apply_items(Credentials(user.account_id, user.id, name, password))\n\n    @check_login\n    async def load(self) -&gt; Database:\n\"\"\"Loads the save from the cloud, saving it in the\n        [`database`][gd.client.Client.database] attribute.\n\n        Note:\n            This function requires the client to be logged in.\n\n        Returns:\n            The [`Database`][gd.api.database.Database] loaded.\n        \"\"\"\n        database = await self.session.load(\n            account_id=self.account_id, name=self.name, password=self.password\n        )\n\n        self.database = database\n\n        return database\n\n    @check_login\n    async def save(self, database: Optional[Database] = None) -&gt; None:\n\"\"\"Saves the the `database` to the cloud, optionally fetching it from the\n        [`database`][gd.client.Client.database] attribute.\n\n        Note:\n            This function requires the client to be logged in.\n        \"\"\"\n        if database is None:\n            database = self.database\n\n        await self.session.save(\n            database, account_id=self.account_id, name=self.name, password=self.password\n        )\n\n    async def get_account_url(self, account_id: int, type: AccountURLType) -&gt; URL:\n        return await self.session.get_account_url(account_id=account_id, type=type)\n\n    @check_login\n    async def update_profile(\n        self,\n        stars: Optional[int] = None,\n        diamonds: Optional[int] = None,\n        secret_coins: Optional[int] = None,\n        user_coins: Optional[int] = None,\n        demons: Optional[int] = None,\n        icon_type: Optional[IconType] = None,\n        icon_id: Optional[int] = None,\n        color_1_id: Optional[int] = None,\n        color_2_id: Optional[int] = None,\n        glow: Optional[bool] = None,\n        cube_id: Optional[int] = None,\n        ship_id: Optional[int] = None,\n        ball_id: Optional[int] = None,\n        ufo_id: Optional[int] = None,\n        wave_id: Optional[int] = None,\n        robot_id: Optional[int] = None,\n        spider_id: Optional[int] = None,\n        # swing_copter_id: Optional[int] = None,\n        explosion_id: Optional[int] = None,\n        special: int = DEFAULT_SPECIAL,\n        *,\n        set_as_user: Optional[User] = None,\n    ) -&gt; None:\n        if set_as_user is None:\n            user = await self.get_self()\n\n        else:\n            user = set_as_user\n\n        statistics = user.statistics\n        cosmetics = user.cosmetics\n\n        if statistics is None:\n            raise InternalError  # TODO: message?\n\n        if cosmetics is None:\n            raise InternalError  # TODO: message?\n\n        await self.session.update_profile(\n            stars=switch_none(stars, statistics.stars),\n            diamonds=switch_none(diamonds, statistics.diamonds),\n            secret_coins=switch_none(secret_coins, statistics.secret_coins),\n            user_coins=switch_none(user_coins, statistics.user_coins),\n            demons=switch_none(demons, statistics.demons),\n            icon_type=switch_none(icon_type, cosmetics.icon_type),\n            icon_id=switch_none(icon_id, cosmetics.icon_id),\n            color_1_id=switch_none(color_1_id, cosmetics.color_1_id),\n            color_2_id=switch_none(color_2_id, cosmetics.color_2_id),\n            glow=switch_none(glow, cosmetics.glow),\n            cube_id=switch_none(cube_id, cosmetics.cube_id),\n            ship_id=switch_none(ship_id, cosmetics.ship_id),\n            ball_id=switch_none(ball_id, cosmetics.ball_id),\n            ufo_id=switch_none(ufo_id, cosmetics.ufo_id),\n            wave_id=switch_none(wave_id, cosmetics.wave_id),\n            robot_id=switch_none(robot_id, cosmetics.robot_id),\n            spider_id=switch_none(spider_id, cosmetics.spider_id),\n            # swing_copter_id=switch_none(swing_copter_id, cosmetics.swing_copter_id),\n            explosion_id=switch_none(explosion_id, cosmetics.explosion_id),\n            special=special,\n            account_id=self.account_id,\n            name=self.name,\n            encoded_password=self.encoded_password,\n        )\n\n    @check_login\n    async def update_settings(\n        self,\n        message_state: Optional[MessageState] = None,\n        friend_request_state: Optional[FriendRequestState] = None,\n        comment_state: Optional[CommentState] = None,\n        youtube: Optional[str] = None,\n        twitter: Optional[str] = None,\n        twitch: Optional[str] = None,\n        # discord: Optional[str] = None,\n        *,\n        set_as_user: Optional[User] = None,\n    ) -&gt; None:\n        if set_as_user is None:\n            user = await self.get_self(simple=True)\n\n        else:\n            user = set_as_user\n\n        states = user.states\n        socials = user.socials\n\n        if states is None:\n            raise InternalError  # TODO: message?\n\n        if socials is None:\n            raise InternalError  # TODO: message?\n\n        await self.session.update_settings(\n            message_state=switch_none(message_state, states.message_state),\n            friend_request_state=switch_none(friend_request_state, states.friend_request_state),\n            comment_state=switch_none(comment_state, states.comment_state),\n            youtube=switch_none(youtube, socials.youtube),\n            twitter=switch_none(twitter, socials.twitter),\n            twitch=switch_none(twitch, socials.twitch),\n            # discord=switch_none(discord, socials.discord),\n            account_id=self.account_id,\n            encoded_password=self.encoded_password,\n        )\n\n    @check_login\n    async def get_self(self, simple: bool = DEFAULT_SIMPLE) -&gt; User:\n\"\"\"Gets the user representing this client.\n\n        This is a shorthand for:\n\n        ```python\n        await client.user.get(simple=simple)\n        ```\n\n        See [`User.get`][gd.user.User.get] for more information.\n\n        Note:\n            This function requires the client to be logged in.\n\n        Arguments:\n            simple: Whether to fetch simple information.\n\n        Returns:\n            The [`User`][gd.user.User] representing the client.\n        \"\"\"\n        return await self.user.get(simple=simple)\n\n    async def get_user(\n        self,\n        account_id: int,\n        simple: bool = DEFAULT_SIMPLE,\n        friend_state: bool = DEFAULT_FRIEND_STATE,\n    ) -&gt; User:\n\"\"\"Fetches the user by `account_id`.\n\n        Arguments:\n            account_id: The account ID of the user to fetch.\n            simple: Whether to fetch simple information only.\n            friend_state: Whether to fetch friend state.\n\n        Note:\n            `friend_state` requires the client to be logged in.\n\n        Returns:\n            The [`User`][gd.user.User] fetched.\n        \"\"\"\n        if friend_state:  # if we need to fetch friend state\n            check_client_login(self)\n\n            profile_model = await self.session.get_user_profile(  # request profile\n                account_id=account_id,\n                client_account_id=self.account_id,\n                encoded_password=self.encoded_password,\n            )\n\n        else:  # otherwise, simply request normally\n            profile_model = await self.session.get_user_profile(account_id=account_id)\n\n        if simple:  # if only the profile is needed, return right away\n            return User.from_profile_model(profile_model).attach_client(self)\n\n        search_model = await self.session.search_user(profile_model.id)  # search by ID\n\n        return User.from_search_user_and_profile_models(search_model, profile_model).attach_client(\n            self\n        )\n\n    async def search_user(\n        self,\n        query: IntString,\n        simple: bool = DEFAULT_SIMPLE,\n        friend_state: bool = DEFAULT_FRIEND_STATE,\n    ) -&gt; User:\n        search_user_model = await self.session.search_user(query=query)  # search using query\n\n        if simple:  # if only simple is required, return right away\n            return User.from_search_user_model(search_user_model)\n\n        if friend_state:  # if friend state is requested\n            check_client_login(self)  # assert client is logged in\n\n            profile_model = await self.session.get_user_profile(  # request profile\n                search_user_model.account_id,\n                client_account_id=self.account_id,\n                encoded_password=self.encoded_password,\n            )\n\n        else:  # otherwise, request normally\n            profile_model = await self.session.get_user_profile(\n                account_id=search_user_model.account_id\n            )\n\n        return User.from_search_user_and_profile_models(\n            search_user_model, profile_model\n        ).attach_client(self)\n\n    @wrap_async_iter\n    async def search_users_on_page(\n        self, query: IntString, page: int = DEFAULT_PAGE\n    ) -&gt; AsyncIterator[User]:\n        search_users_response_model = await self.session.search_users_on_page(\n            query=query, page=page\n        )\n\n        for search_user_model in search_users_response_model.users:\n            yield User.from_search_user_model(search_user_model).attach_client(self)\n\n    @wrap_async_iter\n    def search_users(\n        self,\n        query: IntString,\n        pages: Iterable[int] = DEFAULT_PAGES,\n    ) -&gt; AsyncIterator[User]:\n        return run_iterables(\n            (self.search_users_on_page(query=query, page=page).unwrap() for page in pages),\n            ClientError,\n        )\n\n    @wrap_async_iter\n    @check_login\n    async def get_relationships(self, type: RelationshipType) -&gt; AsyncIterator[User]:\n        try:\n            response_model = await self.session.get_relationships(\n                type=type,\n                account_id=self.account_id,\n                encoded_password=self.encoded_password,\n            )\n\n        except NothingFound:\n            return\n\n        for model in response_model.users:\n            yield User.from_relationship_user_model(model).attach_client(self)\n\n    @wrap_async_iter\n    @check_login\n    def get_friends(self) -&gt; AsyncIterator[User]:\n        return self.get_relationships(RelationshipType.FRIEND).unwrap()\n\n    @wrap_async_iter\n    @check_login\n    def get_blocked(self) -&gt; AsyncIterator[User]:\n        return self.get_relationships(RelationshipType.BLOCKED).unwrap()\n\n    @wrap_async_iter\n    async def get_leaderboard(\n        self,\n        strategy: LeaderboardStrategy = LeaderboardStrategy.DEFAULT,\n        count: int = DEFAULT_COUNT,\n    ) -&gt; AsyncIterator[User]:\n        response_model = await self.session.get_leaderboard(\n            strategy=strategy,\n            count=count,\n            account_id=self.account_id,\n            encoded_password=self.encoded_password,\n        )\n\n        for model in response_model.users:\n            yield User.from_leaderboard_user_model(model).attach_client(self)\n\n    def level_models_from_model(\n        self, response_model: SearchLevelsResponseModel\n    ) -&gt; Iterator[Tuple[LevelModel, User, Song]]:\n        songs = (Song.from_model(model).attach_client(self) for model in response_model.songs)\n        creators = (\n            User.from_creator_model(model).attach_client(self) for model in response_model.creators\n        )\n\n        id_to_song = {song.id: song for song in songs}\n        id_to_creator = {creator.id: creator for creator in creators}\n\n        for model in response_model.levels:\n            song = id_to_song.get(model.custom_song_id)\n\n            if song is None:\n                song = Song.official(model.official_song_id).attach_client(self)\n\n            creator = id_to_creator.get(model.creator_id)\n\n            if creator is None:\n                creator = User.default().attach_client(self)\n\n            yield (model, creator, song)\n\n    async def get_daily(self, use_client: bool = DEFAULT_USE_CLIENT) -&gt; Level:\n        return await self.get_timely(TimelyType.DAILY, use_client=use_client)\n\n    async def get_weekly(self, use_client: bool = DEFAULT_USE_CLIENT) -&gt; Level:\n        return await self.get_timely(TimelyType.WEEKLY, use_client=use_client)\n\n    async def get_event(self, use_client: bool = DEFAULT_USE_CLIENT) -&gt; Level:\n        return await self.get_timely(TimelyType.EVENT, use_client=use_client)\n\n    async def get_timely(self, type: TimelyType, use_client: bool = DEFAULT_USE_CLIENT) -&gt; Level:\n        timely_model = await self.session.get_timely_info(type=type)\n\n        level = await self.get_level(type.into_timely_id().value, use_client=use_client)\n\n        return level.update_with_timely_model(timely_model)\n\n    async def get_level(\n        self,\n        level_id: int,\n        get_data: bool = DEFAULT_GET_DATA,\n        use_client: bool = DEFAULT_USE_CLIENT,\n    ) -&gt; Level:\n        get_data = get_data or level_id &lt; 0\n\n        if get_data:\n            if use_client:\n                check_client_login(self)\n\n                response_model = await self.session.get_level(\n                    level_id=level_id,\n                    account_id=self.account_id,\n                    encoded_password=self.encoded_password,\n                )\n\n            else:\n                response_model = await self.session.get_level(level_id)\n\n            model = response_model.level\n\n            level_id = model.id\n\n        level = await self.search_levels_on_page(level_id).next().extract()\n\n        if level is None:\n            raise InternalError  # TODO: message?\n\n        if get_data:\n            return Level.from_model(model, level.creator, level.song).attach_client(self)\n\n        return level\n\n    @wrap_async_iter\n    async def search_levels_on_page(\n        self,\n        query: Optional[MaybeIterable[IntString]] = None,\n        page: int = DEFAULT_PAGE,\n        filters: Optional[Filters] = None,\n        user: Optional[User] = None,\n        gauntlet: Optional[int] = None,\n    ) -&gt; AsyncIterator[Level]:\n        if user is None:\n            user_id = None\n\n        else:\n            user_id = user.id\n\n        try:\n            response_model = await self.session.search_levels_on_page(\n                query=query,\n                page=page,\n                filters=filters,\n                user_id=user_id,\n                gauntlet=gauntlet,\n                client_account_id=self.account_id,\n                client_user_id=self.id,\n                encoded_password=self.encoded_password,\n            )\n\n        except NothingFound:\n            return\n\n        for model, creator, song in self.level_models_from_model(response_model):\n            yield Level.from_model(model, creator, song).attach_client(self)\n\n    @wrap_async_iter\n    def search_levels(\n        self,\n        query: Optional[Union[int, str]] = None,\n        pages: Iterable[int] = DEFAULT_PAGES,\n        filters: Optional[Filters] = None,\n        user: Optional[User] = None,\n        gauntlet: Optional[int] = None,\n    ) -&gt; AsyncIterator[Level]:\n        return run_iterables(\n            (\n                self.search_levels_on_page(\n                    query=query,\n                    page=page,\n                    filters=filters,\n                    user=user,\n                    gauntlet=gauntlet,\n                ).unwrap()\n                for page in pages\n            ),\n            ClientError,\n        )\n\n    @check_login\n    async def update_level_description(self, level: Level, description: Optional[str]) -&gt; None:\n        await self.session.update_level_description(\n            level_id=level.id,\n            description=description,\n            account_id=self.account_id,\n            encoded_password=self.encoded_password,\n        )\n\n    async def upload_level(\n        self,\n        name: str = UNNAMED,\n        id: int = DEFAULT_ID,\n        version: int = DEFAULT_VERSION,\n        length: LevelLength = LevelLength.DEFAULT,\n        official_song_id: int = DEFAULT_ID,\n        description: str = EMPTY,\n        song_id: int = DEFAULT_ID,\n        original_id: int = DEFAULT_ID,\n        two_player: bool = DEFAULT_TWO_PLAYER,\n        privacy: LevelPrivacy = LevelPrivacy.DEFAULT,\n        object_count: int = DEFAULT_OBJECT_COUNT,\n        coins: int = DEFAULT_COINS,\n        stars: int = DEFAULT_STARS,\n        low_detail: bool = DEFAULT_LOW_DETAIL,\n        capacity: Optional[Capacity] = None,\n        password: Optional[Password] = None,\n        recording: Optional[Recording] = None,\n        editor_time: Optional[Duration] = None,\n        copies_time: Optional[Duration] = None,\n        data: str = EMPTY,\n    ) -&gt; Level:\n        level_id = await self.session.upload_level(\n            name=name,\n            id=id,\n            version=version,\n            length=length,\n            official_song_id=official_song_id,\n            song_id=song_id,\n            description=description,\n            original_id=original_id,\n            two_player=two_player,\n            object_count=object_count,\n            coins=coins,\n            stars=stars,\n            privacy=privacy,\n            low_detail=low_detail,\n            capacity=capacity,\n            password=password,\n            recording=recording,\n            editor_time=editor_time,\n            copies_time=copies_time,\n            data=data,\n            account_id=self.account_id,\n            account_name=self.name,\n            encoded_password=self.encoded_password,\n        )\n\n        if self.load_after_post:\n            return await self.get_level(level_id)\n\n        level = Level.default(level_id).attach_client(self)\n\n        return level\n\n    async def report_level(self, level: Level) -&gt; None:\n        await self.session.report_level(level.id)\n\n    @check_login\n    async def delete_level(self, level: Level) -&gt; None:\n        await self.session.delete_level(\n            level_id=level.id, account_id=self.account_id, encoded_password=self.encoded_password\n        )\n\n    @check_login\n    async def rate_level(self, level: Level, stars: int) -&gt; None:\n        await self.session.rate_level(\n            level_id=level.id,\n            stars=stars,\n            account_id=self.account_id,\n            encoded_password=self.encoded_password,\n        )\n\n    @check_login\n    async def rate_demon(self, level: Level, rating: DemonDifficulty) -&gt; None:\n        await self.session.rate_demon(\n            level_id=level.id,\n            rating=rating,\n            account_id=self.account_id,\n            encoded_password=self.encoded_password,\n        )\n\n    @check_login\n    async def suggest_demon(self, level: Level, rating: DemonDifficulty) -&gt; None:\n        await self.session.suggest_demon(\n            level_id=level.id,\n            rating=rating,\n            account_id=self.account_id,\n            encoded_password=self.encoded_password,\n        )\n\n    @check_login\n    async def suggest_level(self, level: Level, stars: int, feature: bool) -&gt; None:\n        return await self.session.suggest_level(\n            level_id=level.id,\n            stars=stars,\n            feature=feature,\n            account_id=self.account_id,\n            encoded_password=self.encoded_password,\n        )\n\n    @wrap_async_iter\n    @check_login\n    async def get_level_leaderboard(\n        self,\n        level: Level,\n        strategy: LevelLeaderboardStrategy = LevelLeaderboardStrategy.ALL,\n    ) -&gt; AsyncIterator[User]:\n        response_model = await self.session.get_level_leaderboard(\n            level_id=level.id,\n            strategy=strategy,\n            account_id=self.account_id,\n            encoded_password=self.encoded_password,\n        )\n\n        for model in response_model.users:\n            yield User.from_level_leaderboard_user_model(model).attach_client(self)\n\n    @check_login\n    async def block_user(self, user: User) -&gt; None:\n        await self.session.block_user(\n            account_id=user.account_id,\n            client_account_id=self.account_id,\n            encoded_password=self.encoded_password,\n        )\n\n    @check_login\n    async def unblock_user(self, user: User) -&gt; None:\n        await self.session.unblock_user(\n            account_id=user.account_id,\n            client_account_id=self.account_id,\n            encoded_password=self.encoded_password,\n        )\n\n    @check_login\n    async def unfriend_user(self, user: User) -&gt; None:\n        await self.session.unfriend_user(\n            account_id=user.account_id,\n            client_account_id=self.account_id,\n            encoded_password=self.encoded_password,\n        )\n\n    @check_login\n    async def send_message(\n        self, user: User, subject: Optional[str] = None, content: Optional[str] = None\n    ) -&gt; Optional[Message]:\n        await self.session.send_message(\n            account_id=user.account_id,\n            subject=subject,\n            content=content,\n            client_account_id=self.account_id,\n            encoded_password=self.encoded_password,\n        )\n\n        if self.load_after_post:\n            if subject is None:\n                subject = EMPTY\n\n            messages = self.get_messages_on_page(MessageType.OUTGOING)\n            message = await messages.find(by_subject_and_user(subject, user)).extract()\n\n            if message is None:\n                return message\n\n            message.content = content\n\n            return message\n\n        return None\n\n    @check_login\n    async def get_message(self, message_id: int, type: MessageType) -&gt; Message:\n        model = await self.session.get_message(\n            message_id=message_id,\n            type=type,\n            account_id=self.account_id,\n            encoded_password=self.encoded_password,\n        )\n\n        return Message.from_model(model).attach_client(self)\n\n    @check_login\n    async def delete_message(self, message: Message) -&gt; None:\n        await self.session.delete_message(\n            message_id=message.id,\n            type=message.type,\n            account_id=self.account_id,\n            encoded_password=self.encoded_password,\n        )\n\n    @wrap_async_iter\n    @check_login\n    async def get_messages_on_page(\n        self, type: MessageType = MessageType.DEFAULT, page: int = DEFAULT_PAGE\n    ) -&gt; AsyncIterator[Message]:\n        try:\n            response_model = await self.session.get_messages_on_page(\n                type=type,\n                page=page,\n                account_id=self.account_id,\n                encoded_password=self.encoded_password,\n            )\n\n        except NothingFound:\n            return\n\n        for model in response_model.messages:\n            yield Message.from_model(model).attach_client(self)\n\n    @wrap_async_iter\n    @check_login\n    def get_messages(\n        self,\n        type: MessageType = MessageType.DEFAULT,\n        pages: Iterable[int] = DEFAULT_PAGES,\n    ) -&gt; AsyncIterator[Message]:\n        return run_iterables(\n            (self.get_messages_on_page(type=type, page=page).unwrap() for page in pages),\n            ClientError,\n        )\n\n    @check_login\n    async def send_friend_request(\n        self, user: User, message: Optional[str] = None\n    ) -&gt; Optional[FriendRequest]:\n        await self.session.send_friend_request(\n            account_id=user.account_id,\n            message=message,\n            client_account_id=self.account_id,\n            encoded_password=self.encoded_password,\n        )\n\n        if self.load_after_post:\n            friend_requests = self.get_friend_requests_on_page(FriendRequestType.OUTGOING)\n\n            return await friend_requests.find(by_user(user)).extract()\n\n        return None\n\n    @check_login\n    async def delete_friend_request(self, friend_request: FriendRequest) -&gt; None:\n        await self.session.delete_friend_request(\n            account_id=friend_request.user.account_id,\n            type=friend_request.type,\n            client_account_id=self.account_id,\n            encoded_password=self.encoded_password,\n        )\n\n    @check_login\n    async def accept_friend_request(self, friend_request: FriendRequest) -&gt; None:\n        await self.session.accept_friend_request(\n            account_id=friend_request.user.account_id,\n            request_id=friend_request.id,\n            type=friend_request.type,\n            client_account_id=self.account_id,\n            encoded_password=self.encoded_password,\n        )\n\n    @check_login\n    async def read_friend_request(self, friend_request: FriendRequest) -&gt; None:\n        await self.session.read_friend_request(\n            request_id=friend_request.id,\n            account_id=self.account_id,\n            encoded_password=self.encoded_password,\n        )\n\n    @wrap_async_iter\n    @check_login\n    async def get_friend_requests_on_page(\n        self,\n        type: FriendRequestType = FriendRequestType.DEFAULT,\n        page: int = DEFAULT_PAGE,\n    ) -&gt; AsyncIterator[FriendRequest]:\n        try:\n            response_model = await self.session.get_friend_requests_on_page(\n                type=type,\n                page=page,\n                account_id=self.account_id,\n                encoded_password=self.encoded_password,\n            )\n\n        except NothingFound:\n            return\n\n        for model in response_model.friend_requests:\n            yield FriendRequest.from_model(model, type).attach_client(self)\n\n    @wrap_async_iter\n    @check_login\n    def get_friend_requests(\n        self,\n        type: FriendRequestType = FriendRequestType.DEFAULT,\n        pages: Iterable[int] = DEFAULT_PAGES,\n    ) -&gt; AsyncIterator[FriendRequest]:\n        return run_iterables(\n            (self.get_friend_requests_on_page(type=type, page=page).unwrap() for page in pages),\n            ClientError,\n        )\n\n    @check_login\n    async def like_level(self, level: Level) -&gt; None:\n        await self.session.like_level(\n            level.id,\n            dislike=False,\n            account_id=self.account_id,\n            encoded_password=self.encoded_password,\n        )\n\n    @check_login\n    async def dislike_level(self, level: Level) -&gt; None:\n        await self.session.like_level(\n            level.id,\n            dislike=True,\n            account_id=self.account_id,\n            encoded_password=self.encoded_password,\n        )\n\n    @check_login\n    async def like_user_comment(self, comment: UserComment) -&gt; None:\n        await self.session.like_user_comment(\n            comment.id,\n            dislike=False,\n            account_id=self.account_id,\n            encoded_password=self.encoded_password,\n        )\n\n    @check_login\n    async def dislike_user_comment(self, comment: UserComment) -&gt; None:\n        await self.session.like_user_comment(\n            comment.id,\n            dislike=True,\n            account_id=self.account_id,\n            encoded_password=self.encoded_password,\n        )\n\n    @check_login\n    async def like_level_comment(self, comment: LevelComment) -&gt; None:\n        await self.session.like_level_comment(\n            comment.id,\n            comment.level.id,\n            dislike=False,\n            account_id=self.account_id,\n            encoded_password=self.encoded_password,\n        )\n\n    @check_login\n    async def dislike_level_comment(self, comment: LevelComment) -&gt; None:\n        await self.session.like_level_comment(\n            comment.id,\n            comment.level.id,\n            dislike=True,\n            account_id=self.account_id,\n            encoded_password=self.encoded_password,\n        )\n\n    @check_login\n    async def post_comment(self, content: Optional[str] = None) -&gt; Optional[UserComment]:\n        comment_id = await self.session.post_user_comment(\n            content=content,\n            account_id=self.account_id,\n            account_name=self.name,\n            encoded_password=self.encoded_password,\n        )\n\n        if self.load_after_post:\n            comments = self.user.get_comments_on_page()\n\n            return await comments.find(by_id(comment_id)).extract()\n\n        return None\n\n    @check_login\n    async def post_level_comment(\n        self, level: Level, content: Optional[str] = None, record: int = DEFAULT_RECORD\n    ) -&gt; Optional[LevelComment]:\n        comment_id = await self.session.post_level_comment(\n            level_id=level.id,\n            content=content,\n            record=record,\n            account_id=self.account_id,\n            account_name=self.name,\n            encoded_password=self.encoded_password,\n        )\n\n        if self.load_after_post:\n            comments = level.get_comments_on_page(count=DEFAULT_COUNT)\n\n            return await comments.find(by_id(comment_id)).extract()\n\n        return None\n\n    @check_login\n    async def delete_user_comment(self, comment: UserComment) -&gt; None:\n        await self.session.delete_user_comment(\n            comment_id=comment.id,\n            account_id=self.account_id,\n            encoded_password=self.encoded_password,\n        )\n\n    @check_login\n    async def delete_level_comment(self, comment: LevelComment) -&gt; None:\n        await self.session.delete_level_comment(\n            comment_id=comment.id,\n            level_id=comment.level.id,\n            account_id=self.account_id,\n            encoded_password=self.encoded_password,\n        )\n\n    @wrap_async_iter\n    async def get_user_comments_on_page(\n        self,\n        user: User,\n        page: int = DEFAULT_PAGE,\n    ) -&gt; AsyncIterator[UserComment]:\n        response_model = await self.session.get_user_comments_on_page(\n            account_id=user.account_id,\n            page=page,\n        )\n\n        for model in response_model.comments:\n            yield UserComment.from_model(model, user).attach_client(self)\n\n    @wrap_async_iter\n    def get_user_comments(\n        self,\n        user: User,\n        pages: Iterable[int] = DEFAULT_PAGES,\n    ) -&gt; AsyncIterator[UserComment]:\n        return run_iterables(\n            (self.get_user_comments_on_page(user=user, page=page).unwrap() for page in pages),\n            ClientError,\n        )\n\n    @wrap_async_iter\n    async def get_user_level_comments_on_page(\n        self,\n        user: User,\n        count: int = COMMENT_PAGE_SIZE,\n        page: int = DEFAULT_PAGE,\n        strategy: CommentStrategy = CommentStrategy.DEFAULT,\n    ) -&gt; AsyncIterator[LevelComment]:\n        try:\n            response_model = await self.session.get_user_level_comments_on_page(\n                user_id=user.id,\n                count=count,\n                page=page,\n                strategy=strategy,\n            )\n\n        except NothingFound:\n            return\n\n        for model in response_model.comments:\n            yield LevelComment.from_model(model).attach_client(self)\n\n    @wrap_async_iter\n    def get_user_level_comments(\n        self,\n        user: User,\n        count: int = COMMENT_PAGE_SIZE,\n        pages: Iterable[int] = DEFAULT_PAGES,\n        strategy: CommentStrategy = CommentStrategy.DEFAULT,\n    ) -&gt; AsyncIterator[LevelComment]:\n        return run_iterables(\n            (\n                self.get_user_level_comments_on_page(user=user, count=count, page=page).unwrap()\n                for page in pages\n            ),\n            ClientError,\n        )\n\n    @wrap_async_iter\n    async def get_level_comments_on_page(\n        self,\n        level: Level,\n        count: int = COMMENT_PAGE_SIZE,\n        page: int = DEFAULT_PAGE,\n        strategy: CommentStrategy = CommentStrategy.DEFAULT,\n    ) -&gt; AsyncIterator[LevelComment]:\n        try:\n            response_model = await self.session.get_level_comments_on_page(\n                level_id=level.id,\n                count=count,\n                page=page,\n                strategy=strategy,\n            )\n\n        except NothingFound:\n            return\n\n        for model in response_model.comments:\n            comment = LevelComment.from_model(model).attach_client(self)\n\n            comment.level = level\n\n            yield comment\n\n    @wrap_async_iter\n    def get_level_comments(\n        self,\n        level: Level,\n        count: int = COMMENT_PAGE_SIZE,\n        pages: Iterable[int] = DEFAULT_PAGES,\n        strategy: CommentStrategy = CommentStrategy.DEFAULT,\n    ) -&gt; AsyncIterator[LevelComment]:\n        return run_iterables(\n            (\n                self.get_level_comments_on_page(\n                    level=level, count=count, page=page, strategy=strategy\n                ).unwrap()\n                for page in pages\n            ),\n            ClientError,\n        )\n\n    @wrap_async_iter\n    async def get_gauntlets(self) -&gt; AsyncIterator[Gauntlet]:\n        response_model = await self.session.get_gauntlets()\n\n        for model in response_model.gauntlets:\n            yield Gauntlet.from_model(model).attach_client(self)\n\n    @wrap_async_iter\n    async def get_map_packs_on_page(self, page: int = DEFAULT_PAGE) -&gt; AsyncIterator[MapPack]:\n        response_model = await self.session.get_map_packs_on_page(page=page)\n\n        for model in response_model.map_packs:\n            yield MapPack.from_model(model).attach_client(self)\n\n    @wrap_async_iter\n    def get_map_packs(self, pages: Iterable[int] = DEFAULT_PAGES) -&gt; AsyncIterator[MapPack]:\n        return run_iterables(\n            (self.get_map_packs_on_page(page=page).unwrap() for page in pages),\n            ClientError,\n        )\n\n    @wrap_async_iter\n    @check_login\n    async def get_quests(self) -&gt; AsyncIterator[Quest]:\n        response_model = await self.session.get_quests(\n            account_id=self.account_id, encoded_password=self.encoded_password\n        )\n\n        model = response_model.inner\n\n        for quest_model in (model.quest_1, model.quest_2, model.quest_3):\n            yield Quest.from_model(quest_model, model.quest_duration).attach_client(self)\n\n    @wrap_async_iter\n    @check_login\n    async def get_chests(\n        self,\n        reward_type: RewardType = RewardType.DEFAULT,\n        chest_1_count: int = DEFAULT_CHEST_COUNT,\n        chest_2_count: int = DEFAULT_CHEST_COUNT,\n    ) -&gt; AsyncIterator[Chest]:\n        response_model = await self.session.get_chests(\n            reward_type=reward_type,\n            chest_1_count=chest_1_count,\n            chest_2_count=chest_2_count,\n            account_id=self.account_id,\n            encoded_password=self.encoded_password,\n        )\n        model = response_model.inner\n\n        for id, chest_model, count, duration in (\n            (1, model.chest_1, model.chest_1_count, model.chest_1_duration),\n            (2, model.chest_2, model.chest_2_count, model.chest_2_duration),\n        ):\n            yield Chest.from_model(chest_model, id, count, duration).attach_client(self)\n\n    @wrap_async_iter\n    async def get_artists_on_page(self, page: int = DEFAULT_PAGE) -&gt; AsyncIterator[Artist]:\n        response_model = await self.session.get_artists_on_page(page=page)\n\n        for model in response_model.artists:\n            yield Artist.from_model(model).attach_client(self)\n\n    @wrap_async_iter\n    def get_artists(self, pages: Iterable[int] = DEFAULT_PAGES) -&gt; AsyncIterator[Artist]:\n        return run_iterables(\n            (self.get_artists_on_page(page=page).unwrap() for page in pages),\n            ClientError,\n        )\n\n    async def get_song(self, song_id: int) -&gt; Song:\n        model = await self.session.get_song(song_id=song_id)\n\n        return Song.from_model(model).attach_client(self)\n\n    async def get_newgrounds_song(self, song_id: int) -&gt; Song:\n        model = await self.session.get_newgrounds_song(song_id=song_id)\n\n        return Song.from_model(model).attach_client(self)\n\n    @wrap_async_iter\n    async def search_newgrounds_songs_on_page(\n        self, query: str, page: int = DEFAULT_PAGE\n    ) -&gt; AsyncIterator[Song]:\n        models = await self.session.search_newgrounds_songs_on_page(query=query, page=page)\n\n        for model in models:\n            yield Song.from_model(model).attach_client(self)\n\n    @wrap_async_iter\n    def search_newgrounds_songs(\n        self, query: str, pages: Iterable[int] = DEFAULT_PAGES\n    ) -&gt; AsyncIterator[Song]:\n        return run_iterables(\n            (self.search_newgrounds_songs_on_page(query=query, page=page) for page in pages),\n            ClientError,\n        )\n\n    @wrap_async_iter\n    async def search_newgrounds_artists_on_page(\n        self, query: str, page: int = DEFAULT_PAGE\n    ) -&gt; AsyncIterator[Artist]:\n        models = await self.session.search_newgrounds_artists_on_page(query=query, page=page)\n\n        for model in models:\n            yield Artist.from_model(model).attach_client(self)\n\n    @wrap_async_iter\n    def search_newgrounds_artists(\n        self, query: str, pages: Iterable[int] = DEFAULT_PAGES\n    ) -&gt; AsyncIterator[Artist]:\n        return run_iterables(\n            (self.search_newgrounds_artists_on_page(query=query, page=page) for page in pages),\n            ClientError,\n        )\n\n    @wrap_async_iter\n    async def get_newgrounds_artist_songs_on_page(\n        self, artist: Artist, page: int = DEFAULT_PAGE\n    ) -&gt; AsyncIterator[Song]:\n        models = await self.session.get_newgrounds_artist_songs_on_page(\n            artist_name=artist.name, page=page\n        )\n\n        for model in models:\n            yield Song.from_model(model).attach_client(self)\n\n    @wrap_async_iter\n    def get_newgrounds_artist_songs(\n        self, artist: Artist, pages: Iterable[int] = DEFAULT_PAGES\n    ) -&gt; AsyncIterator[Song]:\n        return run_iterables(\n            (\n                self.get_newgrounds_artist_songs_on_page(artist=artist, page=page).unwrap()\n                for page in pages\n            ),\n            ClientError,\n        )\n\n    # handlers\n\n    async def on_daily(self, daily: Level) -&gt; None:\n\"\"\"Handles `daily` events.\n\n        Arguments:\n            daily: The daily level to handle.\n        \"\"\"\n\n    async def on_weekly(self, weekly: Level) -&gt; None:\n\"\"\"Handles `weekly` events.\n\n        Arguments:\n            weekly: The weekly level to handle.\n        \"\"\"\n\n    async def on_rate(self, level: Level) -&gt; None:\n\"\"\"Handles `rate` events.\n\n        Arguments:\n            level: The rated level to handle.\n        \"\"\"\n\n    async def on_level(self, level: Level) -&gt; None:\n\"\"\"Handles `level` events.\n\n        Arguments:\n            level: The level to handle.\n        \"\"\"\n\n    async def on_user_level(self, user: User, level: Level) -&gt; None:\n\"\"\"Handles `user_level` events.\n\n        Arguments:\n            user: The user to handle.\n            level: The level to handle.\n        \"\"\"\n\n    async def on_message(self, message: Message) -&gt; None:\n\"\"\"Handles `message` events.\n\n        Arguments:\n            message: The message to handle.\n        \"\"\"\n\n    async def on_friend_request(self, friend_request: FriendRequest) -&gt; None:\n\"\"\"Handles `friend_request` events.\n\n        Arguments:\n            friend_request: The friend request to handle.\n        \"\"\"\n\n    async def on_level_comment(self, level: Level, comment: LevelComment) -&gt; None:\n\"\"\"Handles `level_comment` events.\n\n        Arguments:\n            level: The level to handle.\n            comment: The level comment to handle.\n        \"\"\"\n\n    async def on_daily_comment(self, daily: Level, comment: LevelComment) -&gt; None:\n\"\"\"Handles `daily_comment` events.\n\n        Arguments:\n            daily: The daily level to handle.\n            comment: The daily comment to handle.\n        \"\"\"\n\n    async def on_weekly_comment(self, weekly: Level, comment: LevelComment) -&gt; None:\n\"\"\"Handles `weekly_comment` events.\n\n        Arguments:\n            weekly: The weekly level to handle.\n            comment: The weekly comment to handle.\n        \"\"\"\n\n    async def on_user_comment(self, user: User, comment: UserComment) -&gt; None:\n\"\"\"Handles `user_comment` events.\n\n        Arguments:\n            user: The user to handle.\n            comment: The comment to handle.\n        \"\"\"\n\n    async def on_user_level_comment(self, user: User, comment: LevelComment) -&gt; None:\n\"\"\"Handles `user_level_comment` events.\n\n        Arguments:\n            user: The user to handle.\n            comment: The level comment to handle.\n        \"\"\"\n\n    # dispatchers\n\n    async def dispatch_daily(self, daily: Level) -&gt; None:\n\"\"\"Dispatches `daily` events via calling [`on_daily`][gd.client.Client.on_daily].\n\n        Arguments:\n            daily: The daily level to dispatch.\n        \"\"\"\n        await self.on_daily(daily)\n\n    async def dispatch_weekly(self, weekly: Level) -&gt; None:\n\"\"\"Dispatches `weekly` events via calling [`on_weekly`][gd.client.Client.on_weekly].\n\n        Arguments:\n            weekly: The weekly level to dispatch.\n        \"\"\"\n        await self.on_weekly(weekly)\n\n    async def dispatch_rate(self, level: Level) -&gt; None:\n\"\"\"Dispatches `rate` events via calling [`on_rate`][gd.client.Client.on_rate].\n\n        Arguments:\n            level: The rated level to dispatch.\n        \"\"\"\n        await self.on_rate(level)\n\n    async def dispatch_level(self, level: Level) -&gt; None:\n\"\"\"Dispatches `level` events via calling [`on_level`][gd.client.Client.on_level].\n\n        Arguments:\n            level: The level to dispatch.\n        \"\"\"\n        await self.on_level(level)\n\n    async def dispatch_user_level(self, user: User, level: Level) -&gt; None:\n\"\"\"Dispatches `user_level` events via calling\n        [`on_user_level`][gd.client.Client.on_user_level].\n\n        Arguments:\n            user: The user to dispatch.\n            level: The level to dispatch.\n        \"\"\"\n        await self.on_user_level(user, level)\n\n    async def dispatch_message(self, message: Message) -&gt; None:\n\"\"\"Dispatches `message` events via calling [`on_message`][gd.client.Client.on_message].\n\n        Arguments:\n            message: The message to dispatch.\n        \"\"\"\n        await self.on_message(message)\n\n    async def dispatch_friend_request(self, friend_request: FriendRequest) -&gt; None:\n\"\"\"Dispatches `friend_request` events via calling\n        [`on_friend_request`][gd.client.Client.on_friend_request].\n\n        Arguments:\n            friend_request: The friend request to dispatch.\n        \"\"\"\n        await self.on_friend_request(friend_request)\n\n    async def dispatch_level_comment(self, level: Level, comment: LevelComment) -&gt; None:\n\"\"\"Dispatches `level_comment` events via calling\n        [`on_level_comment`][gd.client.Client.on_level_comment].\n\n        Arguments:\n            level: The level to dispatch.\n            comment: The level comment to dispatch.\n        \"\"\"\n        await self.on_level_comment(level, comment)\n\n    async def dispatch_daily_comment(self, daily: Level, comment: LevelComment) -&gt; None:\n\"\"\"Dispatches `level_comment` events via calling\n        [`on_level_comment`][gd.client.Client.on_level_comment].\n\n        Arguments:\n            daily: The daily level to dispatch.\n            comment: The daily comment to dispatch.\n        \"\"\"\n        await self.on_daily_comment(daily, comment)\n\n    async def dispatch_weekly_comment(self, weekly: Level, comment: LevelComment) -&gt; None:\n\"\"\"Dispatches `weekly_comment` events via calling\n        [`on_weekly_comment`][gd.client.Client.on_weekly_comment].\n\n        Arguments:\n            weekly: The weekly level to dispatch.\n            comment: The weekly comment to dispatch.\n        \"\"\"\n        await self.on_weekly_comment(weekly, comment)\n\n    async def dispatch_user_comment(self, user: User, comment: UserComment) -&gt; None:\n\"\"\"Dispatches `user_comment` events via calling\n        [`on_user_comment`][gd.client.Client.on_user_comment].\n\n        Arguments:\n            user: The user to dispatch.\n            comment: The comment to dispatch.\n        \"\"\"\n        await self.on_user_comment(user, comment)\n\n    async def dispatch_user_level_comment(self, user: User, comment: LevelComment) -&gt; None:\n\"\"\"Dispatches `user_level_comment` events via calling\n        [`on_user_level_comment`][gd.client.Client.on_user_level_comment].\n\n        Arguments:\n            user: The user to dispatch.\n            comment: The level comment to dispatch.\n        \"\"\"\n        await self.on_user_level_comment(user, comment)\n\n    def event(self, function: F) -&gt; F:\n\"\"\"Registers an event handler.\n\n        Example:\n            ```python\n            client = Client()\n\n            DAILY = \"new daily! {daily.name} by {daily.creator.name} (ID: {daily.id})\n\n            @client.event\n            async def on_daily(daily: Level) -&gt; None:\n                print(DAILY.format(daily=daily))\n            ```\n\n        Arguments:\n            function: The function to register as an event handler.\n\n        Returns:\n            The function passed.\n        \"\"\"\n        set_attribute(self, function.__name__, function)\n\n        return function\n\n    def listen_for_daily(\n        self, delay: float = DEFAULT_DELAY, reconnect: bool = DEFAULT_RECONNECT\n    ) -&gt; DailyListener:\n        return self.add_listener(DailyListener(self, delay=delay, reconnect=reconnect))\n\n    def listen_for_weekly(\n        self, delay: float = DEFAULT_DELAY, reconnect: bool = DEFAULT_RECONNECT\n    ) -&gt; WeeklyListener:\n        return self.add_listener(WeeklyListener(self, delay=delay, reconnect=reconnect))\n\n    def listen_for_rate(\n        self,\n        pages_count: int = DEFAULT_PAGES_COUNT,\n        delay: float = DEFAULT_DELAY,\n        reconnect: bool = DEFAULT_RECONNECT,\n    ) -&gt; RateListener:\n        return self.add_listener(\n            RateListener(self, delay=delay, reconnect=reconnect, pages_count=pages_count)\n        )\n\n    def listen_for_level(\n        self,\n        pages_count: int = DEFAULT_PAGES_COUNT,\n        filters: Optional[Filters] = None,\n        delay: float = DEFAULT_DELAY,\n        reconnect: bool = DEFAULT_RECONNECT,\n    ) -&gt; LevelListener:\n        if filters is None:\n            filters = Filters()\n\n        return self.add_listener(\n            LevelListener(\n                self,\n                delay=delay,\n                reconnect=reconnect,\n                pages_count=pages_count,\n                filters=filters,\n            )\n        )\n\n    def listen_for_user_level(\n        self,\n        account_id: Optional[int] = None,\n        id: Optional[int] = None,\n        name: Optional[str] = None,\n        pages_count: int = DEFAULT_PAGES_COUNT,\n        update: bool = DEFAULT_UPDATE,\n        delay: float = DEFAULT_DELAY,\n        reconnect: bool = DEFAULT_RECONNECT,\n    ) -&gt; UserLevelListener:\n        return self.add_listener(\n            UserLevelListener(\n                self,\n                delay=delay,\n                reconnect=reconnect,\n                account_id=account_id,\n                id=id,\n                name=name,\n                pages_count=pages_count,\n                update=update,\n            )\n        )\n\n    def listen_for_message(\n        self,\n        pages_count: int = DEFAULT_PAGES_COUNT,\n        delay: float = DEFAULT_DELAY,\n        reconnect: bool = DEFAULT_RECONNECT,\n    ) -&gt; MessageListener:\n        return self.add_listener(\n            MessageListener(self, delay=delay, reconnect=reconnect, pages_count=pages_count)\n        )\n\n    def listen_for_friend_request(\n        self,\n        pages_count: int = DEFAULT_PAGES_COUNT,\n        delay: float = DEFAULT_DELAY,\n        reconnect: bool = DEFAULT_RECONNECT,\n    ) -&gt; FriendRequestListener:\n        return self.add_listener(\n            FriendRequestListener(self, delay=delay, reconnect=reconnect, pages_count=pages_count)\n        )\n\n    def listen_for_level_comment(\n        self,\n        level_id: int,\n        pages_count: int = DEFAULT_PAGES_COUNT,\n        count: int = DEFAULT_COUNT,\n        update: bool = DEFAULT_UPDATE,\n        delay: float = DEFAULT_DELAY,\n        reconnect: bool = DEFAULT_RECONNECT,\n    ) -&gt; LevelCommentListener:\n        return self.add_listener(\n            LevelCommentListener(\n                self,\n                delay=delay,\n                reconnect=reconnect,\n                level_id=level_id,\n                pages_count=pages_count,\n                count=count,\n                update=update,\n            )\n        )\n\n    def listen_for_daily_comment(\n        self,\n        pages_count: int = DEFAULT_PAGES_COUNT,\n        count: int = DEFAULT_COUNT,\n        update: bool = DEFAULT_UPDATE,\n        delay: float = DEFAULT_DELAY,\n        reconnect: bool = DEFAULT_RECONNECT,\n    ) -&gt; DailyCommentListener:\n        return self.add_listener(\n            DailyCommentListener(\n                self,\n                delay=delay,\n                reconnect=reconnect,\n                pages_count=pages_count,\n                count=count,\n                update=update,\n            )\n        )\n\n    def listen_for_weekly_comment(\n        self,\n        pages_count: int = DEFAULT_PAGES_COUNT,\n        count: int = DEFAULT_COUNT,\n        update: bool = DEFAULT_UPDATE,\n        delay: float = DEFAULT_DELAY,\n        reconnect: bool = DEFAULT_RECONNECT,\n    ) -&gt; WeeklyCommentListener:\n        return self.add_listener(\n            WeeklyCommentListener(\n                self,\n                delay=delay,\n                reconnect=reconnect,\n                pages_count=pages_count,\n                count=count,\n                update=update,\n            )\n        )\n\n    def listen_for_user_comment(\n        self,\n        account_id: Optional[int] = None,\n        id: Optional[int] = None,\n        name: Optional[str] = None,\n        update: bool = DEFAULT_UPDATE,\n        delay: float = DEFAULT_DELAY,\n        reconnect: bool = DEFAULT_RECONNECT,\n    ) -&gt; UserCommentListener:\n        return self.add_listener(\n            UserCommentListener(\n                self,\n                delay=delay,\n                reconnect=reconnect,\n                account_id=account_id,\n                id=id,\n                name=name,\n                update=update,\n            )\n        )\n\n    def listen_for_user_level_comment(\n        self,\n        account_id: Optional[int] = None,\n        id: Optional[int] = None,\n        name: Optional[str] = None,\n        update: bool = DEFAULT_UPDATE,\n        delay: float = DEFAULT_DELAY,\n        reconnect: bool = DEFAULT_RECONNECT,\n    ) -&gt; UserLevelCommentListener:\n        return self.add_listener(\n            UserLevelCommentListener(\n                self,\n                delay=delay,\n                reconnect=reconnect,\n                account_id=account_id,\n                id=id,\n                name=name,\n                update=update,\n            )\n        )\n\n    # listeners\n\n    def add_listener(self, listener: L) -&gt; L:\n        self.check_controller()\n\n        self._listeners = (*self._listeners, listener)\n\n        return listener\n\n    def clear_listeners(self) -&gt; None:\n        self.check_controller()\n\n        self._listeners = ()\n\n    def remove_listener(self, listener: Listener) -&gt; bool:\n        self.check_controller()\n\n        listeners = self._listeners\n\n        length = len(listeners)\n\n        self._listeners = listeners = tuple(\n            present_listener for present_listener in listeners if present_listener is not listener\n        )\n\n        return len(listeners) &lt; length\n\n    # controllers\n\n    def check_controller(self) -&gt; None:\n        if self._controller is not None:\n            raise RuntimeError(CONTROLLER_ALREADY_CREATED)\n\n    def create_controller(self) -&gt; Controller:\n        self.check_controller()\n\n        self._controller = controller = Controller(self._listeners)\n\n        return controller\n</code></pre>"},{"location":"reference/client/#gd.client.Client.session","title":"<code>session: Session = field(factory=Session)</code>  <code>instance-attribute</code> <code>class-attribute</code>","text":"<p>The session of the client.</p>"},{"location":"reference/client/#gd.client.Client.credentials","title":"<code>credentials: Credentials = field(factory=Credentials)</code>  <code>instance-attribute</code> <code>class-attribute</code>","text":"<p>The credentials of the client.</p>"},{"location":"reference/client/#gd.client.Client.database_unchecked","title":"<code>database_unchecked: Optional[Database] = field(default=None, repr=False)</code>  <code>instance-attribute</code> <code>class-attribute</code>","text":"<p>The database of the client.</p>"},{"location":"reference/client/#gd.client.Client.load_after_post","title":"<code>load_after_post: bool = field(default=DEFAULT_LOAD_AFTER_POST)</code>  <code>instance-attribute</code> <code>class-attribute</code>","text":"<p>Whether to load items after posting them.</p>"},{"location":"reference/client/#gd.client.Client.account_id","title":"<code>account_id: int</code>  <code>property</code>","text":"<p>The account ID of the client.</p>"},{"location":"reference/client/#gd.client.Client.id","title":"<code>id: int</code>  <code>property</code>","text":"<p>The user ID of the client.</p>"},{"location":"reference/client/#gd.client.Client.name","title":"<code>name: str</code>  <code>property</code>","text":"<p>The name of the client.</p>"},{"location":"reference/client/#gd.client.Client.password","title":"<code>password: str</code>  <code>property</code>","text":"<p>The password of the client.</p>"},{"location":"reference/client/#gd.client.Client.http","title":"<code>http: HTTPClient</code>  <code>property</code>","text":"<p>The <code>HTTPClient</code> used by the client session.</p>"},{"location":"reference/client/#gd.client.Client.encoded_password","title":"<code>encoded_password: str</code>  <code>property</code>","text":"<p>The encoded password of the client.</p>"},{"location":"reference/client/#gd.client.Client.user","title":"<code>user: User</code>  <code>property</code>","text":"<p>The user representing the client.</p>"},{"location":"reference/client/#gd.client.Client.is_logged_in","title":"<code>is_logged_in() -&gt; bool</code>","text":"<p>Checks if the client is logged in.</p> <p>Returns:</p> Type Description <code>bool</code> <p>Whether the client is logged in.</p> Source code in <code>gd/client.py</code> <pre><code>def is_logged_in(self) -&gt; bool:\n\"\"\"Checks if the client is logged in.\n\n    Returns:\n        Whether the client is logged in.\n    \"\"\"\n    return self.credentials.is_loaded()\n</code></pre>"},{"location":"reference/client/#gd.client.Client.ping","title":"<code>ping() -&gt; Duration</code>  <code>async</code>","text":"<p>Pings the Geometry Dash server.</p> <p>Returns:</p> Type Description <code>Duration</code> <p>The <code>Duration</code> representing the latency.</p> Source code in <code>gd/client.py</code> <pre><code>async def ping(self) -&gt; Duration:\n\"\"\"Pings the Geometry Dash server.\n\n    Returns:\n        The [`Duration`][gd.date_time.Duration] representing the latency.\n    \"\"\"\n    return await self.ping_url(self.http.url)\n</code></pre>"},{"location":"reference/client/#gd.client.Client.ping_url","title":"<code>ping_url(url: URLString) -&gt; Duration</code>  <code>async</code>","text":"<p>Pings the given <code>url</code>.</p> <p>Returns:</p> Type Description <code>Duration</code> <p>The <code>Duration</code> representing the latency.</p> Source code in <code>gd/client.py</code> <pre><code>async def ping_url(self, url: URLString) -&gt; Duration:\n\"\"\"Pings the given `url`.\n\n    Returns:\n        The [`Duration`][gd.date_time.Duration] representing the latency.\n    \"\"\"\n    return await self.session.ping(url)\n</code></pre>"},{"location":"reference/client/#gd.client.Client.logout","title":"<code>logout() -&gt; None</code>  <code>async</code>","text":"<p>Performs the logout.</p> Source code in <code>gd/client.py</code> <pre><code>async def logout(self) -&gt; None:\n\"\"\"Performs the logout.\"\"\"\n    self.reset_items()\n</code></pre>"},{"location":"reference/client/#gd.client.Client.login","title":"<code>login(name: str, password: str) -&gt; LoginContextManager[C]</code>","text":"<p>Performs the login.</p> <p>This function returns a context manager that can be used for temporarily logging in:</p> <pre><code>async with client.login(name, password):\n    assert client.is_logged_in()\n\nassert not client.is_logged_in()\n</code></pre> <p>Returns:</p> Type Description <code>LoginContextManager[C]</code> <p>The <code>LoginContextManager</code> for handling login process.</p> Source code in <code>gd/client.py</code> <pre><code>def login(self: C, name: str, password: str) -&gt; LoginContextManager[C]:\n\"\"\"Performs the login.\n\n    This function returns a context manager that can be used for temporarily logging in:\n\n    ```python\n    async with client.login(name, password):\n        assert client.is_logged_in()\n\n    assert not client.is_logged_in()\n    ```\n\n    Returns:\n        The [`LoginContextManager`][gd.client.LoginContextManager] for handling login process.\n    \"\"\"\n    return LoginContextManager(self, name, password)\n</code></pre>"},{"location":"reference/client/#gd.client.Client.unsafe_login","title":"<code>unsafe_login(name: str, password: str) -&gt; UnsafeLoginContextManager[C]</code>","text":"<p>Performs the unsafe login.</p> <p>Unsafe means that the credentials are not confirmed.</p> <p>This function returns a context manager that can be used for temporarily logging in:</p> <pre><code>async with client.unsafe_login(name, password):\n    assert client.is_logged_in()\n\nassert not client.is_logged_in()\n</code></pre> <p>Returns:</p> Type Description <code>UnsafeLoginContextManager[C]</code> <p>The <code>UnsafeLoginContextManager</code> for handling login process.</p> Source code in <code>gd/client.py</code> <pre><code>def unsafe_login(self: C, name: str, password: str) -&gt; UnsafeLoginContextManager[C]:\n\"\"\"Performs the *unsafe* login.\n\n    *Unsafe* means that the credentials are not confirmed.\n\n    This function returns a context manager that can be used for temporarily logging in:\n\n    ```python\n    async with client.unsafe_login(name, password):\n        assert client.is_logged_in()\n\n    assert not client.is_logged_in()\n    ```\n\n    Returns:\n        The [`UnsafeLoginContextManager`][gd.client.UnsafeLoginContextManager]\n            for handling login process.\n    \"\"\"\n    return UnsafeLoginContextManager(self, name, password)\n</code></pre>"},{"location":"reference/client/#gd.client.Client.load","title":"<code>load() -&gt; Database</code>  <code>async</code>","text":"<p>Loads the save from the cloud, saving it in the <code>database</code> attribute.</p> Note <p>This function requires the client to be logged in.</p> <p>Returns:</p> Type Description <code>Database</code> <p>The <code>Database</code> loaded.</p> Source code in <code>gd/client.py</code> <pre><code>@check_login\nasync def load(self) -&gt; Database:\n\"\"\"Loads the save from the cloud, saving it in the\n    [`database`][gd.client.Client.database] attribute.\n\n    Note:\n        This function requires the client to be logged in.\n\n    Returns:\n        The [`Database`][gd.api.database.Database] loaded.\n    \"\"\"\n    database = await self.session.load(\n        account_id=self.account_id, name=self.name, password=self.password\n    )\n\n    self.database = database\n\n    return database\n</code></pre>"},{"location":"reference/client/#gd.client.Client.save","title":"<code>save(database: Optional[Database] = None) -&gt; None</code>  <code>async</code>","text":"<p>Saves the the <code>database</code> to the cloud, optionally fetching it from the <code>database</code> attribute.</p> Note <p>This function requires the client to be logged in.</p> Source code in <code>gd/client.py</code> <pre><code>@check_login\nasync def save(self, database: Optional[Database] = None) -&gt; None:\n\"\"\"Saves the the `database` to the cloud, optionally fetching it from the\n    [`database`][gd.client.Client.database] attribute.\n\n    Note:\n        This function requires the client to be logged in.\n    \"\"\"\n    if database is None:\n        database = self.database\n\n    await self.session.save(\n        database, account_id=self.account_id, name=self.name, password=self.password\n    )\n</code></pre>"},{"location":"reference/client/#gd.client.Client.get_self","title":"<code>get_self(simple: bool = DEFAULT_SIMPLE) -&gt; User</code>  <code>async</code>","text":"<p>Gets the user representing this client.</p> <p>This is a shorthand for:</p> <pre><code>await client.user.get(simple=simple)\n</code></pre> <p>See <code>User.get</code> for more information.</p> Note <p>This function requires the client to be logged in.</p> <p>Parameters:</p> Name Type Description Default <code>simple</code> <code>bool</code> <p>Whether to fetch simple information.</p> <code>DEFAULT_SIMPLE</code> <p>Returns:</p> Type Description <code>User</code> <p>The <code>User</code> representing the client.</p> Source code in <code>gd/client.py</code> <pre><code>@check_login\nasync def get_self(self, simple: bool = DEFAULT_SIMPLE) -&gt; User:\n\"\"\"Gets the user representing this client.\n\n    This is a shorthand for:\n\n    ```python\n    await client.user.get(simple=simple)\n    ```\n\n    See [`User.get`][gd.user.User.get] for more information.\n\n    Note:\n        This function requires the client to be logged in.\n\n    Arguments:\n        simple: Whether to fetch simple information.\n\n    Returns:\n        The [`User`][gd.user.User] representing the client.\n    \"\"\"\n    return await self.user.get(simple=simple)\n</code></pre>"},{"location":"reference/client/#gd.client.Client.get_user","title":"<code>get_user(account_id: int, simple: bool = DEFAULT_SIMPLE, friend_state: bool = DEFAULT_FRIEND_STATE) -&gt; User</code>  <code>async</code>","text":"<p>Fetches the user by <code>account_id</code>.</p> <p>Parameters:</p> Name Type Description Default <code>account_id</code> <code>int</code> <p>The account ID of the user to fetch.</p> required <code>simple</code> <code>bool</code> <p>Whether to fetch simple information only.</p> <code>DEFAULT_SIMPLE</code> <code>friend_state</code> <code>bool</code> <p>Whether to fetch friend state.</p> <code>DEFAULT_FRIEND_STATE</code> Note <p><code>friend_state</code> requires the client to be logged in.</p> <p>Returns:</p> Type Description <code>User</code> <p>The <code>User</code> fetched.</p> Source code in <code>gd/client.py</code> <pre><code>async def get_user(\n    self,\n    account_id: int,\n    simple: bool = DEFAULT_SIMPLE,\n    friend_state: bool = DEFAULT_FRIEND_STATE,\n) -&gt; User:\n\"\"\"Fetches the user by `account_id`.\n\n    Arguments:\n        account_id: The account ID of the user to fetch.\n        simple: Whether to fetch simple information only.\n        friend_state: Whether to fetch friend state.\n\n    Note:\n        `friend_state` requires the client to be logged in.\n\n    Returns:\n        The [`User`][gd.user.User] fetched.\n    \"\"\"\n    if friend_state:  # if we need to fetch friend state\n        check_client_login(self)\n\n        profile_model = await self.session.get_user_profile(  # request profile\n            account_id=account_id,\n            client_account_id=self.account_id,\n            encoded_password=self.encoded_password,\n        )\n\n    else:  # otherwise, simply request normally\n        profile_model = await self.session.get_user_profile(account_id=account_id)\n\n    if simple:  # if only the profile is needed, return right away\n        return User.from_profile_model(profile_model).attach_client(self)\n\n    search_model = await self.session.search_user(profile_model.id)  # search by ID\n\n    return User.from_search_user_and_profile_models(search_model, profile_model).attach_client(\n        self\n    )\n</code></pre>"},{"location":"reference/client/#gd.client.Client.on_daily","title":"<code>on_daily(daily: Level) -&gt; None</code>  <code>async</code>","text":"<p>Handles <code>daily</code> events.</p> <p>Parameters:</p> Name Type Description Default <code>daily</code> <code>Level</code> <p>The daily level to handle.</p> required Source code in <code>gd/client.py</code> <pre><code>async def on_daily(self, daily: Level) -&gt; None:\n\"\"\"Handles `daily` events.\n\n    Arguments:\n        daily: The daily level to handle.\n    \"\"\"\n</code></pre>"},{"location":"reference/client/#gd.client.Client.on_weekly","title":"<code>on_weekly(weekly: Level) -&gt; None</code>  <code>async</code>","text":"<p>Handles <code>weekly</code> events.</p> <p>Parameters:</p> Name Type Description Default <code>weekly</code> <code>Level</code> <p>The weekly level to handle.</p> required Source code in <code>gd/client.py</code> <pre><code>async def on_weekly(self, weekly: Level) -&gt; None:\n\"\"\"Handles `weekly` events.\n\n    Arguments:\n        weekly: The weekly level to handle.\n    \"\"\"\n</code></pre>"},{"location":"reference/client/#gd.client.Client.on_rate","title":"<code>on_rate(level: Level) -&gt; None</code>  <code>async</code>","text":"<p>Handles <code>rate</code> events.</p> <p>Parameters:</p> Name Type Description Default <code>level</code> <code>Level</code> <p>The rated level to handle.</p> required Source code in <code>gd/client.py</code> <pre><code>async def on_rate(self, level: Level) -&gt; None:\n\"\"\"Handles `rate` events.\n\n    Arguments:\n        level: The rated level to handle.\n    \"\"\"\n</code></pre>"},{"location":"reference/client/#gd.client.Client.on_level","title":"<code>on_level(level: Level) -&gt; None</code>  <code>async</code>","text":"<p>Handles <code>level</code> events.</p> <p>Parameters:</p> Name Type Description Default <code>level</code> <code>Level</code> <p>The level to handle.</p> required Source code in <code>gd/client.py</code> <pre><code>async def on_level(self, level: Level) -&gt; None:\n\"\"\"Handles `level` events.\n\n    Arguments:\n        level: The level to handle.\n    \"\"\"\n</code></pre>"},{"location":"reference/client/#gd.client.Client.on_user_level","title":"<code>on_user_level(user: User, level: Level) -&gt; None</code>  <code>async</code>","text":"<p>Handles <code>user_level</code> events.</p> <p>Parameters:</p> Name Type Description Default <code>user</code> <code>User</code> <p>The user to handle.</p> required <code>level</code> <code>Level</code> <p>The level to handle.</p> required Source code in <code>gd/client.py</code> <pre><code>async def on_user_level(self, user: User, level: Level) -&gt; None:\n\"\"\"Handles `user_level` events.\n\n    Arguments:\n        user: The user to handle.\n        level: The level to handle.\n    \"\"\"\n</code></pre>"},{"location":"reference/client/#gd.client.Client.on_message","title":"<code>on_message(message: Message) -&gt; None</code>  <code>async</code>","text":"<p>Handles <code>message</code> events.</p> <p>Parameters:</p> Name Type Description Default <code>message</code> <code>Message</code> <p>The message to handle.</p> required Source code in <code>gd/client.py</code> <pre><code>async def on_message(self, message: Message) -&gt; None:\n\"\"\"Handles `message` events.\n\n    Arguments:\n        message: The message to handle.\n    \"\"\"\n</code></pre>"},{"location":"reference/client/#gd.client.Client.on_friend_request","title":"<code>on_friend_request(friend_request: FriendRequest) -&gt; None</code>  <code>async</code>","text":"<p>Handles <code>friend_request</code> events.</p> <p>Parameters:</p> Name Type Description Default <code>friend_request</code> <code>FriendRequest</code> <p>The friend request to handle.</p> required Source code in <code>gd/client.py</code> <pre><code>async def on_friend_request(self, friend_request: FriendRequest) -&gt; None:\n\"\"\"Handles `friend_request` events.\n\n    Arguments:\n        friend_request: The friend request to handle.\n    \"\"\"\n</code></pre>"},{"location":"reference/client/#gd.client.Client.on_level_comment","title":"<code>on_level_comment(level: Level, comment: LevelComment) -&gt; None</code>  <code>async</code>","text":"<p>Handles <code>level_comment</code> events.</p> <p>Parameters:</p> Name Type Description Default <code>level</code> <code>Level</code> <p>The level to handle.</p> required <code>comment</code> <code>LevelComment</code> <p>The level comment to handle.</p> required Source code in <code>gd/client.py</code> <pre><code>async def on_level_comment(self, level: Level, comment: LevelComment) -&gt; None:\n\"\"\"Handles `level_comment` events.\n\n    Arguments:\n        level: The level to handle.\n        comment: The level comment to handle.\n    \"\"\"\n</code></pre>"},{"location":"reference/client/#gd.client.Client.on_daily_comment","title":"<code>on_daily_comment(daily: Level, comment: LevelComment) -&gt; None</code>  <code>async</code>","text":"<p>Handles <code>daily_comment</code> events.</p> <p>Parameters:</p> Name Type Description Default <code>daily</code> <code>Level</code> <p>The daily level to handle.</p> required <code>comment</code> <code>LevelComment</code> <p>The daily comment to handle.</p> required Source code in <code>gd/client.py</code> <pre><code>async def on_daily_comment(self, daily: Level, comment: LevelComment) -&gt; None:\n\"\"\"Handles `daily_comment` events.\n\n    Arguments:\n        daily: The daily level to handle.\n        comment: The daily comment to handle.\n    \"\"\"\n</code></pre>"},{"location":"reference/client/#gd.client.Client.on_weekly_comment","title":"<code>on_weekly_comment(weekly: Level, comment: LevelComment) -&gt; None</code>  <code>async</code>","text":"<p>Handles <code>weekly_comment</code> events.</p> <p>Parameters:</p> Name Type Description Default <code>weekly</code> <code>Level</code> <p>The weekly level to handle.</p> required <code>comment</code> <code>LevelComment</code> <p>The weekly comment to handle.</p> required Source code in <code>gd/client.py</code> <pre><code>async def on_weekly_comment(self, weekly: Level, comment: LevelComment) -&gt; None:\n\"\"\"Handles `weekly_comment` events.\n\n    Arguments:\n        weekly: The weekly level to handle.\n        comment: The weekly comment to handle.\n    \"\"\"\n</code></pre>"},{"location":"reference/client/#gd.client.Client.on_user_comment","title":"<code>on_user_comment(user: User, comment: UserComment) -&gt; None</code>  <code>async</code>","text":"<p>Handles <code>user_comment</code> events.</p> <p>Parameters:</p> Name Type Description Default <code>user</code> <code>User</code> <p>The user to handle.</p> required <code>comment</code> <code>UserComment</code> <p>The comment to handle.</p> required Source code in <code>gd/client.py</code> <pre><code>async def on_user_comment(self, user: User, comment: UserComment) -&gt; None:\n\"\"\"Handles `user_comment` events.\n\n    Arguments:\n        user: The user to handle.\n        comment: The comment to handle.\n    \"\"\"\n</code></pre>"},{"location":"reference/client/#gd.client.Client.on_user_level_comment","title":"<code>on_user_level_comment(user: User, comment: LevelComment) -&gt; None</code>  <code>async</code>","text":"<p>Handles <code>user_level_comment</code> events.</p> <p>Parameters:</p> Name Type Description Default <code>user</code> <code>User</code> <p>The user to handle.</p> required <code>comment</code> <code>LevelComment</code> <p>The level comment to handle.</p> required Source code in <code>gd/client.py</code> <pre><code>async def on_user_level_comment(self, user: User, comment: LevelComment) -&gt; None:\n\"\"\"Handles `user_level_comment` events.\n\n    Arguments:\n        user: The user to handle.\n        comment: The level comment to handle.\n    \"\"\"\n</code></pre>"},{"location":"reference/client/#gd.client.Client.dispatch_daily","title":"<code>dispatch_daily(daily: Level) -&gt; None</code>  <code>async</code>","text":"<p>Dispatches <code>daily</code> events via calling <code>on_daily</code>.</p> <p>Parameters:</p> Name Type Description Default <code>daily</code> <code>Level</code> <p>The daily level to dispatch.</p> required Source code in <code>gd/client.py</code> <pre><code>async def dispatch_daily(self, daily: Level) -&gt; None:\n\"\"\"Dispatches `daily` events via calling [`on_daily`][gd.client.Client.on_daily].\n\n    Arguments:\n        daily: The daily level to dispatch.\n    \"\"\"\n    await self.on_daily(daily)\n</code></pre>"},{"location":"reference/client/#gd.client.Client.dispatch_weekly","title":"<code>dispatch_weekly(weekly: Level) -&gt; None</code>  <code>async</code>","text":"<p>Dispatches <code>weekly</code> events via calling <code>on_weekly</code>.</p> <p>Parameters:</p> Name Type Description Default <code>weekly</code> <code>Level</code> <p>The weekly level to dispatch.</p> required Source code in <code>gd/client.py</code> <pre><code>async def dispatch_weekly(self, weekly: Level) -&gt; None:\n\"\"\"Dispatches `weekly` events via calling [`on_weekly`][gd.client.Client.on_weekly].\n\n    Arguments:\n        weekly: The weekly level to dispatch.\n    \"\"\"\n    await self.on_weekly(weekly)\n</code></pre>"},{"location":"reference/client/#gd.client.Client.dispatch_rate","title":"<code>dispatch_rate(level: Level) -&gt; None</code>  <code>async</code>","text":"<p>Dispatches <code>rate</code> events via calling <code>on_rate</code>.</p> <p>Parameters:</p> Name Type Description Default <code>level</code> <code>Level</code> <p>The rated level to dispatch.</p> required Source code in <code>gd/client.py</code> <pre><code>async def dispatch_rate(self, level: Level) -&gt; None:\n\"\"\"Dispatches `rate` events via calling [`on_rate`][gd.client.Client.on_rate].\n\n    Arguments:\n        level: The rated level to dispatch.\n    \"\"\"\n    await self.on_rate(level)\n</code></pre>"},{"location":"reference/client/#gd.client.Client.dispatch_level","title":"<code>dispatch_level(level: Level) -&gt; None</code>  <code>async</code>","text":"<p>Dispatches <code>level</code> events via calling <code>on_level</code>.</p> <p>Parameters:</p> Name Type Description Default <code>level</code> <code>Level</code> <p>The level to dispatch.</p> required Source code in <code>gd/client.py</code> <pre><code>async def dispatch_level(self, level: Level) -&gt; None:\n\"\"\"Dispatches `level` events via calling [`on_level`][gd.client.Client.on_level].\n\n    Arguments:\n        level: The level to dispatch.\n    \"\"\"\n    await self.on_level(level)\n</code></pre>"},{"location":"reference/client/#gd.client.Client.dispatch_user_level","title":"<code>dispatch_user_level(user: User, level: Level) -&gt; None</code>  <code>async</code>","text":"<p>Dispatches <code>user_level</code> events via calling <code>on_user_level</code>.</p> <p>Parameters:</p> Name Type Description Default <code>user</code> <code>User</code> <p>The user to dispatch.</p> required <code>level</code> <code>Level</code> <p>The level to dispatch.</p> required Source code in <code>gd/client.py</code> <pre><code>async def dispatch_user_level(self, user: User, level: Level) -&gt; None:\n\"\"\"Dispatches `user_level` events via calling\n    [`on_user_level`][gd.client.Client.on_user_level].\n\n    Arguments:\n        user: The user to dispatch.\n        level: The level to dispatch.\n    \"\"\"\n    await self.on_user_level(user, level)\n</code></pre>"},{"location":"reference/client/#gd.client.Client.dispatch_message","title":"<code>dispatch_message(message: Message) -&gt; None</code>  <code>async</code>","text":"<p>Dispatches <code>message</code> events via calling <code>on_message</code>.</p> <p>Parameters:</p> Name Type Description Default <code>message</code> <code>Message</code> <p>The message to dispatch.</p> required Source code in <code>gd/client.py</code> <pre><code>async def dispatch_message(self, message: Message) -&gt; None:\n\"\"\"Dispatches `message` events via calling [`on_message`][gd.client.Client.on_message].\n\n    Arguments:\n        message: The message to dispatch.\n    \"\"\"\n    await self.on_message(message)\n</code></pre>"},{"location":"reference/client/#gd.client.Client.dispatch_friend_request","title":"<code>dispatch_friend_request(friend_request: FriendRequest) -&gt; None</code>  <code>async</code>","text":"<p>Dispatches <code>friend_request</code> events via calling <code>on_friend_request</code>.</p> <p>Parameters:</p> Name Type Description Default <code>friend_request</code> <code>FriendRequest</code> <p>The friend request to dispatch.</p> required Source code in <code>gd/client.py</code> <pre><code>async def dispatch_friend_request(self, friend_request: FriendRequest) -&gt; None:\n\"\"\"Dispatches `friend_request` events via calling\n    [`on_friend_request`][gd.client.Client.on_friend_request].\n\n    Arguments:\n        friend_request: The friend request to dispatch.\n    \"\"\"\n    await self.on_friend_request(friend_request)\n</code></pre>"},{"location":"reference/client/#gd.client.Client.dispatch_level_comment","title":"<code>dispatch_level_comment(level: Level, comment: LevelComment) -&gt; None</code>  <code>async</code>","text":"<p>Dispatches <code>level_comment</code> events via calling <code>on_level_comment</code>.</p> <p>Parameters:</p> Name Type Description Default <code>level</code> <code>Level</code> <p>The level to dispatch.</p> required <code>comment</code> <code>LevelComment</code> <p>The level comment to dispatch.</p> required Source code in <code>gd/client.py</code> <pre><code>async def dispatch_level_comment(self, level: Level, comment: LevelComment) -&gt; None:\n\"\"\"Dispatches `level_comment` events via calling\n    [`on_level_comment`][gd.client.Client.on_level_comment].\n\n    Arguments:\n        level: The level to dispatch.\n        comment: The level comment to dispatch.\n    \"\"\"\n    await self.on_level_comment(level, comment)\n</code></pre>"},{"location":"reference/client/#gd.client.Client.dispatch_daily_comment","title":"<code>dispatch_daily_comment(daily: Level, comment: LevelComment) -&gt; None</code>  <code>async</code>","text":"<p>Dispatches <code>level_comment</code> events via calling <code>on_level_comment</code>.</p> <p>Parameters:</p> Name Type Description Default <code>daily</code> <code>Level</code> <p>The daily level to dispatch.</p> required <code>comment</code> <code>LevelComment</code> <p>The daily comment to dispatch.</p> required Source code in <code>gd/client.py</code> <pre><code>async def dispatch_daily_comment(self, daily: Level, comment: LevelComment) -&gt; None:\n\"\"\"Dispatches `level_comment` events via calling\n    [`on_level_comment`][gd.client.Client.on_level_comment].\n\n    Arguments:\n        daily: The daily level to dispatch.\n        comment: The daily comment to dispatch.\n    \"\"\"\n    await self.on_daily_comment(daily, comment)\n</code></pre>"},{"location":"reference/client/#gd.client.Client.dispatch_weekly_comment","title":"<code>dispatch_weekly_comment(weekly: Level, comment: LevelComment) -&gt; None</code>  <code>async</code>","text":"<p>Dispatches <code>weekly_comment</code> events via calling <code>on_weekly_comment</code>.</p> <p>Parameters:</p> Name Type Description Default <code>weekly</code> <code>Level</code> <p>The weekly level to dispatch.</p> required <code>comment</code> <code>LevelComment</code> <p>The weekly comment to dispatch.</p> required Source code in <code>gd/client.py</code> <pre><code>async def dispatch_weekly_comment(self, weekly: Level, comment: LevelComment) -&gt; None:\n\"\"\"Dispatches `weekly_comment` events via calling\n    [`on_weekly_comment`][gd.client.Client.on_weekly_comment].\n\n    Arguments:\n        weekly: The weekly level to dispatch.\n        comment: The weekly comment to dispatch.\n    \"\"\"\n    await self.on_weekly_comment(weekly, comment)\n</code></pre>"},{"location":"reference/client/#gd.client.Client.dispatch_user_comment","title":"<code>dispatch_user_comment(user: User, comment: UserComment) -&gt; None</code>  <code>async</code>","text":"<p>Dispatches <code>user_comment</code> events via calling <code>on_user_comment</code>.</p> <p>Parameters:</p> Name Type Description Default <code>user</code> <code>User</code> <p>The user to dispatch.</p> required <code>comment</code> <code>UserComment</code> <p>The comment to dispatch.</p> required Source code in <code>gd/client.py</code> <pre><code>async def dispatch_user_comment(self, user: User, comment: UserComment) -&gt; None:\n\"\"\"Dispatches `user_comment` events via calling\n    [`on_user_comment`][gd.client.Client.on_user_comment].\n\n    Arguments:\n        user: The user to dispatch.\n        comment: The comment to dispatch.\n    \"\"\"\n    await self.on_user_comment(user, comment)\n</code></pre>"},{"location":"reference/client/#gd.client.Client.dispatch_user_level_comment","title":"<code>dispatch_user_level_comment(user: User, comment: LevelComment) -&gt; None</code>  <code>async</code>","text":"<p>Dispatches <code>user_level_comment</code> events via calling <code>on_user_level_comment</code>.</p> <p>Parameters:</p> Name Type Description Default <code>user</code> <code>User</code> <p>The user to dispatch.</p> required <code>comment</code> <code>LevelComment</code> <p>The level comment to dispatch.</p> required Source code in <code>gd/client.py</code> <pre><code>async def dispatch_user_level_comment(self, user: User, comment: LevelComment) -&gt; None:\n\"\"\"Dispatches `user_level_comment` events via calling\n    [`on_user_level_comment`][gd.client.Client.on_user_level_comment].\n\n    Arguments:\n        user: The user to dispatch.\n        comment: The level comment to dispatch.\n    \"\"\"\n    await self.on_user_level_comment(user, comment)\n</code></pre>"},{"location":"reference/client/#gd.client.Client.event","title":"<code>event(function: F) -&gt; F</code>","text":"<p>Registers an event handler.</p> Example <pre><code>client = Client()\n\nDAILY = \"new daily! {daily.name} by {daily.creator.name} (ID: {daily.id})\n\n@client.event\nasync def on_daily(daily: Level) -&gt; None:\n    print(DAILY.format(daily=daily))\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>function</code> <code>F</code> <p>The function to register as an event handler.</p> required <p>Returns:</p> Type Description <code>F</code> <p>The function passed.</p> Source code in <code>gd/client.py</code> <pre><code>def event(self, function: F) -&gt; F:\n\"\"\"Registers an event handler.\n\n    Example:\n        ```python\n        client = Client()\n\n        DAILY = \"new daily! {daily.name} by {daily.creator.name} (ID: {daily.id})\n\n        @client.event\n        async def on_daily(daily: Level) -&gt; None:\n            print(DAILY.format(daily=daily))\n        ```\n\n    Arguments:\n        function: The function to register as an event handler.\n\n    Returns:\n        The function passed.\n    \"\"\"\n    set_attribute(self, function.__name__, function)\n\n    return function\n</code></pre>"},{"location":"reference/enums/","title":"Enums","text":""},{"location":"reference/enums/#gd.enums.SimpleKey","title":"<code>SimpleKey</code>","text":"<p>         Bases: <code>Enum</code></p> <p>Represents keys used in static XOR ciphers.</p> Source code in <code>gd/enums.py</code> <pre><code>class SimpleKey(Enum):\n\"\"\"Represents keys used in static *XOR* ciphers.\"\"\"\n\n    SAVE = 11\n</code></pre>"},{"location":"reference/enums/#gd.enums.Key","title":"<code>Key</code>","text":"<p>         Bases: <code>Enum</code></p> <p>Represents keys used in cyclic XOR ciphers.</p> Source code in <code>gd/enums.py</code> <pre><code>class Key(Enum):\n\"\"\"Represents keys used in cyclic *XOR* ciphers.\"\"\"\n\n    MESSAGE = 14251\n    QUESTS = 19847\n    LEVEL_PASSWORD = 26364\n    COMMENT = 29481\n    USER_PASSWORD = 37526\n    LEVEL_LEADERBOARD = 39673\n    LEVEL = 41274\n    LIKE_RATE = 58281\n    CHESTS = 59182\n    USER_LEADERBOARD = 85271\n\n    def __init__(\n        self, value: int, encoding: str = DEFAULT_ENCODING, errors: str = DEFAULT_ERRORS\n    ) -&gt; None:\n        self.string = string = str(value)\n        self.bytes = string.encode(encoding, errors)\n</code></pre>"},{"location":"reference/enums/#gd.enums.Salt","title":"<code>Salt</code>","text":"<p>         Bases: <code>Enum</code></p> <p>Represents salts used in hashing.</p> Source code in <code>gd/enums.py</code> <pre><code>class Salt(Enum):\n\"\"\"Represents salts used in hashing.\"\"\"\n\n    LEVEL = \"xI25fpAapCQg\"\n    COMMENT = \"xPT6iUrtws0J\"\n    LIKE_RATE = \"ysg6pUrtjn0J\"\n    USER_LEADERBOARD = \"xI35fsAapCRg\"\n    LEVEL_LEADERBOARD = \"yPg6pUrtWn0J\"\n    QUESTS = \"oC36fpYaPtdg\"\n    CHESTS = \"pC26fpYaQCtg\"\n\n    EMPTY = EMPTY\n\n    def __init__(\n        self, string: str, encoding: str = DEFAULT_ENCODING, errors: str = DEFAULT_ERRORS\n    ) -&gt; None:\n        self.string = string\n        self.bytes = string.encode(encoding, errors)\n</code></pre>"},{"location":"reference/enums/#gd.enums.Secret","title":"<code>Secret</code>","text":"<p>         Bases: <code>Enum</code></p> <p>Represents secrets.</p> Source code in <code>gd/enums.py</code> <pre><code>class Secret(Enum):\n\"\"\"Represents secrets.\"\"\"\n\n    MAIN = \"Wmfd2893gb7\"\n    LEVEL = \"Wmfv2898gc9\"\n    USER = \"Wmfv3899gc9\"\n    MOD = \"Wmfp3879gc3\"\n</code></pre>"},{"location":"reference/enums/#gd.enums.AccountURLType","title":"<code>AccountURLType</code>","text":"<p>         Bases: <code>Enum</code></p> <p>Represents account URL types.</p> Source code in <code>gd/enums.py</code> <pre><code>class AccountURLType(Enum):\n\"\"\"Represents account URL types.\"\"\"\n\n    SAVE = 1\n    LOAD = 2\n</code></pre>"},{"location":"reference/enums/#gd.enums.IconType","title":"<code>IconType</code>","text":"<p>         Bases: <code>Enum</code></p> <p>Represents icon types.</p> Source code in <code>gd/enums.py</code> <pre><code>class IconType(Enum):\n\"\"\"Represents icon types.\"\"\"\n\n    CUBE = 0\n    SHIP = 1\n    BALL = 2\n    UFO = 3\n    WAVE = 4\n    ROBOT = 5\n    SPIDER = 6\n    # SWING_COPTER = 7\n\n    DEFAULT = CUBE\n\n    def is_default(self) -&gt; bool:\n        return self is type(self).DEFAULT\n\n    def is_cube(self) -&gt; bool:\n        return self is type(self).CUBE\n\n    def is_ship(self) -&gt; bool:\n        return self is type(self).SHIP\n\n    def is_ball(self) -&gt; bool:\n        return self is type(self).BALL\n\n    def is_ufo(self) -&gt; bool:\n        return self is type(self).UFO\n\n    def is_wave(self) -&gt; bool:\n        return self is type(self).WAVE\n\n    def is_robot(self) -&gt; bool:\n        return self is type(self).ROBOT\n\n    def is_spider(self) -&gt; bool:\n        return self is type(self).SPIDER\n</code></pre>"},{"location":"reference/enums/#gd.enums.MessageState","title":"<code>MessageState</code>","text":"<p>         Bases: <code>Enum</code></p> <p>Represents message states.</p> Source code in <code>gd/enums.py</code> <pre><code>class MessageState(Enum):\n\"\"\"Represents message states.\"\"\"\n\n    OPEN_TO_ALL = 0\n    OPEN_TO_FRIENDS = 1\n    CLOSED = 2\n\n    DEFAULT = OPEN_TO_ALL\n</code></pre>"},{"location":"reference/enums/#gd.enums.CommentState","title":"<code>CommentState</code>","text":"<p>         Bases: <code>Enum</code></p> <p>Represents comment states.</p> Source code in <code>gd/enums.py</code> <pre><code>class CommentState(Enum):\n\"\"\"Represents comment states.\"\"\"\n\n    OPEN_TO_ALL = 0\n    OPEN_TO_FRIENDS = 1\n    CLOSED = 2\n\n    DEFAULT = OPEN_TO_ALL\n</code></pre>"},{"location":"reference/enums/#gd.enums.FriendState","title":"<code>FriendState</code>","text":"<p>         Bases: <code>Enum</code></p> <p>Represents friend states.</p> Source code in <code>gd/enums.py</code> <pre><code>class FriendState(Enum):\n\"\"\"Represents friend states.\"\"\"\n\n    NOT_FRIEND = 0\n    FRIEND = 1\n    BLOCKED = 2\n    OUTGOING_REQUEST = 3\n    INCOMING_REQUEST = 4\n\n    DEFAULT = NOT_FRIEND\n</code></pre>"},{"location":"reference/enums/#gd.enums.FriendRequestState","title":"<code>FriendRequestState</code>","text":"<p>         Bases: <code>Enum</code></p> <p>Represents friend request states.</p> Source code in <code>gd/enums.py</code> <pre><code>class FriendRequestState(Enum):\n\"\"\"Represents friend request states.\"\"\"\n\n    OPEN = 0\n    CLOSED = 1\n\n    DEFAULT = OPEN\n</code></pre>"},{"location":"reference/enums/#gd.enums.Role","title":"<code>Role</code>","text":"<p>         Bases: <code>Enum</code></p> <p>Represents server roles.</p> Source code in <code>gd/enums.py</code> <pre><code>class Role(Enum):\n\"\"\"Represents server roles.\"\"\"\n\n    USER = 0\n    MODERATOR = 1\n    ELDER_MODERATOR = 2\n\n    DEFAULT = USER\n</code></pre>"},{"location":"reference/enums/#gd.enums.LevelLength","title":"<code>LevelLength</code>","text":"<p>         Bases: <code>Enum</code></p> <p>Represents level lengths.</p> Source code in <code>gd/enums.py</code> <pre><code>class LevelLength(Enum):\n\"\"\"Represents level lengths.\"\"\"\n\n    TINY = 0\n    SHORT = 1\n    MEDIUM = 2\n    LONG = 3\n    XL = 4\n    PLATFORMER = 5\n\n    DEFAULT = TINY\n\n    @classmethod\n    def _missing_(cls, value: Any) -&gt; Optional[LevelLength]:  # type: ignore\n        if value &lt; 0:\n            return cls.TINY\n\n        return cls.XL\n</code></pre>"},{"location":"reference/enums/#gd.enums.LevelPrivacy","title":"<code>LevelPrivacy</code>","text":"<p>         Bases: <code>Enum</code></p> <p>Represents level privacy settings.</p> Source code in <code>gd/enums.py</code> <pre><code>class LevelPrivacy(Enum):\n\"\"\"Represents level privacy settings.\"\"\"\n\n    PUBLIC = 0\n    FRIENDS = 1\n    PRIVATE = 2\n\n    DEFAULT = PUBLIC\n\n    def is_private(self) -&gt; bool:\n        return self is type(self).PRIVATE\n\n    def is_friends(self) -&gt; bool:\n        return self is type(self).FRIENDS\n\n    def is_public(self) -&gt; bool:\n        return self is type(self).PUBLIC\n</code></pre>"},{"location":"reference/enums/#gd.enums.Difficulty","title":"<code>Difficulty</code>","text":"<p>         Bases: <code>Enum</code></p> <p>Represents difficulties.</p> Source code in <code>gd/enums.py</code> <pre><code>class Difficulty(Enum):\n\"\"\"Represents difficulties.\"\"\"\n\n    UNKNOWN = 0\n\n    AUTO = 1\n    EASY = 2\n    NORMAL = 3\n    HARD = 4\n    HARDER = 5\n    INSANE = 6\n    DEMON = 7\n    EASY_DEMON = 8\n    MEDIUM_DEMON = 9\n    HARD_DEMON = 10\n    INSANE_DEMON = 11\n    EXTREME_DEMON = 12\n\n    NA = UNKNOWN\n\n    DEFAULT = UNKNOWN\n\n    def into_level_difficulty(self) -&gt; LevelDifficulty:\n        return DIFFICULTY_TO_LEVEL_DIFFICULTY[self]\n\n    def into_demon_difficulty(self) -&gt; DemonDifficulty:\n        return DIFFICULTY_TO_DEMON_DIFFICULTY[self]\n\n    def is_unknown(self) -&gt; bool:\n        return self is type(self).UNKNOWN\n\n    def is_auto(self) -&gt; bool:\n        return self is type(self).AUTO\n\n    def is_unspecified_demon(self) -&gt; bool:\n        return self is type(self).DEMON\n\n    def is_specified_demon(self) -&gt; bool:\n        return self in DEMON\n\n    def is_demon(self) -&gt; bool:\n        return self.is_unspecified_demon() or self.is_specified_demon()\n\n    def clamp_demon(self) -&gt; Difficulty:\n        if self.is_demon():\n            return type(self).DEMON\n\n        return self\n</code></pre>"},{"location":"reference/enums/#gd.enums.LevelDifficulty","title":"<code>LevelDifficulty</code>","text":"<p>         Bases: <code>Enum</code></p> <p>Represents level difficulties.</p> Source code in <code>gd/enums.py</code> <pre><code>class LevelDifficulty(Enum):\n\"\"\"Represents level difficulties.\"\"\"\n\n    UNKNOWN = -1\n    DEMON = -2\n    AUTO = -3\n    EASY = 1\n    NORMAL = 2\n    HARD = 3\n    HARDER = 4\n    INSANE = 5\n    EASY_DEMON = 6\n    MEDIUM_DEMON = 7\n    HARD_DEMON = 8\n    INSANE_DEMON = 9\n    EXTREME_DEMON = 10\n\n    NA = UNKNOWN\n\n    DEFAULT = UNKNOWN\n\n    def into_difficulty(self) -&gt; Difficulty:\n        return LEVEL_DIFFICULTY_TO_DIFFICULTY[self]\n</code></pre>"},{"location":"reference/enums/#gd.enums.DemonDifficulty","title":"<code>DemonDifficulty</code>","text":"<p>         Bases: <code>Enum</code></p> <p>Represents demon difficulties.</p> Source code in <code>gd/enums.py</code> <pre><code>class DemonDifficulty(Enum):\n\"\"\"Represents demon difficulties.\"\"\"\n\n    DEMON = 0\n    EASY_DEMON = 1\n    MEDIUM_DEMON = 2\n    HARD_DEMON = 3\n    INSANE_DEMON = 4\n    EXTREME_DEMON = 5\n\n    DEFAULT = DEMON\n\n    def into_difficulty(self) -&gt; Difficulty:\n        return DEMON_DIFFICULTY_TO_DIFFICULTY[self]\n\n    def into_level_difficulty(self) -&gt; LevelDifficulty:\n        return DEMON_DIFFICULTY_TO_LEVEL_DIFFICULTY[self]\n</code></pre>"},{"location":"reference/enums/#gd.enums.TimelyType","title":"<code>TimelyType</code>","text":"<p>         Bases: <code>Enum</code></p> <p>Represents timely level types.</p> Source code in <code>gd/enums.py</code> <pre><code>class TimelyType(Enum):\n\"\"\"Represents timely level types.\"\"\"\n\n    NOT_TIMELY = 0\n    DAILY = 1\n    WEEKLY = 2\n    EVENT = 3\n\n    DEFAULT = NOT_TIMELY\n\n    def into_timely_id(self) -&gt; TimelyID:\n        return TIMELY_TYPE_TO_ID[self]\n\n    def is_not_timely(self) -&gt; bool:\n        return self is type(self).NOT_TIMELY\n\n    def is_timely(self) -&gt; bool:\n        return not self.is_not_timely()\n\n    def is_daily(self) -&gt; bool:\n        return self is type(self).DAILY\n\n    def is_weekly(self) -&gt; bool:\n        return self is type(self).WEEKLY\n</code></pre>"},{"location":"reference/enums/#gd.enums.TimelyID","title":"<code>TimelyID</code>","text":"<p>         Bases: <code>Enum</code></p> <p>Represents timely level IDs.</p> Source code in <code>gd/enums.py</code> <pre><code>class TimelyID(Enum):\n\"\"\"Represents timely level IDs.\"\"\"\n\n    NOT_TIMELY = 0\n    DAILY = -1\n    WEEKLY = -2\n    EVENT = -3\n\n    DEFAULT = NOT_TIMELY\n\n    def into_timely_type(self) -&gt; TimelyType:\n        return TIMELY_ID_TO_TYPE[self]\n\n    def is_not_timely(self) -&gt; bool:\n        return self is type(self).NOT_TIMELY\n\n    def is_daily(self) -&gt; bool:\n        return self is type(self).DAILY\n\n    def is_weekly(self) -&gt; bool:\n        return self is type(self).WEEKLY\n</code></pre>"},{"location":"reference/enums/#gd.enums.RateFilter","title":"<code>RateFilter</code>","text":"<p>         Bases: <code>Enum</code></p> <p>Represents rate filters.</p> Source code in <code>gd/enums.py</code> <pre><code>class RateFilter(Enum):\n\"\"\"Represents rate filters.\"\"\"\n\n    NOT_RATED = 0\n    RATED = 1\n    FEATURED = 2\n    EPIC = 3\n    GODLIKE = 4\n\n    def is_not_rated(self) -&gt; bool:\n        return self is type(self).NOT_RATED\n\n    def is_rated(self) -&gt; bool:\n        return self is type(self).RATED\n\n    def is_featured(self) -&gt; bool:\n        return self is type(self).FEATURED\n\n    def is_epic(self) -&gt; bool:\n        return self is type(self).EPIC\n\n    def is_godlike(self) -&gt; bool:\n        return self is type(self).GODLIKE\n</code></pre>"},{"location":"reference/enums/#gd.enums.SpecialRateType","title":"<code>SpecialRateType</code>","text":"<p>         Bases: <code>Enum</code></p> <p>Represents special rate types.</p> Source code in <code>gd/enums.py</code> <pre><code>class SpecialRateType(Enum):\n\"\"\"Represents special rate types.\"\"\"\n\n    NONE = 0\n    EPIC = 1\n    GODLIKE = 2\n\n    DEFAULT = NONE\n\n    def is_none(self) -&gt; bool:\n        return self is type(self).NONE\n\n    def is_epic(self) -&gt; bool:\n        return self is type(self).EPIC\n\n    def is_godlike(self) -&gt; bool:\n        return self is type(self).GODLIKE\n\n    def is_default(self) -&gt; bool:\n        return self is type(self).DEFAULT\n</code></pre>"},{"location":"reference/enums/#gd.enums.RateType","title":"<code>RateType</code>","text":"<p>         Bases: <code>Flag</code></p> <p>Represents rate types.</p> Source code in <code>gd/enums.py</code> <pre><code>class RateType(Flag):\n\"\"\"Represents rate types.\"\"\"\n\n    NONE = 0\n\n    NOT_RATED_ONLY = 1 &lt;&lt; 0\n    RATED_ONLY = 1 &lt;&lt; 1\n    FEATURED_ONLY = 1 &lt;&lt; 2\n    EPIC_ONLY = 1 &lt;&lt; 3\n    GODLIKE_ONLY = 1 &lt;&lt; 4\n\n    NOT_RATED = NONE | NOT_RATED_ONLY\n    RATED = NOT_RATED | RATED_ONLY\n    FEATURED = RATED | FEATURED_ONLY\n    EPIC = FEATURED | EPIC_ONLY\n    GODLIKE = EPIC | GODLIKE_ONLY\n\n    DEFAULT = NONE\n\n    def is_not_rated(self) -&gt; bool:\n        return type(self).NOT_RATED_ONLY in self\n\n    def is_rated(self) -&gt; bool:\n        return type(self).RATED_ONLY in self\n\n    def is_featured(self) -&gt; bool:\n        return type(self).FEATURED_ONLY in self\n\n    def is_epic(self) -&gt; bool:\n        return type(self).EPIC_ONLY in self\n\n    def is_godlike(self) -&gt; bool:\n        return type(self).GODLIKE_ONLY in self\n</code></pre>"},{"location":"reference/enums/#gd.enums.CommentType","title":"<code>CommentType</code>","text":"<p>         Bases: <code>Enum</code></p> <p>Represents comment types.</p> Source code in <code>gd/enums.py</code> <pre><code>class CommentType(Enum):\n\"\"\"Represents comment types.\"\"\"\n\n    LEVEL = 0\n    USER = 1\n</code></pre>"},{"location":"reference/enums/#gd.enums.RelationshipType","title":"<code>RelationshipType</code>","text":"<p>         Bases: <code>Enum</code></p> <p>Represents relationship types.</p> Source code in <code>gd/enums.py</code> <pre><code>class RelationshipType(Enum):\n\"\"\"Represents relationship types.\"\"\"\n\n    FRIEND = 0\n    BLOCKED = 1\n\n    def is_friend(self) -&gt; bool:\n        return self is type(self).FRIEND\n\n    def is_outgoing(self) -&gt; bool:\n        return self is type(self).BLOCKED\n</code></pre>"},{"location":"reference/enums/#gd.enums.FriendRequestType","title":"<code>FriendRequestType</code>","text":"<p>         Bases: <code>Enum</code></p> <p>Represents friend request types.</p> Source code in <code>gd/enums.py</code> <pre><code>class FriendRequestType(Enum):\n\"\"\"Represents friend request types.\"\"\"\n\n    INCOMING = 0\n    OUTGOING = 1\n\n    DEFAULT = INCOMING\n\n    def is_incoming(self) -&gt; bool:\n        return self is type(self).INCOMING\n\n    def is_outgoing(self) -&gt; bool:\n        return self is type(self).OUTGOING\n</code></pre>"},{"location":"reference/enums/#gd.enums.MessageType","title":"<code>MessageType</code>","text":"<p>         Bases: <code>Enum</code></p> <p>Represents message types.</p> Source code in <code>gd/enums.py</code> <pre><code>class MessageType(Enum):\n\"\"\"Represents message types.\"\"\"\n\n    INCOMING = 0\n    OUTGOING = 1\n\n    DEFAULT = INCOMING\n\n    def is_incoming(self) -&gt; bool:\n        return self is type(self).INCOMING\n\n    def is_outgoing(self) -&gt; bool:\n        return self is type(self).OUTGOING\n</code></pre>"},{"location":"reference/enums/#gd.enums.CommentStrategy","title":"<code>CommentStrategy</code>","text":"<p>         Bases: <code>Enum</code></p> <p>Represents comment strategies.</p> Source code in <code>gd/enums.py</code> <pre><code>class CommentStrategy(Enum):\n\"\"\"Represents comment strategies.\"\"\"\n\n    RECENT = 0\n    MOST_LIKED = 1\n\n    DEFAULT = RECENT\n</code></pre>"},{"location":"reference/enums/#gd.enums.LeaderboardStrategy","title":"<code>LeaderboardStrategy</code>","text":"<p>         Bases: <code>Enum</code></p> <p>Represents leaderboard strategies.</p> Source code in <code>gd/enums.py</code> <pre><code>class LeaderboardStrategy(Enum):\n\"\"\"Represents leaderboard strategies.\"\"\"\n\n    PLAYERS = 0\n    FRIENDS = 1\n    RELATIVE = 2\n    CREATORS = 3\n\n    DEFAULT = PLAYERS\n\n    def requires_login(self) -&gt; bool:\n        return self in REQUIRES_LOGIN\n</code></pre>"},{"location":"reference/enums/#gd.enums.LevelLeaderboardStrategy","title":"<code>LevelLeaderboardStrategy</code>","text":"<p>         Bases: <code>Enum</code></p> <p>Represents level leaderboard strategies.</p> Source code in <code>gd/enums.py</code> <pre><code>class LevelLeaderboardStrategy(Enum):\n\"\"\"Represents level leaderboard strategies.\"\"\"\n\n    FRIENDS = 0\n    ALL = 1\n    WEEKLY = 2\n\n    DEFAULT = ALL\n</code></pre>"},{"location":"reference/enums/#gd.enums.LikeType","title":"<code>LikeType</code>","text":"<p>         Bases: <code>Enum</code></p> <p>Represents like types.</p> Source code in <code>gd/enums.py</code> <pre><code>class LikeType(Enum):\n\"\"\"Represents like types.\"\"\"\n\n    LEVEL = 1\n    LEVEL_COMMENT = 2\n    USER_COMMENT = 3\n</code></pre>"},{"location":"reference/enums/#gd.enums.GauntletID","title":"<code>GauntletID</code>","text":"<p>         Bases: <code>Enum</code></p> <p>Represents gauntlet IDs.</p> Source code in <code>gd/enums.py</code> <pre><code>class GauntletID(Enum):\n\"\"\"Represents gauntlet IDs.\"\"\"\n\n    UNKNOWN = 0\n    FIRE = 1\n    ICE = 2\n    POISON = 3\n    SHADOW = 4\n    LAVA = 5\n    BONUS = 6\n    CHAOS = 7\n    DEMON = 8\n    TIME = 9\n    CRYSTAL = 10\n    MAGIC = 11\n    SPIKE = 12\n    MONSTER = 13\n    DOOM = 14\n    DEATH = 15\n\n    @classmethod\n    def _missing_(cls, value: Any) -&gt; GauntletID:  # type: ignore\n        return cls.UNKNOWN\n</code></pre>"},{"location":"reference/enums/#gd.enums.SearchStrategy","title":"<code>SearchStrategy</code>","text":"<p>         Bases: <code>Enum</code></p> <p>Represents search strategies.</p> Source code in <code>gd/enums.py</code> <pre><code>class SearchStrategy(Enum):\n\"\"\"Represents search strategies.\"\"\"\n\n    DEFAULT = 0\n    MOST_DOWNLOADED = 1\n    MOST_LIKED = 2\n    TRENDING = 3\n    RECENT = 4\n    BY_USER = 5\n    FEATURED = 6\n    MAGIC = 7\n    SENT = 8\n    SEARCH_MANY = 10\n    RATED = 11\n    FOLLOWED = 12\n    FRIENDS = 13\n    MOST_LIKED_WORLD = 15\n    HALL_OF_FAME = 16\n    FEATURED_WORLD = 17\n    UNKNOWN = 18\n    DAILY_HISTORY = 21\n    WEEKLY_HISTORY = 22\n\n    def is_default(self) -&gt; bool:\n        return self is type(self).DEFAULT\n\n    def is_most_downloaded(self) -&gt; bool:\n        return self is type(self).MOST_DOWNLOADED\n\n    def is_most_liked(self) -&gt; bool:\n        return self is type(self).MOST_LIKED\n\n    def is_trending(self) -&gt; bool:\n        return self is type(self).TRENDING\n\n    def is_recent(self) -&gt; bool:\n        return self is type(self).RECENT\n\n    def is_by_user(self) -&gt; bool:\n        return self is type(self).BY_USER\n\n    def is_featured(self) -&gt; bool:\n        return self is type(self).FEATURED\n\n    def is_magic(self) -&gt; bool:\n        return self is type(self).MAGIC\n\n    def is_sent(self) -&gt; bool:\n        return self is type(self).SENT\n\n    def is_search_many(self) -&gt; bool:\n        return self is type(self).SEARCH_MANY\n\n    def is_rated(self) -&gt; bool:\n        return self is type(self).RATED\n\n    def is_followed(self) -&gt; bool:\n        return self is type(self).FOLLOWED\n\n    def is_friends(self) -&gt; bool:\n        return self is type(self).FRIENDS\n\n    def is_most_liked_world(self) -&gt; bool:\n        return self is type(self).MOST_LIKED_WORLD\n\n    def is_hall_of_fame(self) -&gt; bool:\n        return self is type(self).HALL_OF_FAME\n\n    def is_featured_world(self) -&gt; bool:\n        return self is type(self).FEATURED_WORLD\n\n    def is_unknown(self) -&gt; bool:\n        return self is type(self).UNKNOWN\n\n    def is_daily_history(self) -&gt; bool:\n        return self is type(self).DAILY_HISTORY\n\n    def is_weekly_history(self) -&gt; bool:\n        return self is type(self).WEEKLY_HISTORY\n</code></pre>"},{"location":"reference/enums/#gd.enums.RewardType","title":"<code>RewardType</code>","text":"<p>         Bases: <code>Enum</code></p> <p>Represents reward types.</p> Source code in <code>gd/enums.py</code> <pre><code>class RewardType(Enum):\n\"\"\"Represents reward types.\"\"\"\n\n    GET_INFO = 0\n    CLAIM_SMALL = 1\n    CLAIM_LARGE = 2\n\n    DEFAULT = GET_INFO\n</code></pre>"},{"location":"reference/enums/#gd.enums.ShardType","title":"<code>ShardType</code>","text":"<p>         Bases: <code>Enum</code></p> <p>Represents shard types.</p> Source code in <code>gd/enums.py</code> <pre><code>class ShardType(Enum):\n\"\"\"Represents shard types.\"\"\"\n\n    UNKNOWN = 0\n    FIRE = 1\n    ICE = 2\n    POISON = 3\n    SHADOW = 4\n    LAVA = 5\n    NULL = 6\n\n    DEFAULT = UNKNOWN\n</code></pre>"},{"location":"reference/enums/#gd.enums.RewardItemType","title":"<code>RewardItemType</code>","text":"<p>         Bases: <code>Enum</code></p> <p>Represents item types.</p> Source code in <code>gd/enums.py</code> <pre><code>class RewardItemType(Enum):\n\"\"\"Represents item types.\"\"\"\n\n    UNKNOWN = 0\n\n    FIRE_SHARD = 1\n    ICE_SHARD = 2\n    POISON_SHARD = 3\n    SHADOW_SHARD = 4\n    LAVA_SHARD = 5\n    KEY = 6\n    ORB = 7\n    DIAMOND = 8\n    CUSTOM = 9\n\n    DEFAULT = UNKNOWN\n\n    def is_custom(self) -&gt; bool:\n        return self is type(self).CUSTOM\n</code></pre>"},{"location":"reference/enums/#gd.enums.QuestType","title":"<code>QuestType</code>","text":"<p>         Bases: <code>Enum</code></p> <p>Represents quest types.</p> Source code in <code>gd/enums.py</code> <pre><code>class QuestType(Enum):\n\"\"\"Represents quest types.\"\"\"\n\n    UNKNOWN = 0\n    ORBS = 1\n    COINS = 2\n    STARS = 3\n\n    DEFAULT = UNKNOWN\n\n    def is_unknown(self) -&gt; bool:\n        return self is type(self).UNKNOWN\n</code></pre>"},{"location":"reference/enums/#gd.enums.Scene","title":"<code>Scene</code>","text":"<p>         Bases: <code>Enum</code></p> <p>Represents various scene IDs.</p> Source code in <code>gd/enums.py</code> <pre><code>class Scene(Enum):\n\"\"\"Represents various scene IDs.\"\"\"\n\n    MAIN = 0\n    SELECT = 1\n    OLD = 2\n    EDITOR_OR_LEVEL = 3\n    SEARCH = 4\n    UNUSED = 5\n    LEADERBOARD = 6\n    ONLINE = 7\n    OFFICIAL_SELECT = 8\n    OFFICIAL_LEVEL = 9\n    THE_CHALLENGE = 12\n</code></pre>"},{"location":"reference/enums/#gd.enums.PlayerColor","title":"<code>PlayerColor</code>","text":"<p>         Bases: <code>Enum</code></p> <p>Represents player color settings.</p> Source code in <code>gd/enums.py</code> <pre><code>class PlayerColor(Enum):\n\"\"\"Represents player color settings.\"\"\"\n\n    NOT_USED = 0\n\n    COLOR_1 = 1\n    COLOR_2 = 2\n\n    P1 = COLOR_1\n    P2 = COLOR_2\n\n    DEFAULT = NOT_USED\n\n    def is_not_used(self) -&gt; bool:\n        return self is type(self).NOT_USED\n\n    def is_used(self) -&gt; bool:\n        return not self.is_not_used()\n\n    def is_default(self) -&gt; bool:\n        return self is type(self).DEFAULT\n\n    def is_color_1(self) -&gt; bool:\n        return self is type(self).COLOR_1\n\n    def is_color_2(self) -&gt; bool:\n        return self is type(self).COLOR_2\n</code></pre>"},{"location":"reference/enums/#gd.enums.Easing","title":"<code>Easing</code>","text":"<p>         Bases: <code>Enum</code></p> <p>Represents easing types.</p> Source code in <code>gd/enums.py</code> <pre><code>class Easing(Enum):\n\"\"\"Represents easing types.\"\"\"\n\n    NONE = 0\n    EASE_IN_OUT = 1\n    EASE_IN = 2\n    EASE_OUT = 3\n    ELASTIC_IN_OUT = 4\n    ELASTIC_IN = 5\n    ELASTIC_OUT = 6\n    BOUNCE_IN_OUT = 7\n    BOUNCE_IN = 8\n    BOUNCE_OUT = 9\n    EXPONENTIAL_IN_OUT = 10\n    EXPONENTIAL_IN = 11\n    EXPONENTIAL_OUT = 12\n    SINE_IN_OUT = 13\n    SINE_IN = 14\n    SINE_OUT = 15\n    BACK_IN_OUT = 16\n    BACK_IN = 17\n    BACK_OUT = 18\n\n    DEFAULT = NONE\n</code></pre>"},{"location":"reference/enums/#gd.enums.EasingMethod","title":"<code>EasingMethod</code>","text":"<p>         Bases: <code>Flag</code></p> <p>Represents easing methods.</p> Source code in <code>gd/enums.py</code> <pre><code>class EasingMethod(Flag):\n\"\"\"Represents easing methods.\"\"\"\n\n    NONE = 0\n    IN = 1\n    OUT = 2\n    EASE = 4\n    ELASTIC = 8\n    BOUNCE = 16\n    EXPONENTIAL = 32\n    SINE = 64\n    BACK = 128\n\n    DEFAULT = NONE\n\n    def into_easing(self) -&gt; Easing:\n        cls = type(self)\n        value = self.value\n\n        if not value:\n            return Easing.NONE\n\n        has_easing_in = cls.IN in self\n        has_easing_out = cls.OUT in self\n\n        if not has_easing_in and not has_easing_out:\n            raise ValueError(EXPECTED_MODIFIERS)\n\n        value = (value.bit_length() - IN_OUT_SHIFT) * MULTIPLIER\n\n        if has_easing_in:\n            value -= 1\n\n        if has_easing_out:\n            value -= 1\n\n        return Easing(value)\n\n    @classmethod\n    def from_easing(cls, easing: Easing) -&gt; EasingMethod:\n        value = easing.value\n\n        if not value:\n            return cls.DEFAULT\n\n        IN = cls.IN\n        OUT = cls.OUT\n\n        shift, remainder = divmod((value - 1), MULTIPLIER)\n        shift += IN_OUT_SHIFT\n\n        has_easing_in = remainder != OUT.value\n        has_easing_out = remainder != IN.value\n\n        result = cls(1 &lt;&lt; shift)\n\n        if has_easing_in:\n            result |= IN\n\n        if has_easing_out:\n            result |= OUT\n\n        return result\n</code></pre>"},{"location":"reference/enums/#gd.enums.PulseMode","title":"<code>PulseMode</code>","text":"<p>         Bases: <code>Enum</code></p> <p>Represents pulse modes.</p> Source code in <code>gd/enums.py</code> <pre><code>class PulseMode(Enum):\n\"\"\"Represents pulse modes.\"\"\"\n\n    COLOR = 0\n    HSV = 1\n\n    DEFAULT = COLOR\n\n    def is_color(self) -&gt; bool:\n        return self is type(self).COLOR\n\n    def is_hsv(self) -&gt; bool:\n        return self is type(self).HSV\n</code></pre>"},{"location":"reference/enums/#gd.enums.ToggleType","title":"<code>ToggleType</code>","text":"<p>         Bases: <code>Enum</code></p> <p>Represents toggle types.</p> Source code in <code>gd/enums.py</code> <pre><code>class ToggleType(Enum):\n\"\"\"Represents toggle types.\"\"\"\n\n    SPAWN = 0\n    TOGGLE_ON = 1\n    TOGGLE_OFF = 2\n\n    DEFAULT = SPAWN\n</code></pre>"},{"location":"reference/enums/#gd.enums.InstantCountComparison","title":"<code>InstantCountComparison</code>","text":"<p>         Bases: <code>Enum</code></p> <p>Represents instant count comparison types.</p> Source code in <code>gd/enums.py</code> <pre><code>class InstantCountComparison(Enum):\n\"\"\"Represents instant count comparison types.\"\"\"\n\n    EQUALS = 0\n    LARGER = 1\n    SMALLER = 2\n\n    DEFAULT = EQUALS\n</code></pre>"},{"location":"reference/enums/#gd.enums.OrbType","title":"<code>OrbType</code>","text":"<p>         Bases: <code>Enum</code></p> <p>Represents orb object IDs.</p> Source code in <code>gd/enums.py</code> <pre><code>class OrbType(Enum):\n\"\"\"Represents orb object IDs.\"\"\"\n\n    YELLOW = 36\n    BLUE = 84\n    PINK = 141\n    GREEN = 1022\n    RED = 1333\n    BLACK = 1330\n    DASH = 1704\n    REVERSE_DASH = 1751\n    TRIGGER = 1594\n\n    @property\n    def id(self) -&gt; int:\n        return self.value\n\n    def is_trigger(self) -&gt; int:\n        return self is type(self).TRIGGER\n</code></pre>"},{"location":"reference/enums/#gd.enums.PadType","title":"<code>PadType</code>","text":"<p>         Bases: <code>Enum</code></p> <p>Represents pad object IDs.</p> Source code in <code>gd/enums.py</code> <pre><code>class PadType(Enum):\n\"\"\"Represents pad object IDs.\"\"\"\n\n    YELLOW = 35\n    BLUE = 67\n    PINK = 140\n    RED = 1332\n\n    @property\n    def id(self) -&gt; int:\n        return self.value\n</code></pre>"},{"location":"reference/enums/#gd.enums.MiscType","title":"<code>MiscType</code>","text":"<p>         Bases: <code>Enum</code></p> <p>Represents miscellaneous object IDs.</p> Source code in <code>gd/enums.py</code> <pre><code>class MiscType(Enum):\n\"\"\"Represents miscellaneous object IDs.\"\"\"\n\n    TEXT = 914\n    START_POSITION = 31\n    ITEM_COUNTER = 1615\n    COLLISION_BLOCK = 1816\n\n    @property\n    def id(self) -&gt; int:\n        return self.value\n</code></pre>"},{"location":"reference/enums/#gd.enums.ItemMode","title":"<code>ItemMode</code>","text":"<p>         Bases: <code>Enum</code></p> <p>Represents item modes.</p> Source code in <code>gd/enums.py</code> <pre><code>class ItemMode(Enum):\n\"\"\"Represents item modes.\"\"\"\n\n    DEFAULT = 0\n    PICKUP = 1\n    TOGGLE = 2\n\n    def is_pickup(self) -&gt; bool:\n        return self is type(self).PICKUP\n\n    def is_toggle(self) -&gt; bool:\n        return self is type(self).TOGGLE\n</code></pre>"},{"location":"reference/enums/#gd.enums.GameMode","title":"<code>GameMode</code>","text":"<p>         Bases: <code>Enum</code></p> <p>Represents game modes.</p> Source code in <code>gd/enums.py</code> <pre><code>class GameMode(Enum):\n\"\"\"Represents game modes.\"\"\"\n\n    CUBE = 0\n    SHIP = 1\n    BALL = 2\n    UFO = 3\n    WAVE = 4\n    ROBOT = 5\n    SPIDER = 6\n    # SWING_COPTER = 7\n\n    DEFAULT = CUBE\n</code></pre>"},{"location":"reference/enums/#gd.enums.LevelType","title":"<code>LevelType</code>","text":"<p>         Bases: <code>Enum</code></p> <p>Represents level types.</p> Source code in <code>gd/enums.py</code> <pre><code>class LevelType(Enum):\n\"\"\"Represents level types.\"\"\"\n\n    NULL = 0\n    OFFICIAL = 1\n    CREATED = 2\n    SAVED = 3\n    ONLINE = 4\n\n    def is_null(self) -&gt; bool:\n        return self is type(self).NULL\n\n    def is_official(self) -&gt; bool:\n        return self is type(self).OFFICIAL\n\n    def is_created(self) -&gt; bool:\n        return self is type(self).CREATED\n\n    def is_saved(self) -&gt; bool:\n        return self is type(self).SAVED\n\n    def is_online(self) -&gt; bool:\n        return self is type(self).ONLINE\n\n    DEFAULT = NULL\n</code></pre>"},{"location":"reference/enums/#gd.enums.PortalType","title":"<code>PortalType</code>","text":"<p>         Bases: <code>Enum</code></p> <p>Represents portal object IDs.</p> Source code in <code>gd/enums.py</code> <pre><code>class PortalType(Enum):\n\"\"\"Represents portal object IDs.\"\"\"\n\n    CUBE = 12\n    SHIP = 13\n    BALL = 47\n    UFO = 111\n    WAVE = 660\n    ROBOT = 745\n    SPIDER = 1331\n\n    YELLOW_GRAVITY = 11\n    BLUE_GRAVITY = 10\n    YELLOW_MIRROR = 45\n    BLUE_MIRROR = 46\n    PINK_SIZE = 101\n    GREEN_SIZE = 99\n    YELLOW_DUAL = 286\n    BLUE_DUAL = 287\n    BLUE_TELEPORT = 747\n    YELLOW_TELEPORT = 749\n\n    @property\n    def id(self) -&gt; int:\n        return self.value\n</code></pre>"},{"location":"reference/enums/#gd.enums.SpeedChangeType","title":"<code>SpeedChangeType</code>","text":"<p>         Bases: <code>Enum</code></p> <p>Represents speed change object IDs.</p> Source code in <code>gd/enums.py</code> <pre><code>class SpeedChangeType(Enum):\n\"\"\"Represents speed change object IDs.\"\"\"\n\n    SLOW = 200\n    NORMAL = 201\n    FAST = 202\n    FASTER = 203\n    FASTEST = 1334\n\n    @property\n    def id(self) -&gt; int:\n        return self.value\n</code></pre>"},{"location":"reference/enums/#gd.enums.CoinType","title":"<code>CoinType</code>","text":"<p>         Bases: <code>Enum</code></p> <p>Represents coin object IDs.</p> Source code in <code>gd/enums.py</code> <pre><code>class CoinType(Enum):\n\"\"\"Represents coin object IDs.\"\"\"\n\n    SECRET = 142\n    USER = 1329\n\n    @property\n    def id(self) -&gt; int:\n        return self.value\n</code></pre>"},{"location":"reference/enums/#gd.enums.ItemType","title":"<code>ItemType</code>","text":"<p>         Bases: <code>Enum</code></p> <p>Represents pickup item object IDs.</p> Source code in <code>gd/enums.py</code> <pre><code>class ItemType(Enum):\n\"\"\"Represents pickup item object IDs.\"\"\"\n\n    KEY = 1275\n    HEART = 1587\n    BOTTLE = 1589\n    SKULL = 1598\n    COIN = 1614\n\n    @property\n    def id(self) -&gt; int:\n        return self.value\n</code></pre>"},{"location":"reference/enums/#gd.enums.RotatingObjectType","title":"<code>RotatingObjectType</code>","text":"<p>         Bases: <code>Enum</code></p> <p>Represents rotating object IDs.</p> Source code in <code>gd/enums.py</code> <pre><code>class RotatingObjectType(Enum):\n\"\"\"Represents rotating object IDs.\"\"\"\n\n    ID_85 = 85\n    ID_86 = 86\n    ID_87 = 87\n    ID_97 = 97\n\n    ID_137 = 137\n    ID_138 = 138\n    ID_139 = 139\n\n    ID_154 = 154\n    ID_155 = 155\n    ID_156 = 156\n\n    ID_180 = 180\n    ID_181 = 181\n    ID_182 = 182\n\n    ID_183 = 183\n    ID_184 = 184\n    ID_185 = 185\n\n    ID_186 = 186\n    ID_187 = 187\n    ID_188 = 188\n\n    ID_222 = 222\n    ID_223 = 223\n    ID_224 = 224\n\n    ID_375 = 375\n    ID_376 = 376\n    ID_377 = 377\n    ID_378 = 378\n\n    ID_394 = 394\n    ID_395 = 395\n    ID_396 = 396\n\n    ID_678 = 678\n    ID_679 = 679\n    ID_680 = 680\n\n    ID_740 = 740\n    ID_741 = 741\n    ID_742 = 742\n\n    ID_997 = 997\n    ID_998 = 998\n    ID_999 = 999\n    ID_1000 = 1000\n\n    ID_1019 = 1019\n    ID_1020 = 1020\n    ID_1021 = 1021\n\n    ID_1055 = 1055\n    ID_1056 = 1056\n    ID_1057 = 1057\n\n    ID_1058 = 1058\n    ID_1059 = 1059\n    ID_1060 = 1060\n    ID_1061 = 1061\n\n    ID_1521 = 1521\n    ID_1522 = 1522\n    ID_1523 = 1523\n    ID_1524 = 1524\n\n    ID_1525 = 1525\n    ID_1526 = 1526\n    ID_1527 = 1527\n    ID_1528 = 1528\n\n    ID_1582 = 1582\n\n    ID_1619 = 1619\n    ID_1620 = 1620\n\n    ID_1705 = 1705\n    ID_1706 = 1706\n    ID_1707 = 1707\n\n    ID_1708 = 1708\n    ID_1709 = 1709\n    ID_1710 = 1710\n\n    ID_1734 = 1734\n    ID_1735 = 1735\n    ID_1736 = 1736\n\n    ID_1752 = 1752\n\n    ID_1831 = 1831\n    ID_1832 = 1832\n\n    ID_1833 = 1833\n    ID_1834 = 1834\n\n    @property\n    def id(self) -&gt; int:\n        return self.value\n</code></pre>"},{"location":"reference/enums/#gd.enums.PulseTargetType","title":"<code>PulseTargetType</code>","text":"<p>         Bases: <code>Enum</code></p> <p>Represents pulse target types.</p> Source code in <code>gd/enums.py</code> <pre><code>class PulseTargetType(Enum):\n\"\"\"Represents pulse target types.\"\"\"\n\n    COLOR_CHANNEL = 0\n    GROUP = 1\n\n    DEFAULT = COLOR_CHANNEL\n\n    def is_color_channel(self) -&gt; bool:\n        return self is type(self).COLOR_CHANNEL\n\n    def is_group(self) -&gt; bool:\n        return self is type(self).GROUP\n</code></pre>"},{"location":"reference/enums/#gd.enums.PulsatingObjectType","title":"<code>PulsatingObjectType</code>","text":"<p>         Bases: <code>Enum</code></p> <p>Represents pulsating object IDs.</p> Source code in <code>gd/enums.py</code> <pre><code>class PulsatingObjectType(Enum):\n\"\"\"Represents pulsating object IDs.\"\"\"\n\n    OUTER_LARGE = 1839\n    OUTER_SMALL = 1840\n    INNER_LARGE = 1841\n    INNER_SMALL = 1842\n\n    @property\n    def id(self) -&gt; int:\n        return self.value\n</code></pre>"},{"location":"reference/enums/#gd.enums.PulseType","title":"<code>PulseType</code>","text":"<p>         Bases: <code>Flag</code></p> <p>Represents pulse types.</p> Source code in <code>gd/enums.py</code> <pre><code>class PulseType(Flag):\n\"\"\"Represents pulse types.\"\"\"\n\n    MAIN = 1\n    DETAIL = 2\n\n    BOTH = MAIN | DETAIL\n\n    DEFAULT = BOTH\n\n    def is_main_only(self) -&gt; bool:\n        return self is type(self).MAIN\n\n    def is_detail_only(self) -&gt; bool:\n        return self is type(self).DETAIL\n</code></pre>"},{"location":"reference/enums/#gd.enums.SpecialBlockType","title":"<code>SpecialBlockType</code>","text":"<p>         Bases: <code>Enum</code></p> <p>Represents special block (<code>D</code>, <code>J</code>, <code>S</code>, <code>H</code>) object IDs.</p> Source code in <code>gd/enums.py</code> <pre><code>class SpecialBlockType(Enum):\n\"\"\"Represents special block (`D`, `J`, `S`, `H`) object IDs.\"\"\"\n\n    D = 1755\n    J = 1813\n    S = 1829\n    H = 1859\n</code></pre>"},{"location":"reference/enums/#gd.enums.SpecialColorID","title":"<code>SpecialColorID</code>","text":"<p>         Bases: <code>Enum</code></p> <p>Represents special color IDs.</p> Source code in <code>gd/enums.py</code> <pre><code>class SpecialColorID(Enum):\n\"\"\"Represents special color IDs.\"\"\"\n\n    BACKGROUND = BG = 1000\n    GROUND = G = 1001\n    LINE = L = 1002\n    LINE_3D = L3D = 1003\n    OBJECT = OBJ = 1004\n    PLAYER_1 = P1 = 1005\n    PLAYER_2 = P2 = 1006\n    LIGHT_BACKGROUND = LBG = 1007\n    SECONDARY_GROUND = GROUND_2 = G2 = 1009\n    BLACK = 1010\n    WHITE = 1011\n    LIGHTER = 1012\n\n    @property\n    def id(self) -&gt; int:\n        return self.value\n</code></pre>"},{"location":"reference/enums/#gd.enums.TargetType","title":"<code>TargetType</code>","text":"<p>         Bases: <code>Flag</code></p> <p>Represents move target types.</p> Source code in <code>gd/enums.py</code> <pre><code>class TargetType(Flag):\n\"\"\"Represents move target types.\"\"\"\n\n    NONE = 0\n\n    X = 1\n    Y = 2\n\n    BOTH = X | Y\n\n    DEFAULT = NONE\n\n    def is_none(self) -&gt; bool:\n        return self is type(self).NONE\n\n    def into_simple_target_type(self) -&gt; SimpleTargetType:\n        return TARGET_TYPE_TO_SIMPLE_TARGET_TYPE[self]\n</code></pre>"},{"location":"reference/enums/#gd.enums.SimpleTargetType","title":"<code>SimpleTargetType</code>","text":"<p>         Bases: <code>Enum</code></p> <p>Represents simple move target types.</p> Source code in <code>gd/enums.py</code> <pre><code>class SimpleTargetType(Enum):\n\"\"\"Represents simple move target types.\"\"\"\n\n    BOTH = 0\n\n    X_ONLY = 1\n    Y_ONLY = 2\n\n    DEFAULT = BOTH\n\n    def into_target_type(self) -&gt; TargetType:\n        return SIMPLE_TARGET_TYPE_TO_TARGET_TYPE[self]\n</code></pre>"},{"location":"reference/enums/#gd.enums.TouchToggleMode","title":"<code>TouchToggleMode</code>","text":"<p>         Bases: <code>Enum</code></p> <p>Represents touch toggle modes.</p> Source code in <code>gd/enums.py</code> <pre><code>class TouchToggleMode(Enum):\n\"\"\"Represents touch toggle modes.\"\"\"\n\n    DEFAULT = 0\n    ON = 1\n    OFF = 2\n</code></pre>"},{"location":"reference/enums/#gd.enums.TriggerType","title":"<code>TriggerType</code>","text":"<p>         Bases: <code>Enum</code></p> <p>Represents trigger object IDs.</p> Source code in <code>gd/enums.py</code> <pre><code>class TriggerType(Enum):\n\"\"\"Represents trigger object IDs.\"\"\"\n\n    BACKGROUND = BG = 29\n    GROUND = G = 30\n    LINE = L = 104\n    OBJECT = OBJ = 105\n    COLOR_1 = C1 = 221\n    COLOR_2 = C2 = 717\n    COLOR_3 = C3 = 718\n    COLOR_4 = C4 = 743\n    LINE_3D = L3D = 744\n    COLOR = 899\n    SECONDARY_GROUND = GROUND_2 = G2 = 900\n    MOVE = 901\n    # LINE_2 = L2 = 915\n    PULSE = 1006\n    ALPHA = 1007\n    TOGGLE = 1049\n    SPAWN = 1268\n    ROTATE = 1346\n    FOLLOW = 1347\n    SHAKE = 1520\n    ANIMATE = 1585\n    TOUCH = 1595\n    COUNT = 1611\n    STOP = 1616\n    INSTANT_COUNT = 1811\n    ON_DEATH = 1812\n    FOLLOW_PLAYER_Y = 1814\n    COLLISION = 1815\n    PICKUP = 1817\n\n    @property\n    def id(self) -&gt; int:\n        return self.value\n</code></pre>"},{"location":"reference/enums/#gd.enums.Speed","title":"<code>Speed</code>","text":"<p>         Bases: <code>Enum</code></p> <p>Represents speed modifiers.</p> Source code in <code>gd/enums.py</code> <pre><code>class Speed(Enum):\n\"\"\"Represents speed modifiers.\"\"\"\n\n    NORMAL = 0\n    SLOW = 1\n    FAST = 2\n    FASTER = 3\n    FASTEST = 4\n\n    DEFAULT = NORMAL\n</code></pre>"},{"location":"reference/enums/#gd.enums.SpeedConstant","title":"<code>SpeedConstant</code>","text":"<p>         Bases: <code>float</code>, <code>Enum</code></p> <p>Represents actuall speed modifiers.</p> Source code in <code>gd/enums.py</code> <pre><code>class SpeedConstant(float, Enum):\n\"\"\"Represents actuall speed modifiers.\"\"\"\n\n    NULL = 0.0\n    SLOW = 0.7\n    NORMAL = 0.9\n    FAST = 1.1\n    FASTER = 1.3\n    FASTEST = 1.6\n</code></pre>"},{"location":"reference/enums/#gd.enums.SpeedMagic","title":"<code>SpeedMagic</code>","text":"<p>         Bases: <code>float</code>, <code>Enum</code></p> <p>Represents magic speed constants.</p> Source code in <code>gd/enums.py</code> <pre><code>class SpeedMagic(float, Enum):\n\"\"\"Represents *magic* speed constants.\"\"\"\n\n    SLOW = 251.16\n    NORMAL = 311.58\n    FAST = 387.42\n    FASTER = 468.0\n    FASTEST = 576.0\n    DEFAULT = NORMAL\n</code></pre>"},{"location":"reference/enums/#gd.enums.GuidelineColor","title":"<code>GuidelineColor</code>","text":"<p>         Bases: <code>float</code>, <code>Enum</code></p> <p>Represents guideline colors.</p> Source code in <code>gd/enums.py</code> <pre><code>class GuidelineColor(float, Enum):\n\"\"\"Represents guideline colors.\"\"\"\n\n    DEFAULT = 0.0\n    TRANSPARENT = 0.7\n    ORANGE = 0.8\n    YELLOW = 0.9\n    GREEN = 1.0\n\n    @classmethod\n    def _missing_(cls, value: Any) -&gt; GuidelineColor:  # type: ignore\n        if cls.ORANGE &lt; value &lt; cls.GREEN:\n            return cls.ORANGE\n\n        return cls.TRANSPARENT\n</code></pre>"},{"location":"reference/enums/#gd.enums.InternalType","title":"<code>InternalType</code>","text":"<p>         Bases: <code>Enum</code></p> <p>Represents internal types.</p> Source code in <code>gd/enums.py</code> <pre><code>class InternalType(Enum):\n\"\"\"Represents internal types.\"\"\"\n\n    LEVEL = 4\n    SONG = 6\n    QUEST = 7\n    REWARD_ITEM = 8\n    REWARD = 9\n</code></pre>"},{"location":"reference/enums/#gd.enums.Filter","title":"<code>Filter</code>","text":"<p>         Bases: <code>Enum</code></p> <p>Represents filter types.</p> Source code in <code>gd/enums.py</code> <pre><code>class Filter(Enum):\n\"\"\"Represents filter types.\"\"\"\n\n    NONE = 0\n    DETAIL = 1\n    STATIC = 2\n    CUSTOM = 3\n\n    DEFAULT = NONE\n\n    def is_none(self) -&gt; bool:\n        return self is type(self).NONE\n\n    def is_detail(self) -&gt; bool:\n        return self is type(self).DETAIL\n\n    def is_static(self) -&gt; bool:\n        return self is type(self).STATIC\n\n    def is_custom(self) -&gt; bool:\n        return self is type(self).CUSTOM\n\n    def is_default(self) -&gt; bool:\n        return self is type(self).DEFAULT\n</code></pre>"},{"location":"reference/enums/#gd.enums.ByteOrder","title":"<code>ByteOrder</code>","text":"<p>         Bases: <code>Enum</code></p> <p>Represents byte orders (used in binary protocols).</p> Source code in <code>gd/enums.py</code> <pre><code>class ByteOrder(Enum):\n\"\"\"Represents byte orders (used in binary protocols).\"\"\"\n\n    NATIVE = \"=\"\n    LITTLE = \"&lt;\"\n    BIG = \"&gt;\"\n\n    DEFAULT = LITTLE\n\n    def is_native(self) -&gt; bool:\n        return self is type(self).NATIVE\n\n    def is_little(self) -&gt; bool:\n        return self is type(self).LITTLE\n\n    def is_big(self) -&gt; bool:\n        return self is type(self).BIG\n\n    def is_default(self) -&gt; bool:\n        return self is type(self).DEFAULT\n</code></pre>"},{"location":"reference/enums/#gd.enums.Platform","title":"<code>Platform</code>","text":"<p>         Bases: <code>Enum</code></p> <p>Represents system platforms.</p> Source code in <code>gd/enums.py</code> <pre><code>class Platform(Enum):\n\"\"\"Represents system platforms.\"\"\"\n\n    UNKNOWN = 0\n\n    ANDROID = 1\n    DARWIN = 2\n    LINUX = 3\n    WINDOWS = 4\n\n    DEFAULT = UNKNOWN\n\n    def is_unknown(self) -&gt; bool:\n        return self is type(self).UNKNOWN\n\n    def is_android(self) -&gt; bool:\n        return self is type(self).ANDROID\n\n    def is_darwin(self) -&gt; bool:\n        return self is type(self).DARWIN\n\n    def is_linux(self) -&gt; bool:\n        return self is type(self).LINUX\n\n    def is_windows(self) -&gt; bool:\n        return self is type(self).WINDOWS\n</code></pre>"},{"location":"reference/enums/#gd.enums.Orientation","title":"<code>Orientation</code>","text":"<p>         Bases: <code>Enum</code></p> <p>Represents orientations.</p> Source code in <code>gd/enums.py</code> <pre><code>class Orientation(Enum):\n\"\"\"Represents orientations.\"\"\"\n\n    HORIZONTAL = 0\n    VERTICAL = 1\n\n    DEFAULT = HORIZONTAL\n\n    def is_horizontal(self) -&gt; bool:\n        return self is type(self).HORIZONTAL\n\n    def is_vertical(self) -&gt; bool:\n        return self is type(self).VERTICAL\n</code></pre>"},{"location":"reference/enums/#gd.enums.ResponseType","title":"<code>ResponseType</code>","text":"<p>         Bases: <code>Enum</code></p> <p>Represents response types.</p> Source code in <code>gd/enums.py</code> <pre><code>class ResponseType(Enum):\n\"\"\"Represents response types.\"\"\"\n\n    BYTES = 0\n    TEXT = 1\n    JSON = 2\n\n    DEFAULT = TEXT\n</code></pre>"},{"location":"reference/enums/#gd.enums.CollectedCoins","title":"<code>CollectedCoins</code>","text":"<p>         Bases: <code>Flag</code></p> <p>Represents collected coins.</p> Source code in <code>gd/enums.py</code> <pre><code>class CollectedCoins(Flag):\n\"\"\"Represents collected coins.\"\"\"\n\n    NONE = 0\n\n    FIRST = 1\n    SECOND = 2\n    THIRD = 4\n\n    ALL = FIRST | SECOND | THIRD\n\n    DEFAULT = NONE\n\n    def first(self) -&gt; bool:\n        return type(self).FIRST in self\n\n    def second(self) -&gt; bool:\n        return type(self).SECOND in self\n\n    def third(self) -&gt; bool:\n        return type(self).THIRD in self\n\n    def all(self) -&gt; bool:\n        return type(self).ALL in self\n</code></pre>"},{"location":"reference/enums/#gd.enums.Quality","title":"<code>Quality</code>","text":"<p>         Bases: <code>Enum</code></p> <p>Represents quality settings.</p> Source code in <code>gd/enums.py</code> <pre><code>class Quality(Enum):\n\"\"\"Represents quality settings.\"\"\"\n\n    AUTO = 0\n    LOW = 1\n    MEDIUM = 2\n    HIGH = 3\n\n    DEFAULT = AUTO\n</code></pre>"},{"location":"reference/enums/#gd.enums.Permissions","title":"<code>Permissions</code>","text":"<p>         Bases: <code>Flag</code></p> <p>Represents permissions.</p> Source code in <code>gd/enums.py</code> <pre><code>class Permissions(Flag):\n\"\"\"Represents permissions.\"\"\"\n\n    NONE = 0\n\n    EXECUTE = 1\n    WRITE = 2\n    READ = 4\n\n    ALL = EXECUTE | WRITE | READ\n\n    DEFAULT = ALL\n</code></pre>"},{"location":"reference/song/","title":"Song","text":""},{"location":"reference/song/#gd.song.Song","title":"<code>Song</code>","text":"<p>         Bases: <code>Entity</code></p> <p>Represents Geometry Dash and Newgrounds songs.</p> Binary <pre><code>const CUSTOM_BIT: u8 = 1 &lt;&lt; 0;\nconst HAS_SIZE_BIT: u8 = 1 &lt;&lt; 1;\nconst HAS_DOWNLOAD_URL_BIT: u8 = 1 &lt;&lt; 2;\n\nstruct DownloadURL {\nlength: u16,\nurl: [u8; length],  // utf-8 string\n}\n\nstruct Song {\nvalue: u8,  // contains `custom`, `has_size` and `has_download_url`\nid: u32,\nname_length: u8,\nname: [u8; name_length],  // utf-8 string\nartist: Artist,\nsize: Option&lt;f32&gt;,  // if `has_size`\ndownload_url: Option&lt;DownloadURL&gt;,  // if `has_download_url`\n}\n</code></pre> Source code in <code>gd/song.py</code> <pre><code>@register_unstructure_hook_omit_client\n@define()\nclass Song(Entity):\n\"\"\"Represents *Geometry Dash* and *Newgrounds* songs.\n\n    Binary:\n\n        ```rust\n        const CUSTOM_BIT: u8 = 1 &lt;&lt; 0;\n        const HAS_SIZE_BIT: u8 = 1 &lt;&lt; 1;\n        const HAS_DOWNLOAD_URL_BIT: u8 = 1 &lt;&lt; 2;\n\n        struct DownloadURL {\n            length: u16,\n            url: [u8; length],  // utf-8 string\n        }\n\n        struct Song {\n            value: u8,  // contains `custom`, `has_size` and `has_download_url`\n            id: u32,\n            name_length: u8,\n            name: [u8; name_length],  // utf-8 string\n            artist: Artist,\n            size: Option&lt;f32&gt;,  // if `has_size`\n            download_url: Option&lt;DownloadURL&gt;,  // if `has_download_url`\n        }\n        ```\n    \"\"\"\n\n    name: str = field(eq=False)\n\n    artist: Artist = field(eq=False)\n\n    custom: bool = field(eq=False)\n\n    size: Optional[float] = field(default=None, eq=False)\n\n    download_url: Optional[URL] = field(default=None, eq=False)\n\n    def __hash__(self) -&gt; int:\n        return hash(type(self)) ^ self.id\n\n    @property\n    def url(self) -&gt; URL:\n        return URL(NEWGROUNDS_SONG.format(self.id))\n\n    @classmethod\n    def from_data(cls: Type[S], data: SongData) -&gt; S:  # type: ignore\n        return CONVERTER.structure(data, cls)\n\n    def into_data(self) -&gt; SongData:\n        return CONVERTER.unstructure(self)  # type: ignore\n\n    @classmethod\n    def from_binary(\n        cls: Type[S],\n        binary: BinaryReader,\n        order: ByteOrder = ByteOrder.DEFAULT,\n        version: int = VERSION,\n        encoding: str = DEFAULT_ENCODING,\n        errors: str = DEFAULT_ERRORS,\n    ) -&gt; S:\n        rounding = DEFAULT_ROUNDING\n\n        reader = Reader(binary, order)\n\n        song_flag_value = reader.read_u8()\n\n        song_flag = SongFlag(song_flag_value)\n\n        id = reader.read_u32()\n\n        custom = song_flag.is_custom()\n\n        name_length = reader.read_u8()\n\n        name = reader.read(name_length).decode(encoding, errors)\n\n        artist = Artist.from_binary(binary, order, version, encoding, errors)\n\n        if song_flag.has_size():\n            size = round(reader.read_f32(), rounding)\n\n        else:\n            size = None\n\n        if song_flag.has_download_url():\n            download_url_length = reader.read_u16()\n\n            download_url_string = reader.read(download_url_length).decode(encoding, errors)\n\n            download_url = URL(download_url_string)\n\n        else:\n            download_url = None\n\n        return cls(\n            id=id, custom=custom, name=name, artist=artist, size=size, download_url=download_url\n        )\n\n    def to_binary(\n        self,\n        binary: BinaryWriter,\n        order: ByteOrder = ByteOrder.DEFAULT,\n        version: int = VERSION,\n        encoding: str = DEFAULT_ENCODING,\n        errors: str = DEFAULT_ERRORS,\n    ) -&gt; None:\n        writer = Writer(binary, order)\n\n        song_flag = SongFlag.SIMPLE\n\n        if self.is_custom():\n            song_flag |= SongFlag.CUSTOM\n\n        size = self.size\n\n        if size is not None:\n            song_flag |= SongFlag.SIZE\n\n        download_url = self.download_url\n\n        if download_url is not None:\n            song_flag |= SongFlag.DOWNLOAD_URL\n\n        writer.write_u8(song_flag.value)\n\n        writer.write_u32(self.id)\n\n        data = self.name.encode(encoding, errors)\n\n        writer.write_u8(len(data))\n\n        writer.write(data)\n\n        self.artist.to_binary(binary, order, version, encoding, errors)\n\n        if size is not None:\n            writer.write_f32(size)\n\n        if download_url is not None:\n            data = dump_url(download_url).encode(encoding, errors)\n\n            writer.write_u16(len(data))\n\n            writer.write(data)\n\n    @classmethod\n    def default(\n        cls: Type[S],\n        id: int = DEFAULT_ID,\n        artist_id: int = DEFAULT_ID,\n        custom: bool = DEFAULT_CUSTOM,\n    ) -&gt; S:\n        return cls(id=id, name=EMPTY, artist=Artist.default(artist_id), custom=custom)\n\n    @classmethod\n    def official(cls: Type[S], id: Optional[int] = None, name: Optional[str] = None) -&gt; S:\n        if id is None:\n            if name is None:\n                raise ValueError(EXPECTED_QUERY)\n\n            else:\n                official_song = NAME_TO_OFFICIAL_SONG.get(name)\n\n                if official_song is None:\n                    official_song = OfficialSong.default(name=name)\n\n        else:\n            official_song = ID_TO_OFFICIAL_SONG.get(id)\n\n            if official_song is None:\n                official_song = OfficialSong.default(id=id)\n\n        return cls(\n            id=official_song.id,\n            custom=False,\n            name=official_song.name,\n            artist=Artist.name_only(official_song.artist_name),\n        )\n\n    @classmethod\n    def from_model(cls: Type[S], model: SongModel) -&gt; S:\n        return cls(\n            id=model.id,\n            custom=True,\n            name=model.name,\n            artist=Artist(\n                model.artist_id,\n                model.artist_name,\n                model.is_artist_verified(),\n            ),\n            size=model.size or None,\n            download_url=model.download_url,\n        )\n\n    def __str__(self) -&gt; str:\n        return self.name or UNKNOWN\n\n    def is_custom(self) -&gt; bool:\n        return self.custom\n\n    async def get(self, from_newgrounds: bool = DEFAULT_FROM_NEWGROUNDS) -&gt; Song:\n        if self.is_custom():\n            if from_newgrounds:\n                return await self.client.get_newgrounds_song(self.id)\n\n            else:\n                return await self.client.get_song(self.id)\n\n        raise MissingAccess(CAN_NOT_GET)\n\n    async def update(self: S, from_newgrounds: bool = DEFAULT_FROM_NEWGROUNDS) -&gt; S:\n        return self.update_from(await self.get(from_newgrounds=from_newgrounds))\n\n    async def ensure_download_url(self) -&gt; None:\n        download_url = self.download_url\n\n        if download_url is None:\n            await self.update(from_newgrounds=True)\n\n        download_url = self.download_url\n\n        if download_url is None:\n            raise MissingAccess(CAN_NOT_FIND_URL)\n\n    async def download(self, file: BinaryIO, with_bar: bool = DEFAULT_WITH_BAR) -&gt; None:\n        if self.is_custom():\n            await self.ensure_download_url()\n\n            await self.client.http.download(\n                file, self.download_url, with_bar=with_bar  # type: ignore\n            )\n\n        else:\n            raise MissingAccess(CAN_NOT_DOWNLOAD)\n\n    async def download_bytes(self, with_bar: bool = DEFAULT_WITH_BAR) -&gt; bytes:\n        if self.is_custom():\n            await self.ensure_download_url()\n\n            return await self.client.http.download_bytes(\n                self.download_url, with_bar=with_bar  # type: ignore\n            )\n\n        raise MissingAccess(CAN_NOT_DOWNLOAD)\n\n    async def download_to(self, path: IntoPath, with_bar: bool = DEFAULT_WITH_BAR) -&gt; None:\n        if self.is_custom():\n            await self.ensure_download_url()\n\n            await self.client.http.download_to(\n                path, self.download_url, with_bar=with_bar  # type: ignore\n            )\n\n        else:\n            raise MissingAccess(CAN_NOT_DOWNLOAD)\n</code></pre>"},{"location":"reference/tasks/","title":"Tasks","text":"<p>Task loops, adapted from the <code>discord.py</code> library.</p>"},{"location":"reference/tasks/#gd.tasks.ExponentialBackoff","title":"<code>ExponentialBackoff</code>","text":"<p>Implements the exponential backoff algorithm.</p> <p>Provides a convenient interface to implement an exponential backoff for reconnecting or retrying transmissions in a distributed network.</p> <p>Once instantiated, the delay method will return the next interval to wait for when retrying a connection or transmission. The maximum delay increases exponentially with each retry up to a maximum of \\(m \\cdot b^l\\) (where \\(m\\) is <code>multiply</code>, \\(b\\) is <code>base</code> and \\(l\\) is <code>limit</code>), and is reset if no more attempts are needed in a period of \\(m \\cdot b^{l + 1}\\) seconds.</p> Source code in <code>gd/tasks.py</code> <pre><code>@define()\nclass ExponentialBackoff:\n\"\"\"Implements the *exponential backoff* algorithm.\n\n    Provides a convenient interface to implement an exponential backoff\n    for reconnecting or retrying transmissions in a distributed network.\n\n    Once instantiated, the delay method will return the next interval to\n    wait for when retrying a connection or transmission. The maximum\n    delay increases exponentially with each retry up to a maximum of\n    $m \\\\cdot b^l$ (where $m$ is `multiply`, $b$ is `base` and $l$ is `limit`),\n    and is reset if no more attempts are needed in a period of $m \\\\cdot b^{l + 1}$ seconds.\n    \"\"\"\n\n    multiply: float = field(default=DEFAULT_MULTIPLY)\n    base: float = field(default=DEFAULT_BASE)\n    limit: int = field(default=DEFAULT_LIMIT)\n\n    _clock: Clock = field(default=clock)\n\n    _exponent: int = field(default=0, init=False)\n    _last_called: float = field(init=False)\n    _reset_delta: float = field(init=False)\n\n    @_last_called.default\n    def default_last_called(self) -&gt; float:\n        return self._clock()\n\n    @_reset_delta.default\n    def default_reset_delta(self) -&gt; float:\n        return self.multiply * pow(self.base, self.limit + 1)\n\n    def delay(self) -&gt; float:\n\"\"\"Computes the next delay.\n\n        Returns the next delay to wait according to the exponential\n        backoff algorithm. This is a value between $0$ and $m \\\\cdot b^e$\n        where $e$ (`exponent`) starts off at $0$ and is incremented at every\n        invocation of this method up to a maximum of $l$ (`limit`).\n\n        If a period of more than $m \\\\cdot b^{l + 1}$ has passed since the last\n        retry, the `exponent` ($e$) is reset to $0$.\n        \"\"\"\n        called = self._clock()\n\n        interval = called - self._last_called\n        self._last_called = called\n\n        if interval &gt; self._reset_delta:\n            self._exponent = 0\n\n        if self._exponent &lt; self.limit:\n            self._exponent += 1\n\n        return uniform_to(self.multiply * pow(self.base, self._exponent))\n</code></pre>"},{"location":"reference/tasks/#gd.tasks.ExponentialBackoff.delay","title":"<code>delay() -&gt; float</code>","text":"<p>Computes the next delay.</p> <p>Returns the next delay to wait according to the exponential backoff algorithm. This is a value between \\(0\\) and \\(m \\cdot b^e\\) where \\(e\\) (<code>exponent</code>) starts off at \\(0\\) and is incremented at every invocation of this method up to a maximum of \\(l\\) (<code>limit</code>).</p> <p>If a period of more than \\(m \\cdot b^{l + 1}\\) has passed since the last retry, the <code>exponent</code> (\\(e\\)) is reset to \\(0\\).</p> Source code in <code>gd/tasks.py</code> <pre><code>def delay(self) -&gt; float:\n\"\"\"Computes the next delay.\n\n    Returns the next delay to wait according to the exponential\n    backoff algorithm. This is a value between $0$ and $m \\\\cdot b^e$\n    where $e$ (`exponent`) starts off at $0$ and is incremented at every\n    invocation of this method up to a maximum of $l$ (`limit`).\n\n    If a period of more than $m \\\\cdot b^{l + 1}$ has passed since the last\n    retry, the `exponent` ($e$) is reset to $0$.\n    \"\"\"\n    called = self._clock()\n\n    interval = called - self._last_called\n    self._last_called = called\n\n    if interval &gt; self._reset_delta:\n        self._exponent = 0\n\n    if self._exponent &lt; self.limit:\n        self._exponent += 1\n\n    return uniform_to(self.multiply * pow(self.base, self._exponent))\n</code></pre>"},{"location":"reference/tasks/#gd.tasks.Loop","title":"<code>Loop</code>","text":"<p>         Bases: <code>Generic[P]</code></p> <p>Abstracts away event loop handling and reconnection logic.</p> <p>The main interface to create this is through <code>loop</code>.</p> Source code in <code>gd/tasks.py</code> <pre><code>@define()\nclass Loop(Generic[P]):\n\"\"\"Abstracts away event loop handling and reconnection logic.\n\n    The main interface to create this is through [`loop`][gd.tasks.loop].\n    \"\"\"\n\n    function: AsyncCallable[P, None] = field()\n\n    delay: float = field(default=DEFAULT_DELAY)\n\n    count: Optional[int] = field(default=None)\n\n    reconnect: bool = field(default=DEFAULT_RECONNECT)\n\n    _task: Optional[Task[None]] = field(default=None, init=False)\n\n    _current_count: int = field(default=0, init=False)\n\n    _error_types: AnyErrorTypes = field(\n        default=(OSError, GDError, ClientError, TimeoutError),\n        init=False,\n    )\n\n    _is_being_cancelled: bool = field(default=False, init=False)\n    _has_failed: bool = field(default=False, init=False)\n    _stop_next_iteration: bool = field(default=False, init=False)\n\n    _injected: Optional[Any] = field(default=None, init=False)\n\n    _before_loop: Optional[LoopFunction[Any]] = field(default=None, init=False)\n    _after_loop: Optional[LoopFunction[Any]] = field(default=None, init=False)\n\n    async def _call_before_loop(self) -&gt; None:\n        before_loop = self._before_loop\n\n        if before_loop is None:\n            return\n\n        injected = self._injected\n\n        if injected is None:\n            await before_loop()  # type: ignore\n\n        else:\n            await before_loop(injected)  # type: ignore\n\n    async def _call_after_loop(self) -&gt; None:\n        after_loop = self._after_loop\n\n        if after_loop is None:\n            return\n\n        injected = self._injected\n\n        if injected is None:\n            await after_loop()  # type: ignore\n\n        else:\n            await after_loop(injected)  # type: ignore\n\n    async def _loop(self, *args: P.args, **kwargs: P.kwargs) -&gt; None:\n        backoff = ExponentialBackoff()\n\n        await self._call_before_loop()\n\n        try:\n            while True:\n                try:\n                    await self.function(*args, **kwargs)\n\n                except self._error_types:\n                    if not self.reconnect:\n                        raise\n\n                    await sleep(backoff.delay())\n\n                else:\n                    if self._stop_next_iteration:\n                        return\n\n                    self._current_count += 1\n\n                    if self._current_count == self.count:\n                        break\n\n                    await sleep(self.delay)\n\n        except CancelledError:\n            self._is_being_cancelled = True\n\n            raise\n\n        except NormalError:\n            self._has_failed = True\n\n            raise\n\n        finally:\n            await self._call_after_loop()\n\n            self._current_count = 0\n\n            self._is_being_cancelled = False\n            self._has_failed = False\n            self._stop_next_iteration = False\n\n    def __get__(self: L, instance: Optional[S], type: Optional[Type[S]] = None) -&gt; L:\n        if instance is None:\n            return self\n\n        self._injected = instance\n\n        return self\n\n    @property\n    def current_count(self) -&gt; int:\n        return self._current_count\n\n    def start(self, *args: Any, **kwargs: Any) -&gt; Task[None]:\n        task = self._task\n\n        if task is not None and not task.done():\n            raise RuntimeError(TASK_ALREADY_LAUNCHED)\n\n        injected = self._injected\n\n        if injected is not None:\n            args = (injected, *args)\n\n        self._task = task = get_event_loop().create_task(self._loop(*args, **kwargs))\n\n        return task\n\n    def stop(self) -&gt; None:\n        task = self._task\n\n        if task is not None and not task.done():\n            self._stop_next_iteration = True\n\n    @property\n    def _can_be_cancelled(self) -&gt; bool:\n        task = self._task\n\n        return not self._is_being_cancelled and task is not None and not task.done()\n\n    def cancel(self) -&gt; None:\n        if self._can_be_cancelled:\n            self._task.cancel()  # type: ignore\n\n    def restart(self, *args: Any, **kwargs: Any) -&gt; None:\n        def restart_when_over(\n            task: Task[None],\n            *,\n            args: DynamicTuple[Any] = args,\n            kwargs: StringDict[Any] = kwargs,\n        ) -&gt; None:\n            self._task.remove_done_callback(restart_when_over)  # type: ignore\n            self.start(*args, **kwargs)\n\n        if self._can_be_cancelled:\n            self._task.add_done_callback(restart_when_over)  # type: ignore\n            self._task.cancel()  # type: ignore\n\n    def add_error_type(self, error_type: AnyErrorType) -&gt; None:\n        self._error_types = (*self._error_types, error_type)\n\n    def clear_error_types(self) -&gt; None:\n        self._error_types = ()\n\n    def remove_error_type(self, error_type: AnyErrorType) -&gt; bool:\n        error_types = self._error_types\n\n        length = len(error_types)\n\n        self._error_types = error_types = tuple(\n            present_error_type\n            for present_error_type in error_types\n            if present_error_type is not error_type\n        )\n\n        return len(error_types) &lt; length\n\n    def is_being_cancelled(self) -&gt; bool:\n        return self._is_being_cancelled\n\n    def has_failed(self) -&gt; bool:\n        return self._has_failed\n\n    def before_loop(self, loop_function: F) -&gt; F:\n        self._before_loop = loop_function\n\n        return loop_function\n\n    def after_loop(self, loop_function: F) -&gt; F:\n        self._after_loop = loop_function\n\n        return loop_function\n</code></pre>"},{"location":"reference/api/color_channels/","title":"Color Channels","text":""},{"location":"reference/api/color_channels/#gd.api.color_channels.BaseColorChannel","title":"<code>BaseColorChannel</code>","text":"<p>         Bases: <code>Binary</code>, <code>RobTop</code></p> <p>Represents base color channels.</p> Source code in <code>gd/api/color_channels.py</code> <pre><code>@define()\nclass BaseColorChannel(Binary, RobTop):\n\"\"\"Represents base color channels.\"\"\"\n\n    id: int\n\n    @classmethod\n    def from_robtop(cls: Type[BCC], string: str) -&gt; BCC:\n        return cls.from_robtop_data(split_color_channel(string))\n\n    @classmethod\n    def from_robtop_data(cls: Type[BCC], data: Mapping[int, str]) -&gt; BCC:\n        id = parse_get_or(int, DEFAULT_ID, data.get(ID))\n\n        if not id:\n            raise ValueError(COLOR_CHANNEL_ID_NOT_PRESENT)\n\n        return cls(id=id)\n\n    def to_robtop(self) -&gt; str:\n        return concat_color_channel(self.to_robtop_data())\n\n    def to_robtop_data(self) -&gt; Dict[int, str]:\n        data = {ID: str(self.id)}\n\n        return data\n\n    @classmethod\n    def from_binary(\n        cls: Type[BCC],\n        binary: BinaryReader,\n        order: ByteOrder = ByteOrder.DEFAULT,\n        version: int = VERSION,\n    ) -&gt; BCC:\n        reader = Reader(binary, order)\n\n        id = reader.read_u16()\n\n        return cls(id=id)\n\n    def to_binary(\n        self, binary: BinaryWriter, order: ByteOrder = ByteOrder.DEFAULT, version: int = VERSION\n    ) -&gt; None:\n        writer = Writer(binary, order)\n\n        writer.write_u16(self.id)\n\n    def is_player(self) -&gt; bool:\n        return False\n\n    def is_normal(self) -&gt; bool:\n        return False\n\n    def is_copied(self) -&gt; bool:\n        return False\n</code></pre>"},{"location":"reference/api/color_channels/#gd.api.color_channels.PlayerColorChannel","title":"<code>PlayerColorChannel</code>","text":"<p>         Bases: <code>BaseColorChannel</code></p> <p>Represents player color channels.</p> Source code in <code>gd/api/color_channels.py</code> <pre><code>@define()\nclass PlayerColorChannel(BaseColorChannel):\n\"\"\"Represents player color channels.\"\"\"\n\n    player_color: PlayerColor\n\n    opacity: float = DEFAULT_OPACITY\n    blending: bool = DEFAULT_BLENDING\n\n    def is_blending(self) -&gt; bool:\n        return self.blending\n\n    @classmethod\n    def from_robtop_data(cls: Type[PCC], data: Mapping[int, str]) -&gt; PCC:\n        id = parse_get_or(int, DEFAULT_ID, data.get(ID))\n\n        if not id:\n            raise ValueError(COLOR_CHANNEL_ID_NOT_PRESENT)\n\n        default_player_color_value = DEFAULT_PLAYER_COLOR_VALUE\n\n        player_color_value = max(\n            parse_get_or(int, default_player_color_value, data.get(PLAYER_COLOR)),\n            default_player_color_value,\n        )\n\n        player_color = PlayerColor(player_color_value)\n\n        opacity = parse_get_or(float, DEFAULT_OPACITY, data.get(OPACITY))\n\n        blending = parse_get_or(int_bool, DEFAULT_BLENDING, data.get(BLENDING))\n\n        return cls(id=id, player_color=player_color, opacity=opacity, blending=blending)\n\n    def to_robtop_data(self) -&gt; Dict[int, str]:\n        data = super().to_robtop_data()\n\n        actual = {\n            PLAYER_COLOR: str(self.player_color.value),\n            OPACITY: float_str(self.opacity),\n            OPACITY_TOGGLED: bool_str(DEFAULT_OPACITY_TOGGLED),\n        }\n\n        data.update(actual)\n\n        blending = self.is_blending()\n\n        if blending:\n            data[BLENDING] = bool_str(blending)\n\n        return data\n\n    @classmethod\n    def from_binary(\n        cls: Type[PCC],\n        binary: BinaryReader,\n        order: ByteOrder = ByteOrder.DEFAULT,\n        version: int = VERSION,\n    ) -&gt; PCC:\n        rounding = DEFAULT_ROUNDING\n\n        blending_bit = BLENDING_BIT\n\n        reader = Reader(binary, order)\n\n        id = reader.read_u16()\n\n        value = reader.read_u8()\n\n        blending = value &amp; blending_bit == blending_bit\n\n        player_color_value = (value &amp; PLAYER_COLOR_MASK) &gt;&gt; PLAYER_COLOR_SHIFT\n\n        player_color = PlayerColor(player_color_value)\n\n        opacity = round(reader.read_f32(), rounding)\n\n        return cls(id=id, blending=blending, player_color=player_color, opacity=opacity)\n\n    def to_binary(\n        self,\n        binary: BinaryWriter,\n        order: ByteOrder = ByteOrder.DEFAULT,\n        version: int = VERSION,\n    ) -&gt; None:\n        super().to_binary(binary, order, version)\n\n        writer = Writer(binary, order)\n\n        value = 0\n\n        if self.is_blending():\n            value |= BLENDING_BIT\n\n        value |= self.player_color.value &lt;&lt; PLAYER_COLOR_SHIFT\n\n        writer.write_u8(value)\n\n        writer.write_f32(self.opacity)\n\n    def is_player(self) -&gt; bool:\n        return True\n</code></pre>"},{"location":"reference/api/color_channels/#gd.api.color_channels.NormalColorChannel","title":"<code>NormalColorChannel</code>","text":"<p>         Bases: <code>BaseColorChannel</code></p> <p>Represents normal color channels.</p> Source code in <code>gd/api/color_channels.py</code> <pre><code>@define()\nclass NormalColorChannel(BaseColorChannel):\n\"\"\"Represents normal color channels.\"\"\"\n\n    color: Color\n\n    opacity: float = DEFAULT_OPACITY\n    blending: bool = DEFAULT_BLENDING\n\n    def is_blending(self) -&gt; bool:\n        return self.blending\n\n    @classmethod\n    def from_robtop_data(cls: Type[NCC], data: Mapping[int, str]) -&gt; NCC:\n        id = parse_get_or(int, DEFAULT_ID, data.get(ID))\n\n        if not id:\n            raise ValueError(COLOR_CHANNEL_ID_NOT_PRESENT)\n\n        red = parse_get_or(int, DEFAULT_RED, data.get(RED))\n        green = parse_get_or(int, DEFAULT_GREEN, data.get(GREEN))\n        blue = parse_get_or(int, DEFAULT_BLUE, data.get(BLUE))\n\n        color = Color.from_rgb(red, green, blue)\n\n        opacity = parse_get_or(float, DEFAULT_OPACITY, data.get(OPACITY))\n\n        blending = parse_get_or(int_bool, DEFAULT_BLENDING, data.get(BLENDING))\n\n        return cls(id=id, color=color, opacity=opacity, blending=blending)\n\n    def to_robtop_data(self) -&gt; Dict[int, str]:\n        data = super().to_robtop_data()\n\n        color = self.color\n\n        actual = {\n            RED: str(color.red),\n            GREEN: str(color.green),\n            BLUE: str(color.blue),\n            OPACITY: float_str(self.opacity),\n            OPACITY_TOGGLED: bool_str(DEFAULT_OPACITY_TOGGLED),\n        }\n\n        data.update(actual)\n\n        blending = self.is_blending()\n\n        if blending:\n            data[BLENDING] = bool_str(blending)\n\n        return data\n\n    @classmethod\n    def from_binary(\n        cls: Type[NCC],\n        binary: BinaryReader,\n        order: ByteOrder = ByteOrder.DEFAULT,\n        version: int = VERSION,\n    ) -&gt; NCC:\n        rounding = DEFAULT_ROUNDING\n\n        blending_bit = BLENDING_BIT\n\n        reader = Reader(binary, order)\n\n        id = reader.read_u16()\n\n        value = reader.read_u32()\n\n        blending = value &amp; blending_bit == blending_bit\n\n        value &gt;&gt;= BITS\n\n        color = Color(value)\n\n        opacity = round(reader.read_f32(), rounding)\n\n        return cls(id=id, color=color, opacity=opacity, blending=blending)\n\n    def to_binary(\n        self,\n        binary: BinaryWriter,\n        order: ByteOrder = ByteOrder.DEFAULT,\n        version: int = VERSION,\n    ) -&gt; None:\n        super().to_binary(binary, order, version)\n\n        writer = Writer(binary, order)\n\n        value = 0\n\n        if self.is_blending():\n            value |= BLENDING_BIT\n\n        value |= self.color.value &lt;&lt; BITS\n\n        writer.write_u32(value)\n\n        writer.write_f32(self.opacity)\n\n    def is_normal(self) -&gt; bool:\n        return True\n</code></pre>"},{"location":"reference/api/color_channels/#gd.api.color_channels.CopiedColorChannel","title":"<code>CopiedColorChannel</code>","text":"<p>         Bases: <code>BaseColorChannel</code></p> <p>Represents copied color channels.</p> Source code in <code>gd/api/color_channels.py</code> <pre><code>@define()\nclass CopiedColorChannel(BaseColorChannel):\n\"\"\"Represents copied color channels.\"\"\"\n\n    copied_id: int = field()\n\n    hsv: HSV = field(factory=HSV)\n\n    opacity: Optional[float] = field(default=None)\n\n    blending: bool = field(default=DEFAULT_BLENDING)\n\n    def is_blending(self) -&gt; bool:\n        return self.blending\n\n    @classmethod\n    def from_robtop_data(cls: Type[CCC], data: Mapping[int, str]) -&gt; CCC:\n        id = parse_get_or(int, DEFAULT_ID, data.get(ID))\n\n        if not id:\n            raise ValueError(COLOR_CHANNEL_ID_NOT_PRESENT)\n\n        copied_id = parse_get_or(int, DEFAULT_ID, data.get(COPIED_ID))\n\n        if not copied_id:\n            raise ValueError(COLOR_CHANNEL_COPIED_ID_NOT_PRESENT)\n\n        hsv = parse_get_or_else(HSV.from_robtop, HSV, data.get(COLOR_HSV))\n\n        copy_opacity = parse_get_or(int_bool, DEFAULT_COPY_OPACITY, data.get(COPY_OPACITY))\n\n        if copy_opacity:\n            opacity = None\n\n        else:\n            opacity = parse_get_or(float, DEFAULT_OPACITY, data.get(OPACITY))\n\n        blending = parse_get_or(int_bool, DEFAULT_BLENDING, data.get(BLENDING))\n\n        return cls(id=id, copied_id=copied_id, hsv=hsv, opacity=opacity, blending=blending)\n\n    def to_robtop_data(self) -&gt; Dict[int, str]:\n        data = super().to_robtop_data()\n\n        actual = {\n            COPIED_ID: str(self.copied_id),\n            COLOR_HSV: self.hsv.to_robtop(),\n            COPY_OPACITY: bool_str(self.is_copy_opacity()),\n            OPACITY_TOGGLED: bool_str(DEFAULT_OPACITY_TOGGLED),\n        }\n\n        data.update(actual)\n\n        opacity = self.opacity\n\n        if opacity is not None:\n            data[OPACITY] = float_str(opacity)\n\n        blending = self.is_blending()\n\n        if blending:\n            data[BLENDING] = bool_str(blending)\n\n        return data\n\n    @classmethod\n    def from_binary(\n        cls: Type[CCC],\n        binary: BinaryReader,\n        order: ByteOrder = ByteOrder.DEFAULT,\n        version: int = VERSION,\n    ) -&gt; CCC:\n        rounding = DEFAULT_ROUNDING\n\n        blending_bit = BLENDING_BIT\n        copy_opacity_bit = COPY_OPACITY_BIT\n\n        reader = Reader(binary, order)\n\n        id = reader.read_u16()\n\n        copied_id = reader.read_u16()\n\n        value = reader.read_u8()\n\n        blending = value &amp; blending_bit == blending_bit\n        copy_opacity = value &amp; copy_opacity_bit == copy_opacity_bit\n\n        hsv = HSV.from_binary(binary, order, version)\n\n        if copy_opacity:\n            opacity = None\n\n        else:\n            opacity = round(reader.read_f32(), rounding)\n\n        return cls(id=id, copied_id=copied_id, blending=blending, hsv=hsv, opacity=opacity)\n\n    def to_binary(\n        self,\n        binary: BinaryWriter,\n        order: ByteOrder = ByteOrder.DEFAULT,\n        version: int = VERSION,\n    ) -&gt; None:\n        super().to_binary(binary, order, version)\n\n        writer = Writer(binary, order)\n\n        writer.write_u16(self.copied_id)\n\n        value = 0\n\n        if self.is_blending():\n            value |= BLENDING_BIT\n\n        if self.is_copy_opacity():\n            value |= COPY_OPACITY_BIT\n\n        writer.write_u8(value)\n\n        self.hsv.to_binary(binary, order, version)\n\n        opacity = self.opacity\n\n        if opacity is not None:\n            writer.write_f32(opacity)\n\n    def is_copied(self) -&gt; bool:\n        return True\n\n    def is_copy_opacity(self) -&gt; bool:\n        return self.opacity is None\n\n    def copy_opacity(self: CCC) -&gt; CCC:\n        self.opacity = None\n\n        return self\n</code></pre>"},{"location":"reference/api/color_channels/#gd.api.color_channels.ColorChannels","title":"<code>ColorChannels</code>","text":"<p>         Bases: <code>Dict[int, ColorChannel]</code>, <code>Binary</code></p> <p>Represents collections of color channels.</p> Binary <pre><code>enum ColorChannel {\nPlayer(PlayerColorChannel),\nNormal(NormalColorChannel),\nCopied(CopiedColorChannel),\n}\n\nstruct ColorChannels {\ncolor_channels_length: u16,\ncolor_channels: [ColorChannel; color_channels_length],\n}\n</code></pre> Source code in <code>gd/api/color_channels.py</code> <pre><code>class ColorChannels(Dict[int, ColorChannel], Binary):\n\"\"\"Represents collections of color channels.\n\n    Binary:\n        ```rust\n        enum ColorChannel {\n            Player(PlayerColorChannel),\n            Normal(NormalColorChannel),\n            Copied(CopiedColorChannel),\n        }\n\n        struct ColorChannels {\n            color_channels_length: u16,\n            color_channels: [ColorChannel; color_channels_length],\n        }\n        ```\n    \"\"\"\n\n    def copy(self: CCS) -&gt; CCS:\n        return type(self)(self)\n\n    @classmethod\n    def from_color_channel_iterable(cls: Type[CCS], color_channels: Iterable[ColorChannel]) -&gt; CCS:\n        return cls({color_channel.id: color_channel for color_channel in color_channels})\n\n    @classmethod\n    def from_color_channels(cls: Type[CCS], *color_channels: ColorChannel) -&gt; CCS:\n        return cls.from_color_channel_iterable(color_channels)\n\n    @property\n    def length(self) -&gt; int:\n        return len(self)\n\n    def add(self, color_channel: ColorChannel) -&gt; None:\n        self[color_channel.id] = color_channel\n\n    @classmethod\n    def from_robtop(cls: Type[CCS], string: str) -&gt; CCS:\n        return cls.from_color_channel_iterable(\n            iter(split_color_channels(string)).filter(None).map(color_channel_from_robtop).unwrap()\n        )\n\n    def to_robtop(self) -&gt; str:\n        return concat_color_channels(map(color_channel_to_robtop, self.values()))\n\n    @classmethod\n    def from_binary(\n        cls: Type[CCS],\n        binary: BinaryReader,\n        order: ByteOrder = ByteOrder.DEFAULT,\n        version: int = VERSION,\n    ) -&gt; CCS:\n        reader = Reader(binary, order)\n\n        length = reader.read_u16()\n\n        color_channel_from_binary_function = partial(\n            color_channel_from_binary, binary, order, version\n        )\n\n        color_channels = iter.repeat_exactly_with(\n            color_channel_from_binary_function, length\n        ).unwrap()\n\n        return cls.from_color_channel_iterable(color_channels)\n\n    def to_binary(\n        self, binary: BinaryWriter, order: ByteOrder = ByteOrder.DEFAULT, version: int = VERSION\n    ) -&gt; None:\n        writer = Writer(binary, order)\n\n        writer.write_u16(self.length)\n\n        for color_channel in self.values():\n            color_channel_to_binary(color_channel, binary, order, version)\n</code></pre>"},{"location":"reference/api/editor/","title":"Editor","text":""},{"location":"reference/api/editor/#gd.api.editor.Editor","title":"<code>Editor</code>","text":"<p>         Bases: <code>RobTop</code>, <code>Binary</code>, <code>Sequence[Object]</code></p> <p>Represents editors.</p> Binary <pre><code>struct Editor {\nheader: Header,\nobjects_length: u32,\nobjects: [Object; objects_length],\n}\n</code></pre> Source code in <code>gd/api/editor.py</code> <pre><code>@define()\nclass Editor(RobTop, Binary, Sequence[Object]):\n\"\"\"Represents editors.\n\n    Binary:\n        ```rust\n        struct Editor {\n            header: Header,\n            objects_length: u32,\n            objects: [Object; objects_length],\n        }\n        ```\n    \"\"\"\n\n    header: Header = field(factory=Header)\n\"\"\"The header of the editor.\"\"\"\n    objects: List[Object] = field(factory=list)\n\"\"\"The objects of the editor.\"\"\"\n\n    @classmethod\n    def from_objects(cls: Type[E], *objects: Object, header: Header) -&gt; E:\n        return cls(header, list(objects))\n\n    @classmethod\n    def from_object_iterable(cls: Type[E], objects: Iterable[Object], header: Header) -&gt; E:\n        return cls(header, list(objects))\n\n    def __len__(self) -&gt; int:\n        return len(self.objects)\n\n    @overload\n    def __getitem__(self, index: int) -&gt; Object:\n        ...\n\n    @overload\n    def __getitem__(self: E, index: slice) -&gt; E:\n        ...\n\n    def __getitem__(self: E, index: Union[int, slice]) -&gt; Union[Object, E]:\n        if is_slice(index):\n            return self.from_object_iterable(self.objects[index], self.header)\n\n        return self.objects[index]  # type: ignore\n\n    @property\n    def color_channels(self) -&gt; ColorChannels:\n        return self.header.color_channels\n\n    def set_header(self: E, header: Header) -&gt; E:\n        self.header = header\n\n        return self\n\n    def set_color_channels(self: E, color_channels: ColorChannels) -&gt; E:\n        self.header.color_channels = color_channels\n\n        return self\n\n    @wrap_iter\n    def iter_groups(self) -&gt; Iterator[int]:\n        for object in self.objects:\n            yield from object.groups\n\n            if has_target_group(object):\n                yield object.target_group_id\n\n            if has_additional_group(object):\n                yield object.additional_group_id\n\n    @property\n    def groups(self) -&gt; Set[int]:\n        return self.iter_groups().set()\n\n    @property\n    def free_group(self) -&gt; int:\n        return find_next(self.groups)\n\n    @wrap_iter\n    def iter_color_ids(self) -&gt; Iterator[int]:\n        for object in self.objects:\n            yield object.base_color_id\n            yield object.detail_color_id\n\n        yield from self.color_channels\n\n    @property\n    def color_ids(self) -&gt; Set[int]:\n        return self.iter_color_ids().set()\n\n    @property\n    def free_color_id(self) -&gt; int:\n        return find_next(self.color_ids)\n\n    @wrap_iter\n    def iter_start_positions(self) -&gt; Iterator[StartPosition]:\n        return filter(is_start_position, self.objects)\n\n    @property\n    def start_position(self) -&gt; List[StartPosition]:\n        return self.iter_start_positions().sorted_by(get_x)\n\n    @wrap_iter\n    def iter_portals(self) -&gt; Iterator[Object]:\n        return (object for object in self.objects if object.is_portal())\n\n    @property\n    def portals(self) -&gt; List[Object]:\n        return self.iter_portals().sorted_by(get_x)\n\n    @wrap_iter\n    def iter_speed_changes(self) -&gt; Iterator[Object]:\n        return (object for object in self.objects if object.is_speed_change())\n\n    @property\n    def speed_changes(self) -&gt; List[Object]:\n        return self.iter_speed_changes().sorted_by(get_x)\n\n    @wrap_iter\n    def iter_triggers(self) -&gt; Iterator[Trigger]:\n        return filter(is_trigger, self.objects)\n\n    @property\n    def triggers(self) -&gt; List[Trigger]:\n        return self.iter_triggers().sorted_by(get_x)\n\n    @property\n    def x_length(self) -&gt; float:\n        return iter(self.objects).map(get_x).max().unwrap_or(DEFAULT_X)\n\n    @property\n    def start_speed(self) -&gt; Speed:\n        return self.header.speed\n\n    @property\n    def length(self) -&gt; float:\n        return time_length(self.x_length, self.start_speed, self.speed_changes)\n\n    @classmethod\n    def from_binary(\n        cls: Type[E],\n        binary: BinaryReader,\n        order: ByteOrder = ByteOrder.DEFAULT,\n        version: int = VERSION,\n    ) -&gt; E:\n        header = Header.from_binary(binary, order, version)\n\n        reader = Reader(binary, order)\n\n        iterable_length = reader.read_u32()\n\n        object_from_binary_function = partial(object_from_binary, binary, order, version)\n\n        iterable = iter.repeat_exactly_with(object_from_binary_function, iterable_length).unwrap()\n\n        return cls.from_object_iterable(iterable, header)\n\n    def to_binary(\n        self, binary: BinaryWriter, order: ByteOrder = ByteOrder.DEFAULT, version: int = VERSION\n    ) -&gt; None:\n        self.header.to_binary(binary, order, version)\n\n        writer = Writer(binary, order)\n\n        objects = self.objects\n\n        writer.write_u32(len(objects))\n\n        for object in objects:\n            object_to_binary(object, binary, order, version)\n\n    @classmethod\n    def from_robtop(cls: Type[E], string: str) -&gt; E:\n        iterator = iter(split_objects(string)).filter(None)\n\n        header_option = iterator.next().extract()\n\n        if header_option is None:\n            header = Header()\n\n        else:\n            header = Header.from_robtop(header_option)\n\n        objects = iterator.map(object_from_robtop).collect_iter(migrate_objects).list()\n\n        return cls(header, objects)\n\n    def to_robtop(self) -&gt; str:\n        return (\n            iter(self.objects)\n            .map(object_to_robtop)\n            .prepend(self.header.to_robtop())\n            .collect(concat_objects)\n        )\n\n    @staticmethod\n    def can_be_in(string: str) -&gt; bool:\n        return OBJECTS_SEPARATOR in string\n</code></pre>"},{"location":"reference/api/editor/#gd.api.editor.Editor.header","title":"<code>header: Header = field(factory=Header)</code>  <code>instance-attribute</code> <code>class-attribute</code>","text":"<p>The header of the editor.</p>"},{"location":"reference/api/editor/#gd.api.editor.Editor.objects","title":"<code>objects: List[Object] = field(factory=list)</code>  <code>instance-attribute</code> <code>class-attribute</code>","text":"<p>The objects of the editor.</p>"},{"location":"reference/api/editor/#gd.api.editor.time_length","title":"<code>time_length(distance: float, start_speed: Speed = Speed.NORMAL, speed_changes: Iterable[Object] = ()) -&gt; float</code>","text":"<p>Computes the time (in seconds) to travel from <code>0</code> to <code>distance</code>, respecting speed portals.</p> <p>Parameters:</p> Name Type Description Default <code>distance</code> <code>float</code> <p>The distance to stop calculating at.</p> required <code>start_speed</code> <code>Speed</code> <p>The starting speed (found in the header).</p> <code>Speed.NORMAL</code> <code>speed_changes</code> <code>Iterable[Object]</code> <p>Speed changes in the level, ordered by <code>x</code> position.</p> <code>()</code> <p>Returns:</p> Type Description <code>float</code> <p>The calculated time (in seconds).</p> Source code in <code>gd/api/editor.py</code> <pre><code>def time_length(\n    distance: float,\n    start_speed: Speed = Speed.NORMAL,\n    speed_changes: Iterable[Object] = (),\n) -&gt; float:\n\"\"\"Computes the time (in seconds) to travel from `0` to `distance`, respecting speed portals.\n\n    Parameters:\n        distance: The distance to stop calculating at.\n        start_speed: The starting speed (found in the header).\n        speed_changes: Speed changes in the level, ordered by `x` position.\n\n    Returns:\n        The calculated time (in seconds).\n    \"\"\"\n    magic = SPEED_TO_MAGIC[start_speed]\n\n    if not speed_changes:\n        return distance / magic\n\n    last_x = 0.0\n    total = 0.0\n\n    for speed_change in speed_changes:\n        x = speed_change.x\n\n        if x &gt; distance:\n            break\n\n        delta = x - last_x\n\n        total += delta / magic\n\n        magic = SPEED_CHANGE_TO_MAGIC[SpeedChangeType(speed_change.id)]\n\n        last_x = x\n\n    delta = distance - last_x\n\n    total += delta / magic\n\n    return total\n</code></pre>"},{"location":"reference/api/folder/","title":"Folder","text":""},{"location":"reference/api/folder/#gd.api.folder.Folder","title":"<code>Folder</code>","text":"<p>         Bases: <code>Binary</code></p> <p>Represents level folders.</p> Binary <pre><code>struct Folder {\nid: u8,\nname_length: u8,\nname: [u8; name_length],  // utf-8 string\n}\n</code></pre> Source code in <code>gd/api/folder.py</code> <pre><code>@define()\nclass Folder(Binary):\n\"\"\"Represents level folders.\n\n    Binary:\n        ```rust\n        struct Folder {\n            id: u8,\n            name_length: u8,\n            name: [u8; name_length],  // utf-8 string\n        }\n        ```\n    \"\"\"\n\n    id: int\n\"\"\"The ID of the folder.\"\"\"\n    name: str\n\"\"\"The name of the folder.\"\"\"\n\n    def __hash__(self) -&gt; int:\n        return self.id\n\n    @classmethod\n    def from_binary(\n        cls: Type[F],\n        binary: BinaryReader,\n        order: ByteOrder = ByteOrder.DEFAULT,\n        version: int = VERSION,\n        encoding: str = DEFAULT_ENCODING,\n        errors: str = DEFAULT_ERRORS,\n    ) -&gt; F:\n        reader = Reader(binary, order)\n\n        id = reader.read_u8()\n\n        name_length = reader.read_u8()\n\n        name = reader.read(name_length).decode(encoding, errors)\n\n        return cls(id, name)\n\n    def to_binary(\n        self,\n        binary: BinaryWriter,\n        order: ByteOrder = ByteOrder.DEFAULT,\n        version: int = VERSION,\n        encoding: str = DEFAULT_ENCODING,\n        errors: str = DEFAULT_ERRORS,\n    ) -&gt; None:\n        writer = Writer(binary, order)\n\n        writer.write_u8(self.id)\n\n        data = self.name.encode(encoding, errors)\n\n        writer.write_u8(len(data))\n\n        writer.write(data)\n</code></pre>"},{"location":"reference/api/folder/#gd.api.folder.Folder.id","title":"<code>id: int</code>  <code>instance-attribute</code>","text":"<p>The ID of the folder.</p>"},{"location":"reference/api/folder/#gd.api.folder.Folder.name","title":"<code>name: str</code>  <code>instance-attribute</code>","text":"<p>The name of the folder.</p>"},{"location":"reference/api/guidelines/","title":"Guidelines","text":""},{"location":"reference/api/guidelines/#gd.api.guidelines.Guidelines","title":"<code>Guidelines</code>","text":"<p>         Bases: <code>Dict[float, GuidelineColor]</code>, <code>RobTop</code>, <code>Binary</code></p> <p>Represents guidelines.</p> Binary <pre><code>struct Guideline {\ntimestamp: f32,\ncolor: f32,\n}\n\nstruct Guidelines {\nguidelines_length: u32,\nguidelines: [Guideline; guidelines_length],\n}\n</code></pre> Source code in <code>gd/api/guidelines.py</code> <pre><code>class Guidelines(Dict[float, GuidelineColor], RobTop, Binary):\n\"\"\"Represents guidelines.\n\n    Binary:\n        ```rust\n        struct Guideline {\n            timestamp: f32,\n            color: f32,\n        }\n\n        struct Guidelines {\n            guidelines_length: u32,\n            guidelines: [Guideline; guidelines_length],\n        }\n        ```\n    \"\"\"\n\n    def add(self, timestamp: float, color: GuidelineColor = GuidelineColor.DEFAULT) -&gt; None:\n\"\"\"Adds the guideline described by `timestamp` and `color`.\n\n        Arguments:\n            timestamp: The timestamp of the guideline.\n            color: The color of the guideline.\n\n        Example:\n            ```python\n            &gt;&gt;&gt; guidelines = Guidelines()\n            &gt;&gt;&gt; guidelines.add(1.0, GuidelineColor.GREEN)\n            &gt;&gt;&gt; guidelines\n            {1.0: &lt;GuidelineColor.GREEN: 1.0&gt;}\n            ```\n        \"\"\"\n        self[timestamp] = color\n\n    @classmethod\n    def from_binary(\n        cls: Type[G],\n        binary: BinaryReader,\n        order: ByteOrder = ByteOrder.DEFAULT,\n        version: int = VERSION,\n    ) -&gt; G:\n        rounding = DEFAULT_ROUNDING\n\n        reader = Reader(binary, order)\n\n        length = reader.read_u32()\n\n        color = GuidelineColor\n\n        return cls(\n            {\n                round(reader.read_f32(), rounding): color(round(reader.read_f32(), rounding))\n                for _ in range(length)\n            }\n        )\n\n    def to_binary(\n        self, binary: BinaryWriter, order: ByteOrder = ByteOrder.DEFAULT, version: int = VERSION\n    ) -&gt; None:\n        writer = Writer(binary, order)\n\n        writer.write_u32(len(self))\n\n        for timestamp, color in self.items():\n            writer.write_f32(timestamp)\n            writer.write_f32(color.value)\n\n    @classmethod\n    def from_robtop(cls: Type[G], string: str) -&gt; G:\n        color = GuidelineColor\n\n        return cls(\n            {timestamp: color(value) for timestamp, value in split_guidelines(string).items()}\n        )\n\n    def to_robtop(self) -&gt; str:\n        return concat_guidelines({timestamp: color.value for timestamp, color in self.items()})\n\n    @staticmethod\n    def can_be_in(string: str) -&gt; bool:\n        return GUIDELINES_SEPARATOR in string\n</code></pre>"},{"location":"reference/api/guidelines/#gd.api.guidelines.Guidelines.add","title":"<code>add(timestamp: float, color: GuidelineColor = GuidelineColor.DEFAULT) -&gt; None</code>","text":"<p>Adds the guideline described by <code>timestamp</code> and <code>color</code>.</p> <p>Parameters:</p> Name Type Description Default <code>timestamp</code> <code>float</code> <p>The timestamp of the guideline.</p> required <code>color</code> <code>GuidelineColor</code> <p>The color of the guideline.</p> <code>GuidelineColor.DEFAULT</code> Example <pre><code>&gt;&gt;&gt; guidelines = Guidelines()\n&gt;&gt;&gt; guidelines.add(1.0, GuidelineColor.GREEN)\n&gt;&gt;&gt; guidelines\n{1.0: &lt;GuidelineColor.GREEN: 1.0&gt;}\n</code></pre> Source code in <code>gd/api/guidelines.py</code> <pre><code>def add(self, timestamp: float, color: GuidelineColor = GuidelineColor.DEFAULT) -&gt; None:\n\"\"\"Adds the guideline described by `timestamp` and `color`.\n\n    Arguments:\n        timestamp: The timestamp of the guideline.\n        color: The color of the guideline.\n\n    Example:\n        ```python\n        &gt;&gt;&gt; guidelines = Guidelines()\n        &gt;&gt;&gt; guidelines.add(1.0, GuidelineColor.GREEN)\n        &gt;&gt;&gt; guidelines\n        {1.0: &lt;GuidelineColor.GREEN: 1.0&gt;}\n        ```\n    \"\"\"\n    self[timestamp] = color\n</code></pre>"},{"location":"reference/memory/internal/","title":"Internal","text":"<p>Internal memory interfaces for different platforms.</p>"},{"location":"reference/memory/internal/#gd.memory.internal--functions","title":"Functions","text":"<ul> <li><code>open</code></li> <li><code>close</code></li> <li><code>terminate</code></li> <li><code>allocate</code></li> <li><code>free</code></li> <li><code>protect</code></li> <li><code>read</code></li> <li><code>write</code></li> <li><code>get_base_address</code></li> <li><code>get_base_address_from_handle</code>?</li> <li><code>get_process_bits</code></li> <li><code>get_process_bits_from_handle</code>?</li> <li><code>get_process_id_from_name</code></li> <li><code>get_process_id_from_title</code>?</li> </ul> <p>Functions marked with <code>?</code> are not required for the library to work.</p>"}]}